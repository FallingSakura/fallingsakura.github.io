<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Programming, JavaScript, C++, Python, Computer Science, AI, Web, Knowledge, Blog"><meta name="author" content="Falling_Sakura"><script>(function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();</script><style>:root[data-theme=dark]{--background-color:#202124;--background-color-transparent:rgba(32, 33, 36, 0.6);--second-background-color:#2d2e32;--third-background-color:#34353a;--third-background-color-transparent:rgba(32, 33, 36, 0.6);--primary-color:#0066CC;--first-text-color:#ffffff;--second-text-color:#eeeeee;--third-text-color:#bebec6;--fourth-text-color:#999999;--default-text-color:#bebec6;--invert-text-color:#373D3F;--border-color:rgba(255, 255, 255, 0.08);--selection-color:#0066CC;--shadow-color-1:rgba(255, 255, 255, 0.08);--shadow-color-2:rgba(255, 255, 255, 0.05)}:root[data-theme=light]{--background-color:#fff;--background-color-transparent:rgba(255, 255, 255, 0.6);--second-background-color:#f8f8f8;--third-background-color:#f2f2f2;--third-background-color-transparent:rgba(241, 241, 241, 0.6);--primary-color:#0066CC;--first-text-color:#16171a;--second-text-color:#2f3037;--third-text-color:#5e5e5e;--fourth-text-color:#eeeeee;--default-text-color:#373D3F;--invert-text-color:#bebec6;--border-color:rgba(0, 0, 0, 0.08);--selection-color:#0066CC;--shadow-color-1:rgba(0, 0, 0, 0.08);--shadow-color-2:rgba(0, 0, 0, 0.05)}body{background-color:var(--background-color);color:var(--default-text-color)}:root[data-theme=dark] body{background-color:var(--background-color);color:var(--default-text-color)}</style><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="canonical" href="http://vercel.fallingsakura.top/48659.html"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:type" content="article"><meta property="og:title" content="DP"><meta property="og:url" content="http://vercel.fallingsakura.top/48659.html"><meta property="og:site_name" content="Falling Blog"><meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:locale" content="en_US"><meta property="og:image" content="http://vercel.fallingsakura.top/images/redefine-og.webp"><meta property="article:published_time" content="2023-03-26T12:53:16.000Z"><meta property="article:modified_time" content="2025-09-24T02:24:52.646Z"><meta property="article:author" content="Falling_Sakura"><meta property="article:tag" content="Programming, JavaScript, C++, Python, Computer Science, AI, Web, Knowledge, Blog"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://vercel.fallingsakura.top/images/redefine-og.webp"><link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/favicon.ico" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/favicon.ico"><meta name="theme-color" content="#EE9CA7"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/favicon.ico"><title>DP | Falling Blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fonts/Chillax/chillax.css"><link rel="stylesheet" href="https://lib.baomitu.com/KaTeX/latest/katex.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/css/build/tailwind.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fonts/Geist/geist.css"><link href="/custom/fonts.css" rel="stylesheet"><link href="/custom/fonts.css" rel="stylesheet"><link href="" rel="stylesheet"><link href="" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/anime.min.js"></script><script id="hexo-configurations">window.config={hostname:"vercel.fallingsakura.top",root:"/",language:"en",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"2.2rem",h2:"2rem",h3:"1.8rem",h4:"1.6rem",h5:"1.5rem",h6:"1.4rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!1,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"atom-one-light",dark:"atom-one-dark"},font:{enable:!0,family:"Fira",url:"/custom/fonts.css"}},toc:{enable:!0,max_depth:3,number:!0,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!1,recommendation:{enable:!1,title:"Recommendation",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#EE9CA7",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!0,family:"Noto Sans SC",url:null},english:{enable:!0,family:"Ubuntu Mono",url:null},title:{enable:!1,family:null,url:null}},content_max_width:"950px",sidebar_width:"200px",hover:{shadow:!0,scale:!0},scroll_progress:{bar:!0,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!0,custom_message:null},side_tools:{gear_rotation:!0,auto_expand:!1},open_graph:{enable:!0,image:"/images/redefine-og.webp",description:"Hexo Theme Redefine, Redefine Your Hexo Journey."},google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202309291412615.webp",dark:"https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202309291412607.webp"},title:"Falling Blog",subtitle:{text:[],hitokoto:{enable:!1,show_author:!1,api:"https://v1.hitokoto.cn"},typing_speed:80,backing_speed:120,starting_delay:500,backing_delay:2e3,loop:!0,smart_backspace:!0},text_color:{light:"#fafafa",dark:"#d76694"},text_style:{title_size:"4.6rem",subtitle_size:"1.5rem",line_height:1.8},custom_font:{enable:!0,family:"Kaushan Script",url:"/custom/fonts.css"},social_links:{enable:!0,style:"default",links:{github:"https://github.com/FallingSakura",instagram:null,zhihu:"https://www.zhihu.com/people/fsimh",twitter:"https://x.com/SakuraFalling1",email:"mailto:dbw1732351264@163.com"},qrs:{weixin:"https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202309291446101.webp",qq:"https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202309291451534.webp"}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:"METHOD_HYMME_AMENOFLAME/.",artist:"stellatram",url:"https://music.163.com/song/media/outer/url?id=471403213.mp3",cover:"https://p3.music.126.net/cPwdlJxGCtX0e2L3SMQksg==/18915998044327357.jpg",lrc:null},{name:"忘れじの言の葉 - 安次嶺希和子",artist:"安次嶺希和子",url:"https://music.163.com/song/media/outer/url?id=432698934.mp3",cover:"https://p3.music.126.net/EnzRjx6TAtWsVKohfRm99w==/1373290038991137.jpg"},{name:"夜街，骤雨和启明星",artist:"鹤见江野",url:"https://music.163.com/song/media/outer/url?id=1429787173.mp3",cover:"https://p3.music.126.net/JOM1EU4wNWyLqpPA3GLTqQ==/109951164789573814.jpg"},{name:"海森堡童话",artist:"Strictlyviolin荀博 / 王朝",url:"https://music.163.com/song/media/outer/url?id=2008978774.mp3",cover:"https://p4.music.126.net/hSM0qHLHuYT388Xm1qJ9dw==/109951168171015319.jpg"},{name:"幽雅に咲かせ、墨染の桜 ~ Border of Life",artist:"ファクトリー・ノイズ&AG",url:"https://music.163.com/song/media/outer/url?id=732206.mp3",cover:"https://p4.music.126.net/m8W2vORGGnzgFRrh4PYmzg==/648711860399964.jpg"}]},mermaid:{enable:!0,version:"11.4.1"}},version:"2.8.5",navbar:{auto_hide:!1,color:{left:"#78617d",right:"#b2a1ef",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},Categories:{path:"/categories",icon:"fa-regular fa-folder"},About:{icon:"fa-regular fa-user",path:"/about"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:"Nothing for nothing.",show_on_mobile:!0,links:{Archives:{path:"/archives",icon:"fa-regular fa-archive"},Tags:{path:"/tags",icon:"fa-regular fa-tags"},Links:{path:"/friends",icon:"fa-regular fa-link"},Essays:{path:"/essays",icon:"fa-regular fa-message-heart"},Photos:{path:"/gallery",icon:"fa-regular fa-images"}}},article_date_format:"auto",excerpt_length:80,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2023/2/19 11:45:14"},window.lang_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},window.data={masonry:!0}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fontawesome/brands.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fontawesome/solid.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fontawesome/regular.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fontawesome/sharp-solid.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span></div><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><h2 class="ml13">Falling Blog</h2><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({ loop: true })
            .add({
                targets: '.ml13 .letter',
                translateY: [20, 0],
                translateZ: 0,
                opacity: [0, 1],
                filter: ['blur(5px)', 'blur(0px)'],
                easing: "easeOutExpo",
                duration: 1200,
                delay: (el, i) => 300 + 20 * i,
            })
            .add({
                targets: '.ml13 .letter',
                translateY: [0, -20],
                opacity: [1, 0],
                filter: ['blur(0px)', 'blur(5px)'],
                easing: "easeInExpo",
                duration: 1000,
                delay: (el, i) => 15 * i,
                complete: function() {
                    hidePreloader();
                }
            }, '-=700');


        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }</script></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">Falling Blog</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> HOME</a></li><li class="navbar-item"><a href="/categories"><i class="fa-regular fa-folder fa-fw"></i> CATEGORIES</a></li><li class="navbar-item"><a href="/about"><i class="fa-regular fa-user fa-fw"></i> ABOUT</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>HOME </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories"><span>CATEGORIES </span><i class="fa-regular fa-folder fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/about"><span>ABOUT </span><i class="fa-regular fa-user fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/archives"><span>Archives</span> <i class="fa-regular fa-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags"><span>Tags</span> <i class="fa-regular fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/friends"><span>Links</span> <i class="fa-regular fa-link fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/essays"><span>Essays</span> <i class="fa-regular fa-message-heart fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/gallery"><span>Photos</span> <i class="fa-regular fa-images fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">22</div><div class="label text-third-text-color text-sm">Tags</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">9</div><div class="label text-third-text-color text-sm">Categories</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">33</div><div class="label text-third-text-color text-sm">Posts</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">DP</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202305211656851.webp"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Falling_Sakura</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2023-03-26 20:53:16</span> <span class="mobile">2023-03-26 20:53:16</span> <span class="hover-info">Created</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-09-24 10:24:52</span> <span class="mobile">2025-09-24 10:24:52</span> <span class="hover-info">Updated</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/ACM/">ACM</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>21.2k Words</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>98 Mins</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><blockquote><p>状态本质是图论中一个个点，转移对应一条条边</p><p>复杂度分析：状态数量 $\times$ 状态计算</p></blockquote><h1 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h1><ul><li>路径类</li><li>序列类</li><li>组合类</li></ul><h2 id="1-状态"><a href="#1-状态" class="headerlink" title="1.状态"></a>1.状态</h2><ul><li>题目中有很多状态，而这些状态间存在某些关系的题目。</li></ul><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303122107009.webp" alt="image.webp"></p><p>所谓状态，就是你当前处于哪个场景的概念。</p><p>比如我现在手里有六个骰子，</p><p>那么就有 ${6}\times{6}\times{6}$ 也就是 $216$ 种场景，</p><p>变量的组合便是状态。</p><h2 id="2-转移方程"><a href="#2-转移方程" class="headerlink" title="2.转移方程"></a>2.转移方程</h2><p>状态与状态之间的关系（点与点之间的边）。</p><p>要根据具体题目进行设计。</p><h3 id="典例"><a href="#典例" class="headerlink" title="典例"></a>典例</h3><ul><li>斐波那契数列</li></ul><p>这是最常见的一个递推。</p><p>那么怎么进行<code>DP</code>呢？</p><p>想想状态和什么有关系——当前这一项和前两项有关系，后两项与当前状态有关系。</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303122117603.webp" alt="image.webp"></p><p>那么就有了<code>DP</code>的两种写法：</p><p>1.自己求别人</p><p>2.别人求自己</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303122120900.webp" alt="image.webp"></p><p>根据题目选择不同的 $\text{DP}$ 方式</p><h2 id="3-记忆化搜索"><a href="#3-记忆化搜索" class="headerlink" title="3.记忆化搜索"></a>3.记忆化搜索</h2><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303161201695.webp" alt="image.webp"></p><p>复杂度 $O(N)$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303161204384.webp" alt="image.webp"></p><p>特征方程法解通项公式。</p><h2 id="闫式思考法"><a href="#闫式思考法" class="headerlink" title="闫式思考法"></a>闫式思考法</h2><h3 id="矩阵路线问题"><a href="#矩阵路线问题" class="headerlink" title="矩阵路线问题"></a>矩阵路线问题</h3><ul><li>状态表示<ul><li>$f_{i,j}$</li><li>表示一类<strong>集合</strong>：所有从 $(1,1)$ 到 $(i,j)$ 的路线。</li><li><strong>属性</strong>：最大值&#x2F;最小值&#x2F;方案数。</li></ul></li><li>状态计算<ul><li>集合的划分<ul><li>划分依据：<strong>最后</strong>，本例中为最后一步从上面下来还是从左边过来。<ul><li>从上边过来：$(1,1)\to(i-1,j)\to(i,j)$</li><li>从左面过来：$(1,1)\to(i,j-1)\to(i,j)$</li><li>两部分取一个 $\max$，分而治之，将集合进行一个划分。</li></ul></li><li>划分原则：<ul><li>不重（求最值等无所谓）</li><li><strong>不漏</strong></li></ul></li></ul></li><li>计算顺序<ul><li>按照拓扑序计算，保证每个状态计算时它的依赖状态已经被计算过了。</li></ul></li></ul></li></ul><p>截图：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310251414839.webp" alt="image.png"></p><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1029/">方格取数<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310251442381.webp" alt="image.png"></p><h3 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h3><ul><li>状态表示<ul><li>集合：所有以 $a_i$ 结尾的严格单调上升子序列</li><li>属性：Max&#x2F;Min&#x2F;数量</li></ul></li><li>状态计算<ul><li>集合——分而治之。</li><li>通过<strong>最后一步</strong>划分：最后一步是 $a_i$</li></ul></li></ul><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1019/">A1017<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p>正序倒叙分别求两遍最长上升子序列取最大值即可。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[<span class="number">110</span>], f[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">                <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                    f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt; i; j--)</span><br><span class="line">                <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                    f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>状态划分<ul><li>先增后减，根据中间点分类。</li></ul></li></ul><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1016/">A1014<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">1100</span>];</span><br><span class="line"><span class="type">int</span> g[<span class="number">1100</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt; i; j--)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                g[i] = <span class="built_in">max</span>(g[i], g[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i] + g[i] - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1014/">A1012 友好城市<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p>两岸，一边看作自变量，一边看作因变量，在自变量不断递增的过程中，因变量也要是单调递增的，对自变量排下序，对因变量求最长上升子序列，这样就转化成了一个最长上升子序列问题。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line">PII q[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;q[i].first, &amp;q[i].second);</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(q[i].second &gt; q[j].second)</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1018/">A1016 最大上升子序列和<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><ul><li>状态表示<ul><li>$f_i$</li><li>集合：所有以 $a_i$ 结尾的上升子序列</li><li>属性：和的最大值</li></ul></li><li>状态计算：倒数第二个数</li></ul><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i ; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + a[i]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="导弹拦截"><a href="#导弹拦截" class="headerlink" title="导弹拦截"></a>导弹拦截</h3><ul><li>贪心流程：<ul><li>情况1：如果现有的子序列结尾都小于当前数，那么就创建新的子序列</li><li>情况2：把当前数放到结尾大于等于它的最小的子序列后面。因为要把结尾尽可能大的保持住，这样后面才会有更多的机会。</li></ul></li><li>证明贪心正确性<ul><li>如何证明两个数相等？<ul><li>A表示贪心算法得到的序列个数，B表示最优解 $A\le B,B\le A$</li><li>由于 B 是最优解，因此 $B\le A$</li><li>使用调整法，假设最优解对应的方案和当前方案不同，那么必然会存在第一个不同的位置。贪心法一定会把这个数分配到一个大于等于它的最小的子序列的后面，最优解也会放到某个序列后面，它们之后的序列就可以是一样的，就可以把它们交换，使得贪心法成为最优解，同时没有增加子序列的个数，所以 $A\le B$。</li><li>此题得证。</li></ul></li></ul></li></ul><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1012/">A1010<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; q[n]) n++;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(q[j] &gt;= q[i])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>; <span class="comment">// 枚举序列</span></span><br><span class="line">        <span class="keyword">while</span>(k &lt; cnt &amp;&amp; g[k] &lt; q[i]) k++;</span><br><span class="line">        g[k] = q[i]; <span class="comment">// 第一个结尾大于等于该数的序列 | g 是单调的</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt;= cnt) cnt++; <span class="comment">// 新开一个序列</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/189/">A187<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p>每个位置有两种选择，两种决策，要考虑所有情况，没办法归类，只能直接爆搜。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> up[N], down[N]; <span class="comment">// 所有子序列中最后一个数的集合</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 占用空间太大 并且不好剪枝</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> su, <span class="type">int</span> sd)</span> <span class="comment">// 当前枚举到第几个数 上升子序列有多少 下降子序列有多少</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(su + sd &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = su + sd; <span class="comment">// 能到就可以更新</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放到上升子序列里</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &lt; su &amp;&amp; up[k] &gt;= q[u]) k++; <span class="comment">// q[u] &gt; up[k] 且 up[k] 最大 | up数组单调递减</span></span><br><span class="line">    <span class="type">int</span> t = up[k]; <span class="comment">// 备份 方便恢复现场</span></span><br><span class="line">    up[k] = q[u];</span><br><span class="line">    <span class="keyword">if</span>(k &lt; su) <span class="built_in">dfs</span>(u + <span class="number">1</span>, su, sd);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">dfs</span>(u + <span class="number">1</span>, su + <span class="number">1</span>, sd);</span><br><span class="line">    up[k] = t;</span><br><span class="line">    <span class="comment">// 放到下降子序列里</span></span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &lt; sd &amp;&amp; down[k] &lt;= q[u]) k++; <span class="comment">// q[u] &lt; down[k] 且 down[k] 最小 | down数组单调递增</span></span><br><span class="line">    t = down[k];</span><br><span class="line">    down[k] = q[u];</span><br><span class="line">    <span class="keyword">if</span>(k &lt; sd) <span class="built_in">dfs</span>(u + <span class="number">1</span>, su, sd);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">dfs</span>(u + <span class="number">1</span>, su, sd + <span class="number">1</span>);</span><br><span class="line">    down[k] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; q[i];</span><br><span class="line">        ans = n;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><ul><li>状态表示<ul><li>$f_{i,j}$</li><li>集合：所有由第一个序列的前 $i$ 个字母，第二个序列的前 $j$ 个字母且以 $b_j$ 结尾的公共上升子序列</li><li>属性：最大长度</li></ul></li><li>状态计算<ul><li>分而治之，对每一个部分求最大值。</li><li>所有包含 $a_i$ 的公共上升子序列<ul><li>根据倒数第二个元素划分。</li><li>$f_{i,k}$</li></ul></li><li>所有不包含 $a_i$ 的公共上升子序列：$f_{i-1,j}$</li></ul></li><li>优化<ul><li>DP 的优化一般思路不变，只是对代码进行等价变形。</li></ul></li></ul><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310261903620.webp" alt="image.png"></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> maxv = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">// f[i][j] = max(f[i][j], 1); // 更新空集</span></span><br><span class="line">                <span class="comment">// for(int k = 1; k &lt; j; k++) // 实际上就是在求 f[i][j] + 1 的前缀最大值不含第 j 位</span></span><br><span class="line">                <span class="comment">//     if(b[k] &lt; a[i])</span></span><br><span class="line">                <span class="comment">//     &#123;</span></span><br><span class="line">                <span class="comment">//         f[i][j] = max(f[i][j], f[i][k] + 1);</span></span><br><span class="line">                <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">/* 等效代码 */</span></span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j], maxv);</span><br><span class="line">            <span class="keyword">if</span>(b[j] &lt; a[i]) maxv = <span class="built_in">max</span>(maxv, f[i - <span class="number">1</span>][j] + <span class="number">1</span>); <span class="comment">// 维护 f[i][j] + 1 这个变量的前缀最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="组合数问题（杨辉三角）"><a href="#组合数问题（杨辉三角）" class="headerlink" title="组合数问题（杨辉三角）"></a>组合数问题（杨辉三角）</h2><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303161208890.webp" alt="image.webp"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303161208268.webp" alt="image.webp"></p><h2 id="过河卒但是没有🐎"><a href="#过河卒但是没有🐎" class="headerlink" title="过河卒但是没有🐎"></a>过河卒但是没有🐎</h2><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303262027794.webp" alt="image.webp"></p><p>每个点的方案数等于左边数和上边数相加（记得初始化边界）。</p><p>那么这个东西斜起来看的话其实就是杨辉三角。</p><h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><h3 id="正常版"><a href="#正常版" class="headerlink" title="正常版"></a>正常版</h3><p>洛谷上有道<a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1434">滑雪<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，</p><p>第$i$行有$i$个数，</p><p>每次可以朝下或者朝右下走，</p><p>那么从第一行走到最后一行怎么走会使路径上的数和最大，</p><p>$f[i][j]&#x3D;max(f[i-1][j-1],f[i-1][j])$。</p><p>还是要<strong>记得初始化</strong>。</p><hr><h3 id="EX版"><a href="#EX版" class="headerlink" title="EX版"></a>EX版</h3><p>附加条件：$%100$后最大</p><p>可以加一个条件，使得每个状态都$%100$？</p><p><code>NO</code></p><p>会破坏它的<strong>最优子结构</strong></p><p>判断<strong>最优子结构</strong>就是判断 DP 正确性的关键</p><p>也就是最优解不一定是用你所谓的最优解求出的</p><p><strong>重点来了</strong>：<code>DP</code>题中题目每多一个条件，状态都可以再加一个维度</p><p>$f[i][j][k]$：走到$i$，$j$，和$%100$为$k$这件事是否可能<code>(true/false)</code></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303262052130.webp" alt="image.webp"></p><h3 id="数字三角形3"><a href="#数字三角形3" class="headerlink" title="数字三角形3"></a>数字三角形3</h3><p>必须经过 ($\dfrac{n}{2}$, $\dfrac{n}{2}$) 这个点。</p><h3 id="数字三角形4"><a href="#数字三角形4" class="headerlink" title="数字三角形4"></a>数字三角形4</h3><p>必须先走到某个点再走到最底层</p><p>个人想法：</p><p>把这看作两个过程，相当于先以这个点为终点跑一遍数字三角形，然后再以这个点为起点再跑一遍数字三角形，两段相加即可。</p><h2 id="最长上升子序列（Longest-Increasing-Subsequence）"><a href="#最长上升子序列（Longest-Increasing-Subsequence）" class="headerlink" title="最长上升子序列（Longest Increasing Subsequence）"></a>最长上升子序列（Longest Increasing Subsequence）</h2><h3 id="1-求最长长度"><a href="#1-求最长长度" class="headerlink" title="1.求最长长度"></a>1.求最长长度</h3><p>$f[i]$ 代表 $i$ 必选且 $i$ 为最后一个数得到的最长上升子序列。</p><p>$f[i]$ 至少等于 $1$，因为至少选 $i$。</p><p>那么就可以求最长：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304011904860.webp" alt="image.webp"></p><h3 id="2-求方案数"><a href="#2-求方案数" class="headerlink" title="2.求方案数"></a>2.求方案数</h3><p>再开一个 $g[i]$，</p><p>$g[i]$代表以 $i$ 结尾最长的长度的方案数，</p><p>这是通解。</p><p>如下：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304011909916.webp" alt="image.webp"></p><p>遇到求方案数的问题都可以新开一个数组来记录方案数。</p><p>假如长度变长了，那么就 $g_i&#x3D;g_j$。</p><p>改一下写法的话就是像上图所示，如果是更新那就先置为0并且令它们相同，然后顺其自然的加上，相当于赋值了，而等于的情况正好也是加上，也就是稍微合并了一下操作。</p><h3 id="3-输出一种方案数"><a href="#3-输出一种方案数" class="headerlink" title="3.输出一种方案数"></a>3.输出一种方案数</h3><ul><li>再开一个数组$pre$记录每一个状态是从哪里走过来的。</li></ul><p>$pre[i]$&#x3D;0就是前面没东西了</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> f[<span class="number">10000</span>];<span class="comment">//f[i]代表i必选且i为最后一个数得到的最长</span></span><br><span class="line"><span class="type">int</span> g[<span class="number">10000</span>];<span class="comment">//g[i]代表最长的长度的方案数</span></span><br><span class="line"><span class="type">int</span> pre[<span class="number">10000</span>];<span class="comment">//上一个状态是从哪里走过来的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;<span class="comment">//至少为1</span></span><br><span class="line">        g[i]=<span class="number">1</span>;<span class="comment">//自己是一个方案</span></span><br><span class="line">        pre[i]=<span class="number">0</span>;<span class="comment">//前面没东西</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> l=f[j]<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l&gt;f[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i]=l;<span class="comment">//更新最长长度,一定会进入下一分支</span></span><br><span class="line">                    g[i]=<span class="number">0</span>;<span class="comment">//每周j的方案后面加上一个i长度不变</span></span><br><span class="line">                    pre[i]=j;<span class="comment">//更新i这个位置的状态是从j更新的</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(l==f[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    g[i]+=g[j];<span class="comment">//新的方案数就等于原来的方案数加上新的方案数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p,cnt=<span class="number">0</span>;<span class="comment">//从p开始走</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        z[++cnt]=p;</span><br><span class="line">        p=pre[p];</span><br><span class="line">    &#125;<span class="keyword">while</span>(p!=<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(z<span class="number">+1</span>,z+cnt<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度显然是$n^2$的。</p><h3 id="4-P2501"><a href="#4-P2501" class="headerlink" title="4.P2501"></a>4.P2501</h3><p><a class="link" target="_blank" rel="noopener" href="https://white.fallingsakura.top/adfe3b0c/">题解<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="5-优化"><a href="#5-优化" class="headerlink" title="5.优化"></a>5.优化</h3><blockquote><p>要做到$nlogn$ ？</p></blockquote><h4 id="1-线段树"><a href="#1-线段树" class="headerlink" title="1.线段树"></a>1.线段树</h4><p>我们无非就是要<strong>在 $1\sim{i-1}$ 中找到一个 $j$ 使得 $a_j&lt;a_i$ 并且 $f[j]$ 最大</strong></p><p>那我们就建一颗线段树，范围 $1{\sim}m$</p><p>$m$ 是 $max({a_1}\sim{a_n})$，即所有数的最大值</p><p>假如 $a[j],f[j]$ 都知道了</p><p>进行一个单点修改</p><p>每次找到一个 $f[j]$ 就把它赋值给 $a_j$，</p><p>这样当前询问 $a_i$ 只需要询问 $1\sim a_i-1$ 区间中的最大值，</p><p>因为这样保证了之前的数都是小于 $a_i$ 的并且它们的 LIS 都已经求出。</p><p>询问的是什么？</p><p>从左向右扫的</p><p>询问的是所有小于 $a_i$ 的数</p><p>这样找到最大的 $f_j$</p><p>满足 $a_j&lt;a_j$</p><p>还取到 $a_j$ 的最大值</p><p>那么 $a[i]$ 就是 $f[j]+1$</p><h4 id="2-二分"><a href="#2-二分" class="headerlink" title="2.二分"></a>2.二分</h4><h5 id="插播一条二分"><a href="#插播一条二分" class="headerlink" title="插播一条二分"></a>插播一条二分</h5><blockquote><p><a class="link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/376467025">关于c++的lower_bound与upper_bound函数的理解 )<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p></blockquote><p>当容器中的元素按照递增的顺序存储时，lower_bound函数返回容器中第一个<strong>大于等于</strong>目标值的位置，upper_bound函数返回容器中第一个<strong>大于</strong>目标值的位置。若容器中的元素都比目标值小则返回最后一个元素的下一个位置。($\ge$)</p><p>如果容器中的元素是递减的应该怎么查找呢？这是可以借助c++内置的仿函数greater<data_type>()，相当于重新定义了比较规则。此时lower_bound_()查找的是容器中第一个<strong>小于等于</strong>目标值的元素的位置，而upper_bound()查找的是容器中第一个<strong>小于</strong>目标值的元素的位置就。如果容器中的元素都比目标值大则返回最后一个元素的下一个位置。($&gt;$)</data_type></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304020831502.webp" alt="image.webp"></p><p>详情见<a class="link" target="_blank" rel="noopener" href="https://white.fallingsakura.top/34778/#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97">优先队列<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><p>现在存在两个位置$p1$和$p2$且$p_1&lt;p_2$、$a_{p_1}$&gt;$a_{p_2}$</p><p>$f[p_1]$$\le$$f[p_2]$</p><p>这意味着什么</p><p>这个$p_1$肯定是没有用的</p><p>$p_2$一定比$p_1$更优</p><p>这样就可以把$p_1$删掉了</p><p>栗子: <code>7 2 1 5 6 4 3 8 9</code></p><p>假如</p><p>$$f[7]&#x3D;f[2]&#x3D;1$$</p><p>那么<code>7</code>就没有用了</p><p>没用的就给去了</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304012031358.webp" alt="image.webp"></p><p>在这里<code>4</code>可以把<code>5</code>给替换掉</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304012032524.webp" alt="image.webp"></p><p>在这里<code>4</code>又被替换成<code>3</code></p><p>我们发现什么问题？</p><p>这个创造出来的序列的第$i$个位置就是$f[i]$</p><p>比如$a_3$就是最长上升子序列为$3$的最小的那个（最优的）</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202306102054543.webp"></p><p><code>cnt</code>代表新建出来的序列的大小</p><p>$a$代表建出来的序列</p><p>$a[3]&#x3D;f[a[3]]&#x3D;3$</p><p>但是这样做还是$n^2$的</p><p>$z[i]$存的是$f[i]$的下标</p><p>也就是$z[f[i]]&#x3D;i$</p><p>算出了$f[i]$那肯定就把$f[i]$放在新数组的第$f[i]$个位置</p><p>比如算出了$f[8]&#x3D;4$,那么新数组的第$4$个位置就是$4$</p><p>新数组就是$z[]$，它存的不是新的序列，而是新序列中每个数对应原序列的下标</p><p>答案就是$z_{1-cnt}$</p><p>$f[z[j]]&#x3D;j$</p><p>代码：</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> z[<span class="number">233</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">233</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">233</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;<span class="comment">//f[i]中为序列下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)<span class="comment">//把循环变成二分就可以优化为 nlogn</span></span><br><span class="line">        <span class="comment">//枚举新序列中的数，更新f[i]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[z[j]]&lt;a[i])<span class="comment">//z[j]为f[]=j的数在a中的下标</span></span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],j<span class="number">+1</span>);<span class="comment">//枚举构造出的序列来更新这个f[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;cnt)<span class="comment">//新序列可以加，因为保证了构造出来的序列中第i位的f[]值为i，第cnt位置的f[]的值为cnt，那么加一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            z[cnt]=i;<span class="comment">//放入第cnt位数在a中的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;a[z[f[i]]])<span class="comment">//长度为f[i]的数在a中的下标，因为长度为f[i]和在z中下标为f[i]是等价的</span></span><br><span class="line">                z[f[i]]=i;<span class="comment">//存下标，拿比你小还比你强的来更新你</span></span><br><span class="line">            <span class="comment">//如果需要方案，就记录一下从哪转移过来的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202306102105149.webp" alt="image.png"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304020802128.webp" alt="image.webp"></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;a[z[f[i]]]) z[f[i]]=i;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202306102106250.webp" alt="image.png"></p><p>这句就是把<code>5</code>给更新成<code>4</code></p><p>注意：这个新构造的序列并不是最长上升子序列，而是用来更新f[i]的</p><p>如果要方案的话就开个数组记录一下</p><p>但是这样解的个数不是很好算</p><h5 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h5><p>可以用二分查找找出小于<code>a[i]</code>的最大的那个位置</p><p>加入一个二分替代枚举就可以达到$nlog_n$</p><p>因为新构造的序列是按照<code>f[]</code>值单调递增的</p><p>所以我们只需要每次二分查找一个小于当前<code>a[i]</code>的最大的数就可以了</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+50</span>;</span><br><span class="line"><span class="type">int</span> z[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ef</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span><span class="comment">//l,r为z下标，k为a中下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r<span class="number">+1</span>)&gt;&gt;<span class="number">1</span>;<span class="comment">//右中位数</span></span><br><span class="line">        <span class="keyword">if</span>(a[z[mid]]&lt;a[k])</span><br><span class="line">            l=mid;<span class="comment">//l=mid,保证l永远小于，满足条件</span></span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;<span class="comment">//缩小右区间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;<span class="comment">//f[i]中为序列下标</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;ef(1,cnt,i)&lt;&lt;endl;</span></span><br><span class="line">        f[i]=<span class="built_in">max</span>(f[i],<span class="built_in">ef</span>(<span class="number">0</span>,cnt,i)<span class="number">+1</span>);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for(int j=1;j&lt;=cnt;j++)//把循环变成二分就可以优化为 nlogn</span></span><br><span class="line"><span class="comment">        //枚举新序列中的数，更新f[i]</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if(a[z[j]]&lt;a[i])//z[j]为f[]=j的数在a中的下标</span></span><br><span class="line"><span class="comment">                f[i]=max(f[i],j+1);//枚举构造出的序列来更新这个f[i]</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;cnt)<span class="comment">//新序列可以加，因为保证了构造出来的序列中第i位的f[]值为i，第cnt位置的f[]的值为cnt，那么加一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            z[cnt]=i;<span class="comment">//放入第cnt位数在a中的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;a[z[f[i]]])<span class="comment">//长度为f[i]的数在a中的下标，因为长度为f[i]和在z中下标为f[i]是等价的</span></span><br><span class="line">                z[f[i]]=i;<span class="comment">//存下标，拿比你小还比你强的来更新你</span></span><br><span class="line">            <span class="comment">//如果需要方案，就记录一下从哪转移过来的,在发生转移的时候记录一下pre</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cnt即为最长上升子序列的长度</span></span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=cnt;i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d &quot;,a[z[i]]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d &quot;,a[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,n-cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><del>二分真的很难调</del></p><p>简单解释一下吧，</p><p>现在保证左端点满足条件，</p><p>不断微调右端点，</p><p>二分到最后让右端点与左端点合并，</p><p>而最后遇到相邻的情况，</p><p>mid要取右中位数（也就是如果是两个相邻的数，在取整的过程中取右端点）。</p><p><del>具体是不是这样我也说不清。</del></p><p>以上做法可以A掉<a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3902">P3902<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="滑雪："><a href="#滑雪：" class="headerlink" title="滑雪："></a>滑雪：</h3><blockquote><p>一个 $n$ 行 $m$ 列的网格图，每个格子有一个高度，只能滑向四周比自己矮的格子，任选起点，问最多能滑多远。</p></blockquote><p>从高往低滑和从低向高滑的答案是一样的。</p><p>用 $f_{i,j}$ 表示从 $i,j$ 出发的最长长度。</p><p>即 $f_{i,j}&#x3D;max(f_{x,y})+1$，其中 $x,y$ 为能滑到 $i,j$ 的格子。</p><p>就这样记忆化搜索。</p><p>可以将所有点的高度从小到大排序。</p><p>这一定是从排序后的数组的左边滑到右边。</p><p>那就可以从左向右进行 dp。</p><p>$f_i$ 代表滑到 $x_i,y_i$ 这个位置时的最长长度，然后枚举 $i$ 左边的数并且满足相邻（$|x_i-x_j|+|y_i-y_j|&#x3D;1$）的数中，$f$ 值最大的那个，把它加一就可以更新 $f_i$。</p><p>这样就可以保证转移是从左向右的，枚举 $i,j$ 就可以了。</p><p>最低点初始化为 0。</p><p>这个方法本质上就是拓扑排序+DP。</p><h3 id="乌龟棋"><a href="#乌龟棋" class="headerlink" title="乌龟棋"></a>乌龟棋</h3><p>在走的过程中，有六个变量在发生变化，其中五个可以用来表示状态，一个用来表示状态的值，即 $f_{i,a_1,a_2,a_3,a_4}$，其中第一维表示当前的位置，后面四维表示分别用了多少牌。</p><p>然后我们发现第一维其实没有必要，因为当前所在的位置可以通过后四维求解，于是就可以减少枚举，此谓之<strong>去除冗余状态</strong>。</p><p>至此的一些技巧：</p><ol><li>状态设计（每有一个变量对应一个维度）</li><li>增加维度</li><li>求方案数</li><li>改变枚举顺序</li><li>消除冗余状态</li></ol><h1 id="背包DP"><a href="#背包DP" class="headerlink" title="背包DP"></a>背包DP</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><ul><li>状态表示<ul><li>$f_{i,j}$</li><li>集合：所有只从前 $i$ 个物品中选，且总体积不超过 $j$ 的选法的集合。</li><li>属性：最大值&#x2F;最小值</li></ul></li><li>划分依据：用最后一步来划分。</li><li>状态计算：<ul><li>不选第 $i$ 个物品的所有方案</li><li>选第 $i$ 个物品的所有方案</li></ul></li></ul><p>有$n$件物品，一个背包，每个物品有重量和价值，在背包不超重的情况下，问得到价值的最大值。</p><ol><li>设计DP状态</li></ol><p>我们令$dp_{i,j}$代在前$i$个物品中进行选择，用了$j$的体积所得到的最大价值之和。</p><ol start="2"><li>转移方程</li></ol><p>第$i$个物体重量为$w_i$，价值为$v_i$。</p><p>考虑完了前$i-1$件物品后，我们开始考虑第$i$件物品，这件物品可以选也可以不选，那么就可以在这两种情况中取较大值。</p><p><code>dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])</code></p><ol start="3"><li>滚动优化</li></ol><p>我们发现更新第$i$个物品的时候只会用到第$i-1$行，之前的都相当于没有用了，所以就可以把第一维去掉，用旧状态代表$i-1$行，用新状态代表第$i$行，更新新状态的时候就是拿旧时的自己来更新现在的自己，根据转移方程，我们发现其实是拿体积较小的状态递推为体积较大的状态，所以我们更新的时候需要保留旧状态，所以从后向前遍历，这样就可以保证用来更新新状态的状态全部都是旧状态；若正向遍历，体积小的旧状态已经被更新为新状态，后面更新体积大的新状态会用被覆盖的新状态来更新，导致考虑了第$i$个物品后接着又考虑了第$i$个物品，这样就会导致每个物品会被拿多次（无穷背包）。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=w[i];j--)</span><br><span class="line">		f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure></div><p>第二层循环的终止条件为<code>j&gt;=a[i]</code>，因为之后无法转移，也就是无法装下第$i$件物品。</p><p><font color="#ec37a1"><b>习题：</b></font></p><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1060">P1060<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> x[N],f[N],v[N],p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;p[i]);</span><br><span class="line">        x[i]=v[i]*p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=v[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1048">P1048<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//背包：N个物品，背包体积为M，第i个物品价值为Wi，体积为Vi;</span></span><br><span class="line"><span class="comment">//Vi之和&lt;=M,使得价值最大，问：最大的价值之和; </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2005</span>];<span class="comment">//f[105][2005];</span></span><br><span class="line"><span class="type">int</span> w[<span class="number">100000</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">100000</span>];</span><br><span class="line"><span class="comment">//f[i][j]变化量：前i个物品已经选好了，此时用了j的体积 ，所能获得的最大价值；</span></span><br><span class="line"><span class="comment">//第i+1个物品放不放进背包？</span></span><br><span class="line"><span class="comment">//f[i][j]------&gt;f[i+1][j]</span></span><br><span class="line"><span class="comment">//转移f[i][j]-----&gt;f[i+1][j+Vi+1];+Wi+1;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n;<span class="comment">//背包大小 </span></span><br><span class="line">	cin&gt;&gt;m;<span class="comment">//药物数目 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;=m;i++)//前i个物品已经决定好放不放进背包 ///O(nm)</span></span><br><span class="line"><span class="comment">//		for(int j=0;j&lt;=n;j++)//当前用了j的体积 </span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//		//考虑i+1放不放</span></span><br><span class="line"><span class="comment">//		//Yes </span></span><br><span class="line"><span class="comment">//			f[i+1][j+v[i+1]]=max(f[i+1][j+v[i+1]],f[i][j]+w[i+1]); </span></span><br><span class="line"><span class="comment">//		//if(j&gt;=v[i])////判断数组越不越界,如果不越界，那么可以选第i个 </span></span><br><span class="line"><span class="comment">//		//	f[i][j]=max(f[i-1][j]//不选第i个,f[i-1][j-v[i]]+w[i]//选第i个);</span></span><br><span class="line"><span class="comment">//		//No</span></span><br><span class="line"><span class="comment">//			f[i+1][j]=max(f[i+1][j],f[i][j]);//待写</span></span><br><span class="line"><span class="comment">//		//else //不能选第i个 </span></span><br><span class="line"><span class="comment">//		//	f[i][j]=max(f[i][j],f[i-1][j]);////别人求自己 </span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	for(int j=1;j&lt;=n;j++)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		ans=max(f[m][j],ans);</span></span><br><span class="line"><span class="comment">////		cout&lt;&lt;f[m][j]&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//滚动数组优化，用新的覆盖旧的 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=v[i];j--)</span><br><span class="line">			f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">	cout&lt;&lt;f[n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="求方案数"><a href="#求方案数" class="headerlink" title="求方案数"></a>求方案数</h3><p>再开一个 $g_{i,j}$ 代表当前状态的方案数</p><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/11/">A11<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0xc0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 容量恰好为 i 的最大价值</span></span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 的方案数</span></span><br><span class="line">    <span class="comment">// 注意题目要求的是不超过 i 体积 因此要找一个最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> maxv = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(maxv == f[j]) cnt += g[j];</span><br><span class="line">            <span class="keyword">if</span>(maxv == f[j - v] + w) cnt += g[j - v];</span><br><span class="line">            g[j] = cnt % MOD;</span><br><span class="line">            f[j] = maxv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span>(res == f[i])</span><br><span class="line">            cnt = (cnt + g[i]) % MOD;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="求方案"><a href="#求方案" class="headerlink" title="求方案"></a>求方案</h3><p>开一个 $pre_{i,j}$ 表示 $i,j$ 这个状态是由 $i-1$ 的哪个状态转移而来就好。</p><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/12/">A12<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i + <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> j = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= v[i] &amp;&amp; f[i][j] == f[i + <span class="number">1</span>][j - v[i]] + w[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            j -= v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1015/">A1013<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">11</span>, M = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"><span class="type">int</span> w[N][M];</span><br><span class="line"><span class="type">int</span> way[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= j; k++)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k] + w[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> k = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++)</span><br><span class="line">            <span class="keyword">if</span>(f[i][k] == f[i - <span class="number">1</span>][k - j] + w[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                way[i] = j;</span><br><span class="line">                k -= j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; way[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h2><ul><li>状态表示<ul><li>$f_{i,j,k}$</li><li>集合：所有只从前 $i$ 个物品中选，并且总体积不超过 $j$ ，总重量不超过 $k$ 的所有选法。</li><li>属性：最大值</li></ul></li><li>状态计算<ul><li>最后一步：最后一个物品，要么包含要么不包含。</li><li>不包含：$f_{i-1,j,k}$</li><li>包含：$f_{i-1,j-v_i,k-m_i}+w_i$</li></ul></li></ul><h2 id="初始化分类"><a href="#初始化分类" class="headerlink" title="初始化分类"></a>初始化分类</h2><ul><li>初始化分类<ul><li>体积最多是 $j$<ul><li>方案数：$f_{0,i}&#x3D;1,i\in{[0,m]}\quad|\quad f_{1}&#x3D;1$</li><li>最大价值：$f_{i,k}&#x3D;0,i\in[0,n],k\in[0,m]\quad|\quad f_i&#x3D;0,i\in[0,m]$</li></ul></li><li>体积恰好是 $j$<ul><li>方案数：$f_{0,0}&#x3D;1\quad|\quad f_0&#x3D;1$</li><li>最大价值：$f_{0,0}&#x3D;0,f_{0,i}&#x3D;-\infty,i\in[1,\infty]\quad|\quad f_0&#x3D;0,f_i&#x3D;-\infty$</li><li>最小价值：$f_{0,0}&#x3D;0,f_{0,i}&#x3D;\infty,i\in[1,\infty]\quad|\quad f_0&#x3D;0,f_i&#x3D;\infty$</li></ul></li><li>体积至少是 $j$<ul><li>方案数：$f_{0,0}&#x3D;1\quad|\quad f_0&#x3D;1$</li><li>最小价值：$f_{0,0}&#x3D;0,f_{0,i}&#x3D;\infty,i\in[1,\infty]\quad|\quad f_0&#x3D;0,f_i&#x3D;\infty$</li></ul></li></ul></li></ul><p>从集合的角度考虑，考虑前 0 个物品且花费体积为 0 这一个元素，或者说是状态，在不同集合的定义中可以被划分到哪个集合，剩下的集合的状态是如何。</p><hr><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1022/">AcWing1020 潜水员<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><ul><li>状态表示<ul><li>集合：所有从前 $i$ 个物品中选，且氧气至少是 $j$，但其至少是 $k$ 的所有选法。</li><li>属性：最小值</li></ul></li><li>状态计算<ul><li>划分依据：最后一个物品的选择情况。</li><li>所有不含第 $i$ 个物品的所有选法：$f_{i-1,j,k}$</li><li>所有包含第 $i$ 个物品的所有选法：$f_{i-1,j-v_1,k-v_2}+w+i$</li></ul></li></ul><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">22</span>, M = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v1, v2, w;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = m; k &gt;= <span class="number">0</span>; k--) <span class="comment">// 至少是 j / k</span></span><br><span class="line">                f[j][k] = <span class="built_in">min</span>(f[j][k], f[<span class="built_in">max</span>(<span class="number">0</span>, j - v1)][<span class="built_in">max</span>(<span class="number">0</span>, k - v2)] + w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="无穷背包"><a href="#无穷背包" class="headerlink" title="无穷背包"></a>无穷背包</h2><p>按照直观的想法，那就再枚举一个 $k$ 表示这个物品选多少个。</p><p>但这样复杂度是 $O(n^3)$ 的，所以考虑优化。</p><p>对比01背包，最大的不同就是它可以通过自己来更新自己，所以我们只需要在原来的基础上加上这样一句话：</p><p>它可以自己更新自己。</p><p>自己最初没选第 $i$ 个，然后可以选一个、两个、三个、四个……</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">-		<span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">+		<span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i][j-w[i]]+v[i]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div><p>很简单，将滚动优化的第二维改为正向枚举即可，解释见上；</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=a[i];j&lt;=m;j++)</span><br><span class="line">		f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure></div><p>等效替换：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310270855546.webp" alt="image.png"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310270855575.webp" alt="image.png"></p><h3 id="求方案数-1"><a href="#求方案数-1" class="headerlink" title="求方案数"></a>求方案数</h3><ul><li>状态表示<ul><li>集合：所有只从前 $i$ 个物品中选，且总体积恰好是 $j$ 的方案的集合。</li><li>属性：数量</li></ul></li><li>状态计算<ul><li>根据第 $i$ 个物品选几个来划分集合。</li><li>0 个：$f_{i-1,j}$</li><li>k 个：$f_{i-1,j-k\times v_i}$</li></ul></li></ul><p>$$<br>f_{i,j}&#x3D;f_{i-1,j}+f_{i-1,j-v_i\times{k}}<br>$$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310291102771.webp" alt="image.png"></p><p>这里可以直接替换。</p><p>$$<br>f_{i,j} &#x3D; f_{i-1,j}+f_{i,j-v}<br>$$</p><p>这是通过它们的层层递推关系得出的。</p><p><font color="#ec37a1"><b>习题：</b></font></p><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1616">P1616<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//w[i]价值</span></span><br><span class="line"><span class="comment">//v[i]花费</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000</span><span class="number">+5</span>,M=<span class="number">100000</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,m,w[N],v[N],f[N][M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;w[i],&amp;v[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=v[i])</span><br><span class="line">				f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i][j-v[i]]+w[i]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">		&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="有限背包"><a href="#有限背包" class="headerlink" title="有限背包"></a>有限背包</h2><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1776">P1776 宝物筛选<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310270931176.webp" alt="image.png"></p><p>每次相当于求一个长度为 $s$ 的窗口的最大值，并且有 $w$ 的偏移量，这个可以通过一个单调队列来维护。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N], g[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        cin &gt;&gt; w &gt;&gt; v &gt;&gt; s;</span><br><span class="line">        <span class="built_in">memcpy</span>(g, f, <span class="built_in">sizeof</span>(f)); <span class="comment">// i - 1 的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; v; j++) <span class="comment">// 余数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>; <span class="comment">// 单调递减的单调队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j; k &lt;= m; k += v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh++; <span class="comment">// 队头超出了范围 出队</span></span><br><span class="line">                <span class="keyword">if</span>(hh &lt;= tt) f[k] = <span class="built_in">max</span>(f[k], g[q[hh]] + (k - q[hh]) / v * w); <span class="comment">// 滑动窗口每移动一点就有 w 的偏移量</span></span><br><span class="line">                <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt--; <span class="comment">// 弹出比它小的队尾</span></span><br><span class="line">                q[++tt] = k; <span class="comment">// 下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><p>与无穷背包相比，每个物品选取次数有一个上限。</p><p>老样子我们可以通过枚举第三维来解决，或者加维来做无穷背包怎么优化呢？</p><p>那就可以把这些不同种物品全部摊开，变成一个一个的物品，这样就变成01背包了。</p><p>但这样还是 $O(n^3)$ 的，我希望物品总数变少，可以把物品少拆一点，使得这个拆分满足选取若干数加起来可以等于 $0\sim{k}$ 中的任何一个数。</p><p>这样不管选多少个物品都可以通过拆分的这些数组合得到。</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202308171640408.webp" alt="image.png"></p><p>比如这样，这样就可以把任何一个数拆分成 $logn$ 个数，这样就把复杂度优化为 $O(n^2logn)$。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, c;</span><br><span class="line"><span class="type">int</span> w[N], v[N], m[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> nw[N], nv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v[i], &amp;w[i], &amp;m[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m[i]; j &lt;&lt;= <span class="number">1</span>) <span class="comment">// 二进制拆分 将物品数降为 log 级别 即可自由组合出全部放方案</span></span><br><span class="line">        &#123;</span><br><span class="line">            m[i] -= j;</span><br><span class="line">            nw[++cnt] = w[i] * j;</span><br><span class="line">            nv[cnt] = v[i] * j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m[i])</span><br><span class="line">        &#123;</span><br><span class="line">            nw[++cnt] = w[i] * m[i];</span><br><span class="line">            nv[cnt] = v[i] * m[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = c; j &gt;= nw[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - nw[i]] + nv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[c] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="限制背包"><a href="#限制背包" class="headerlink" title="限制背包"></a>限制背包</h2><blockquote><p>$n$ 个物品，$m$ 体积的背包， $k$ 次询问，每次强制有一个物品不能选，问最大价值。<br>$n\le{10^5},m\le{100},k\le{1000}$</p></blockquote><p>我们注意 $m$ 很小，这是一个切入点。</p><p>先正常 DP 一遍，$f_{i,j}$ 表示前 $i$ 个物品用了 $j$ 的体积的最大价值。</p><p>再进行一次 DP，$g_{i,j}$ 代表 $i\sim{n}$ 已经考虑完了用了 $j$ 的体积的最大价值。</p><p>所以查询 $p_1$ 时，枚举体积 $a,b$ ，答案就是 $f_{p_1-1,a}+g_{p_1+1,b}$。</p><p>当前也可以分别维护一个前缀最大值，这查询的时候只需要枚举一个变量即可，如 $a,m-a$。</p><p>背包 DP 的本质是不断往里加物品，在加物品的 DP 里考虑删物品很不好做，那不如分为<strong>两段累加</strong>。</p><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><p>分组背包，通俗的讲就是，给你$N$组物品，然后每一组你至多选择一个物品(<strong>也可以不选</strong>),每个物品都有自己的体积和价值，现在给你一个容里为M的背包，让你用这个背包装物品，使得物品价值总和最大。</p><p>那么就可以给它们编号了，然后定义一个数组来存储第$i$组第$j$个的编号，然后正常存储价值、重量等。</p><p>枚举时，第一维是组数，第二维是背包容量（从大到小），第三维是第$i$组的物品数，然后判断下是否能转移。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[j]=<span class="built_in">max</span>(f[j],f[j-w[p[i][k]]]+v[p[i][k]]);</span><br></pre></td></tr></table></figure></div><p><font color="#ec37a1"><b>习题：</b></font></p><p><a class="link" target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1712">HDU1712<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">13505</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1007</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> x,w[N],v[N],f[N],p[M][M],c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;       <span class="comment">/*编号做法仿照P1757*/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    while(cin&gt;&gt;n&gt;&gt;m)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(!n&amp;&amp;!m) break;</span></span><br><span class="line"><span class="comment">        int cnt=0;</span></span><br><span class="line"><span class="comment">        memset(w,0,sizeof(w));</span></span><br><span class="line"><span class="comment">        memset(v,0,sizeof(v));</span></span><br><span class="line"><span class="comment">        memset(f,0,sizeof(f));</span></span><br><span class="line"><span class="comment">        memset(c,0,sizeof(c));</span></span><br><span class="line"><span class="comment">        memset(p,0,sizeof(p));</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)//背包种数</span></span><br><span class="line"><span class="comment">            for(int j=1;j&lt;=m;j++)//物品编号</span></span><br><span class="line"><span class="comment">                scanf(&quot;%d&quot;,&amp;v[++cnt]),w[cnt]=j,p[i][++c[i]]=cnt;//记录第几组第几个的编号为i</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">            for(int j=m;j&gt;=0;j--)</span></span><br><span class="line"><span class="comment">                for(int k=1;k&lt;=c[i];k++)</span></span><br><span class="line"><span class="comment">                    if(j&gt;=w[p[i][k]])</span></span><br><span class="line"><span class="comment">                        f[j]=max(f[j],f[j-w[p[i][k]]]+v[p[i][k]]);</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;f[m]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//可以改成while(cin&gt;&gt;n&gt;&gt;m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">if</span>(!n&amp;&amp;!m) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i][j]);<span class="comment">//这里的p代表在i课程花j天学习所获得的价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举组数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)<span class="comment">//枚举背包体积</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)<span class="comment">//枚举每组的物体</span></span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=k)<span class="comment">//第k号物体的体积为k</span></span><br><span class="line">                        f[j]=<span class="built_in">max</span>(f[j],f[j-k]+p[i][k]);</span><br><span class="line">        cout&lt;&lt;f[m]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/7/">A7<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="number">0</span>) <span class="comment">// 完全</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = v; j &lt;= m; j++)</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s == <span class="number">-1</span>) s = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s; k &lt;&lt;= <span class="number">1</span>) <span class="comment">// 二进制优化</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= k * v; j--)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - k * v] + k * w);</span><br><span class="line">                s -= k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s) <span class="comment">// 剩余</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= s * v; j--)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - s * v] + s * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="依赖背包"><a href="#依赖背包" class="headerlink" title="依赖背包"></a>依赖背包</h2><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/10/">A10<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt, to;</span><br><span class="line">&#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].nxt = fir[u];</span><br><span class="line">    fir[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = fir[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> vv = e[i].to;</span><br><span class="line">        <span class="built_in">dfs</span>(vv);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m - v[u]; j &gt;= <span class="number">0</span>; j--) <span class="comment">// 根节点必选</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= j; k++)</span><br><span class="line">                f[u][j] = <span class="built_in">max</span>(f[u][j], f[u][j - k] + f[vv][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= v[u]; i--) f[u][i] = f[u][i - v[u]] + w[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v[u]; i++) f[u][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; p;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">-1</span>) root = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(p, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    cout &lt;&lt; f[root][m] &lt;&lt; endl; <span class="comment">// 跟节点的子树体积不超过 m 的最大价值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="能量石问题"><a href="#能量石问题" class="headerlink" title="能量石问题"></a>能量石问题</h2><p>分析方法类似国王游戏。</p><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/736/">A734<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p>吃第 $i$ 块花费的时间是 $s_i$ 秒，当时它的价值是 $E’_i$，每秒它将失去 $L_i$ 的价值。</p><p>那么我们在吃 $i$ 和 $i+1$ 的时候，考虑顺序。</p><p>假如先吃 $i$，那么得到的价值就是 $E’<em>i+E’</em>{i+1}-s_i\times{L_{i+1}}$</p><p>假如先吃 $i + 1$，那么得到的价值就是 $E’<em>i+E’</em>{i+1}-s_{i+1}\times{L_i}$</p><p>我们发现只有最后一项不同。</p><p>假如先吃 $i$ 更优，那么就说明 $s_i\times{L_{i+1}}&lt;s_{i+1}\times{L_i}$</p><p>所以我们可以按照 $\frac{s_i}{L_i}$ 从小到大排序，依次选即可。</p><ul><li>状态表示<ul><li>$f_{i,j}$</li><li>集合：所有只从前 $i$ 块能量石中选，且总体积（花费的时间）恰好是 $j$ 的方案</li><li>属性：最大值</li></ul></li><li>状态计算<ul><li>$f_{i,j}&#x3D;max(f_{i-1,j},f_{i-1,j-s_i}+E_i-(j-s_i)\times{L_i})$</li></ul></li></ul><p>注意这里由于要通过当前时间来计算能量石损耗了多少能量，所以我们的 $j$ 记录的是恰好为当前时间的状态。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s, e, l;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Stone &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> s * t.l &lt; t.s * l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;stone[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> C = <span class="number">1</span>; C &lt;= t; C++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s, e, l;</span><br><span class="line">            cin &gt;&gt; s &gt;&gt; e &gt;&gt; l;</span><br><span class="line">            m += s;</span><br><span class="line">            stone[i] = &#123;s, e, l&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(stone, stone + n);</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0xc0</span>, <span class="built_in">sizeof</span>(f)); <span class="comment">// 负无穷</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = stone[i].s, e = stone[i].e, l = stone[i].l;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= s; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - s] + e - (j - s) * l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, C, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="状态机模型"><a href="#状态机模型" class="headerlink" title="状态机模型"></a>状态机模型</h1><p>描述的是一个过程而非结果。</p><p>把点扩展成了一个过程。</p><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1051/">A1049<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p>$f_i$ 表示抢劫前 $i$ 家店铺的最大收益。</p><p>正常转移：$f_i&#x3D;\max(f_{i-1},f_{i-2}+w_i)$</p><p>状态机分析：</p><p>先拆解状态为：$f_{i,0},f_{i,1}$ 表示未选最后一个店铺和选择最后一个店铺。</p><p>那么这个状态机最后的转移状态如图：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310301553352.webp" alt="image.png|300"></p><p>每一步对应一个状态，会清晰很多。</p><p>状态机还对应着一个入口的概念，也就是初始化。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">8</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N], f[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, f[<span class="number">0</span>][<span class="number">1</span>] = -INF; <span class="comment">// 入口 不可能选第 0 家店铺 所以设为不合法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">max</span>(f[n][<span class="number">0</span>], f[n][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1059/">A1057<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p>对于股票对应两个过程：手中有货，手中无货。</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310301611731.webp" alt="image.png|300"></p><ul><li>状态表示：<ul><li>$f_{i, j, 0}, f_{i, j, 1}$</li><li>集合：过完了前 $i$ 天，进行了 $j$ 次交易，并且手中没有&#x2F;有股票的状态。</li><li>假如手中有股票，那么就是处于第 $j$ 次交易。</li></ul></li><li>状态计算：<ul><li>$f_{i,j,0}&#x3D;\max(f_{i-1,j,0},f_{i-1,j,1}+w_i)$</li><li>$f_{i,j,1}&#x3D;\max(f_{i-1,j,1},f_{i-1,j-1,0}-w_i)$</li></ul></li></ul><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> f[N][M][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0xc0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j][<span class="number">1</span>] + w[i]);</span><br><span class="line">            f[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j][<span class="number">1</span>], f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[n][i][<span class="number">0</span>]); <span class="comment">// 完整的交易结束 此时手里无货</span></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1060/">A1058<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><ul><li>状态表示<ul><li>手中有货&#x2F;手中无货的第一天&#x2F;手中无货的非第一天。</li><li><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310301935361.webp" alt="image.png|500"></li><li>入口：手中无货的非第一天。</li><li>出口：手中无货即可，那么算一个即可，但假如股票价格是单调下降的，那么最优解就是一次也不买，出口就是入口。</li><li>注意本题无交易次数。</li></ul></li><li>状态计算：<ul><li>$f_{i,0&#x2F;1&#x2F;2}$</li><li>$f_{i,0}&#x3D;\max(f_{i-1,0},f_{i-1,2}-w_i)$</li><li>$f_{i,1}&#x3D;f_{i-1,0}+w_i$</li><li>$f_{i,2}&#x3D;\max(f_{i-1,2},f_{i-1,1})$</li></ul></li><li>初始化：$f_{0,2}&#x3D;0,f_{0,1}&#x3D;f_{0,0}&#x3D;-\infty$<ul><li>负无穷代表不合法。</li></ul></li></ul><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">-0x3f3f3f3f</span>; <span class="comment">// 手中有货和 无货的第一天</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// 手中无货非第一天</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>] - w[i]);</span><br><span class="line">        f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + w[i];</span><br><span class="line">        f[i][<span class="number">2</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[n][<span class="number">1</span>], f[n][<span class="number">2</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1054/">A1052<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p>KMP 的过程中不能让它跳到最后一个状态。</p><p>每个位置有 26 条边，$m + 1$ 个状态。</p><ul><li>1:40:00 没听懂，复习 KMP 去了，等回来补听。</li></ul><h1 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h1><blockquote><p>在背包问题里，考虑的顺序是对答案没有影响的。<br>但是会存在某些题，物品的选择顺序对答案产生影响。<br>比如这次获得的实际价值是这次选择的物品价值与上一个物品价值异或和，那么<strong>选择顺序就会导致答案变化</strong>，就需要一种新的DP方式——状压DP。</p></blockquote><blockquote><p>状压DP的暴力做法一般是 $n!$ 复杂度的，比如枚举选择顺序的全排列。</p></blockquote><p>设 $f_{i,j}$ 代表上一个选的物品是 $j$，第一维用一个 $n$ 位的二进制数（$0\sim{n-1}$），这个二进制数第 $x$ 位代表第 $x$ 个物品选没选。</p><p>转移的时候看一下第 $i-1$ 位有没有选，没选我才能选上。</p><p>用二进制数代表物品选没选过，这个技巧叫做状态压缩。</p><p>还要考虑体积：当前用了 $k$ 的体积。</p><p>$f_{i,j,k}$ 代表选了哪些，上一个选的是 $j$，当前用了 $k$ 的体积所得到的最大价值，转移时考虑下一个选什么，编号 $0\le{r}\le{n}$。</p><p>选这个物品的条件是$((i&gt;&gt;r)&amp;1)&#x3D;0$</p><p>$f_{i|(1&lt;&lt;r),r,k+v_r}&#x3D;f_{i,j,k}+w_j\oplus{w_r}$</p><p>$i|(1&lt;&lt;r)$ 相当于把 $i$ 的第 $r$ 位赋为 1。</p><p>复杂度：</p><p>$O(2^n\times{n^2}\times{m})$</p><p>这个范围一般是 $n\in{18\sim{22}}$</p><h2 id="棋盘式（基于连通性）"><a href="#棋盘式（基于连通性）" class="headerlink" title="棋盘式（基于连通性）"></a>棋盘式（基于连通性）</h2><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1066/">A1064<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><ul><li>状态表示<ul><li>$f_{i,j,s}$</li><li>集合：所有只摆在前 $i$ 行，已经摆了 $j$ 个国王，且第 $i$ 行摆放的状态是 $s$ 的集合。</li><li>属性：方案数。</li></ul></li><li>状态计算<ul><li>已经摆完前 $i$ 排，且第 $i$ 排的状态是 $a$，第 $i - 1$ 排的状态是 $b$，已经摆了 $j$ 个国王的所有方案。</li></ul></li></ul><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">10</span>, K = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state;</span><br><span class="line"><span class="type">int</span> id[M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; head[M];</span><br><span class="line"><span class="type">int</span> cnt[M];</span><br><span class="line">LL f[N][K][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (((state &gt;&gt; i) &amp; <span class="number">1</span>) &amp;&amp; (state &gt;&gt; (i + <span class="number">1</span>)) &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += (state &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            state.<span class="built_in">push_back</span>(i);</span><br><span class="line">            id[i] = state.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// cnt[i] = count(i);</span></span><br><span class="line">            cnt[i] = __builtin_popcount(i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; state.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = state[i], b = state[j];</span><br><span class="line">            <span class="keyword">if</span>((a &amp; b) == <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(a | b))</span><br><span class="line">                head[i].<span class="built_in">push_back</span>(j); <span class="comment">// 可以转移的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; state.<span class="built_in">size</span>(); a++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> b : head[a])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> c = cnt[state[a]];</span><br><span class="line">                    <span class="keyword">if</span>(j &gt;= c)</span><br><span class="line">                    &#123;</span><br><span class="line">                        f[i][j][a] += f[i - <span class="number">1</span>][j - c][b];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    cout &lt;&lt; f[n + <span class="number">1</span>][m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/329/">A327<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> can[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">15</span>][<span class="number">1</span> &lt;&lt; <span class="number">12</span>];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &amp; (s &lt;&lt; <span class="number">1</span>) || s &amp; (s &gt;&gt; <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span> (((s &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>) &amp;&amp; can[x][i] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; can[i][j];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; m); j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(i - <span class="number">1</span>, j))</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; m); k++)</span><br><span class="line">                    <span class="keyword">if</span> ((j &amp; k) == <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(i, k))</span><br><span class="line">                        f[i][k] = (f[i][k] + f[i - <span class="number">1</span>][j]) % MOD;</span><br><span class="line">    cout &lt;&lt; f[n + <span class="number">1</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"><span class="comment">// const int MOD = 1e8;</span></span><br><span class="line"><span class="comment">// const int N = 14, M = 1 &lt;&lt; 12;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int n, m;</span></span><br><span class="line"><span class="comment">// int g[N];</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; state;</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; head[M];</span></span><br><span class="line"><span class="comment">// int f[N][M];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bool check(int state)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     if(state &amp; (state &lt;&lt; 1) || state &amp; (state &gt;&gt; 1)) return false;</span></span><br><span class="line"><span class="comment">//     return true;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int main()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line"><span class="comment">//     for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">//         for (int j = 0; j &lt; m; j++)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             int t;</span></span><br><span class="line"><span class="comment">//             cin &gt;&gt; t;</span></span><br><span class="line"><span class="comment">//             g[i] += !t &lt;&lt; j;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     for (int i = 0; i &lt; (1 &lt;&lt; m); i++)</span></span><br><span class="line"><span class="comment">//         if(check(i))</span></span><br><span class="line"><span class="comment">//             state.push_back(i);</span></span><br><span class="line"><span class="comment">//     for (int i = 0; i &lt; state.size(); i++)</span></span><br><span class="line"><span class="comment">//         for (int j = 0; j &lt; state.size(); j++)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             int a = state[i], b = state[j];</span></span><br><span class="line"><span class="comment">//             if ((a &amp; b) == 0)</span></span><br><span class="line"><span class="comment">//             &#123;</span></span><br><span class="line"><span class="comment">//                 head[i].push_back(j);</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     f[0][0] = 1;</span></span><br><span class="line"><span class="comment">//     for (int i = 1; i &lt;= n + 1; i++)</span></span><br><span class="line"><span class="comment">//         for (int a = 0; a &lt; state.size(); a++)</span></span><br><span class="line"><span class="comment">//             for (int b : head[a])</span></span><br><span class="line"><span class="comment">//             &#123;</span></span><br><span class="line"><span class="comment">//                 if (g[i] &amp; state[a]) continue;</span></span><br><span class="line"><span class="comment">//                 f[i][a] = (f[i][a] + f[i - 1][b]) % MOD;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//     cout &lt;&lt; f[n + 1][0] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></div><h2 id="旅行商问题（TSP）"><a href="#旅行商问题（TSP）" class="headerlink" title="旅行商问题（TSP）"></a>旅行商问题（TSP）</h2><blockquote><p>平面内有 $n$ 个点，问从 $1$ 号点出发把所有点都走一遍回到自己的最短路径。</p></blockquote><p>除了一号点，其它的点没有必要走两次。</p><p>设 $f_{i,j}$ 代表哪些点走过了，最后停留在 $j$ 号点的最短路径。</p><p>初始化为 $f_{1,0}&#x3D;0$，把编号改为 $0\sim{n-1}$。</p><p>然后枚举一个 $k$，表示最后停在 $j$，这一步是从 $j$ 走到 $k$。</p><p>所以 $f_{i|(1&lt;&lt;k),k}&#x3D;\min(f_{i,j}+dis_{j,k})$</p><h2 id="愤怒的小鸟（基于集合）"><a href="#愤怒的小鸟（基于集合）" class="headerlink" title="愤怒的小鸟（基于集合）"></a><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2831">愤怒的小鸟<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>（基于集合）</h2><p>一共有 $n$ 个点，预处理出 $n^2$ 条抛物线和它们覆盖的点。</p><p>问题就转化为了给定若干条抛物线，用最少的抛物线覆盖所有的点。</p><p>这是一个<strong>重复覆盖问题</strong>，与之相对的还有<strong>精确覆盖问题</strong>，最优解法是 Dancing Links。</p><p>所以这题用状压实现一下。</p><p>用集合类型的状压 DP 优化爆搜。</p><p>爆搜：</p><ul><li>如果包含了所有列，更新全局最优解。</li><li>$state$ 存储哪一列已经被覆盖</li><li>任选没有被覆盖的一列 $x$</li><li>枚举所有能覆盖 $x$ 的抛物线。</li><li>更新 $state$</li></ul><h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>它是由小区间递推得到大区间的一种 DP 方式，可以先枚举长度，再枚举左端点得到右端点，也可以直接枚举左右端点。</p><p>但之间枚举左右端点要注意顺序问题，即大的左端点要先被枚举到：</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j++)</span><br></pre></td></tr></table></figure></div><p>这样可以保证枚举到的区间的子区间之前一定更新过。</p><p>不过个人还是比较习惯：</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div><h2 id="合并石子"><a href="#合并石子" class="headerlink" title="合并石子"></a>合并石子</h2><blockquote><p>有 $n$ 堆石子，每次选择相邻两堆合并，合并代价为两堆石子之和，要合并为一堆，求最小代价。</p></blockquote><p>它始终是连续的一段进行合并，不能进行跳跃。</p><p>所以可以设计 $f_{l,r}$ 代表把 $[l,r]$ 的石子合并为一堆的最小代价，答案就是 $f_{1,n}$。</p><p>初始化为 $f_{i,i}&#x3D;0$ ，那么怎么进行转移？</p><p>最后一次合并一定是把两堆石子合并为一堆石子，所以两堆石子之间一定有一个分界点，所以就枚举一个分界点 $k$ ，$f_{l,r}&#x3D;\min_{l\le{k}\le{r}}(f_{l,k}+f{k+1,r})+sum_{l,r}$。</p><p>区间DP的共性之一：状态有 $l$ 和 $r$。</p><p>大区间一定是由小区间转移而来的，所以我们要先求长度较小的区间，因此不能直接枚举 $l,r$ ，要<strong>枚举区间长度</strong>。</p><p>先枚举区间长度，再枚举 $l,r$，再枚举断点。</p><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1775">石子合并（弱化版）<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+a[i];<span class="comment">//前缀和</span></span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f3f3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		f[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)<span class="comment">//当前处理长度为len的区间 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=n;r++,l++)<span class="comment">//长度为r-l+1 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">				f[l][r]=<span class="built_in">min</span>(sum[r]-sum[l<span class="number">-1</span>]+f[l][k]+f[k<span class="number">+1</span>][r],f[l][r]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><p>那么石子是环呢？</p><p>我们合并为一堆时，总会有一个地方是分界点，可以断环为链，枚举每一个分界点的答案即可。</p><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1880">石子合并<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">+1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">		a[i]=a[i-n]; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">		f[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++) </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=<span class="number">2</span>*n;r++,l++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">				f[l][r]=<span class="built_in">min</span>(sum[r]-sum[l<span class="number">-1</span>]+f[l][k]+f[k<span class="number">+1</span>][r],f[l][r]);</span><br><span class="line">	<span class="type">int</span> ans=f[<span class="number">1</span>][n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=n;r&lt;=<span class="number">2</span>*n;l++,r++)</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,f[l][r]);</span><br><span class="line">	<span class="type">int</span> maxn,minn;</span><br><span class="line">	minn=ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=<span class="number">2</span>*n;r++,l++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">				f[l][r]=<span class="built_in">max</span>(sum[r]-sum[l<span class="number">-1</span>]+f[l][k]+f[k<span class="number">+1</span>][r],f[l][r]);</span><br><span class="line">	ans=f[<span class="number">1</span>][n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=n;r&lt;=<span class="number">2</span>*n;l++,r++)</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,f[l][r]);</span><br><span class="line">	maxn=ans;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>,minn,maxn);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><blockquote><p>分别有一堆矩阵 $M_1&#x3D;{a_1}\times{a_2},M_2&#x3D;{a_2}\times{a_3},M_3&#x3D;{a_3}\times{a_4},\cdots,M_n&#x3D;{a_n}\times{a_{n+1}}$。现在要把它们乘起来，两个矩阵相乘的代价，例如$M_1\cdot{M_2}&#x3D;a_1\times{a_2}\times{a_3}$，根据矩阵的结合律，求最小代价。</p></blockquote><p>类似于<a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1063">能量项链<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">220</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">+1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">        a[i]=a[i-n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n*<span class="number">2</span>;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=n*<span class="number">2</span>;l++,r++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                f[l][r]=<span class="built_in">max</span>(f[l][r],f[l][k]+f[k<span class="number">+1</span>][r]+a[l]*a[k<span class="number">+1</span>]*a[r<span class="number">+1</span>]);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="POJ2955-最长括号匹配"><a href="#POJ2955-最长括号匹配" class="headerlink" title="POJ2955 最长括号匹配"></a>POJ2955 最长括号匹配</h2><blockquote><p>从一个括号串中选出一个最长的子序列，使其满足括号匹配。</p></blockquote><p>$f_{l,r}$ 代表 $[l,r]$ 中最多能选出多少括号满足匹配。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">        s=a;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;end&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=len<span class="number">-1</span>;r&lt;n;l++,r++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                    f[l][r]=<span class="built_in">max</span>(f[l][r],f[l][k]+f[k<span class="number">+1</span>][r]);</span><br><span class="line">                <span class="keyword">if</span>(s[l]==<span class="string">&#x27;(&#x27;</span>&amp;&amp;s[r]==<span class="string">&#x27;)&#x27;</span>) f[l][r]=<span class="built_in">max</span>(f[l][r],f[l<span class="number">+1</span>][r<span class="number">-1</span>]<span class="number">+2</span>);</span><br><span class="line">                <span class="keyword">if</span>(s[l]==<span class="string">&#x27;[&#x27;</span>&amp;&amp;s[r]==<span class="string">&#x27;]&#x27;</span>) f[l][r]=<span class="built_in">max</span>(f[l][r],f[l<span class="number">+1</span>][r<span class="number">-1</span>]<span class="number">+2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[<span class="number">0</span>][n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="POJ1651-删数"><a href="#POJ1651-删数" class="headerlink" title="POJ1651 删数"></a>POJ1651 删数</h2><blockquote><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202308171108862.webp" alt="image.png"></p></blockquote><p>还是用 $f_{l,r}$ 表示删除区间 $[l,r]$ （<strong>除左右端点</strong>）的总代价，答案就是 $f_{1,n}$。</p><p>转移呢？</p><p>删除最后一个数 $k$ ，拿肯定是先把 $l\sim{k}$ 和 $k\sim{r}$ 之间的点都删光，</p><p>枚举一个中间点，$f_{l,r}&#x3D;\min_{l&lt;k&lt;r}(f_{l,k}+f_{k,r}+a_l\times{a_k}\times{a_r})$</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> a[N],f[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        f[i][i<span class="number">+1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">3</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=n;l++,r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l<span class="number">+1</span>;k&lt;r;k++)</span><br><span class="line">                f[l][r]=<span class="built_in">min</span>(f[l][r],f[l][k]+f[k][r]+a[l]*a[k]*a[r]);</span><br><span class="line">            <span class="comment">// printf(&quot;f[%d][%d]=%d\n&quot;,l,r,f[l][r]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="HDU4632-回文子序列"><a href="#HDU4632-回文子序列" class="headerlink" title="HDU4632 回文子序列"></a>HDU4632 回文子序列</h2><blockquote><p>给定一个字符串，求回文子序列的数量。</p></blockquote><p>对于一个区间 $[l,r]$ ，我在处理它的时候一定要保证它的子区间已经处理完了。</p><p>转移：$f_{l,r}&#x3D;f_{l+1,r}+f_{l,r-1}-f_{l+1,r-1}$</p><p>这就完了嘛？如果 $s_l&#x3D;s_r$，那么就是在原来 $[l,r]$ 的基础上又加了这么多，所以要再加上 $f_{l+1,r-1}$，而且两端点也形成了一个回文子序列，所以再加一。</p><p>于是总转移方程为：$f_{l,r}&#x3D;f_{l,r-1}+f_{l+1,r}-[s_l\not&#x3D;s_r]\times{f_{l+1,r-1}}$</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">10007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> t,n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=t;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s<span class="number">+1</span>);</span><br><span class="line">        n=<span class="built_in">strlen</span>(s<span class="number">+1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            f[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=n;l++,r++)</span><br><span class="line">                f[l][r]=(f[l][r<span class="number">-1</span>]+f[l<span class="number">+1</span>][r]-((<span class="type">int</span>)(s[l]!=s[r])*(f[l<span class="number">+1</span>][r<span class="number">-1</span>]))+(<span class="type">int</span>)(s[l]==s[r])+mod)%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>,k,f[<span class="number">1</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="凸多边形"><a href="#凸多边形" class="headerlink" title="凸多边形"></a>凸多边形</h2><blockquote><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202308171157448.webp" alt="image.png"></p><p>一个 $n$ 边形是可以切成 $n-2$ 个三角形，每个三角形的权值是它的三个顶点的点权之积，求最小权值和。</p></blockquote><p>三角形是通过切割得来的。</p><p>断环为链，拷贝几份，假如一个凸八边形，那么$f_{1,9}&#x3D;f_{1,5}+f_{5,9}$，其中 $a_1&#x3D;a_9$。</p><p>$f_{i,j}&#x3D;f_{i,k}+f_{k,j}$</p><p>当这个区间被划分到三个点的时候单独算一下就好了。</p><h1 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h1><p>始终从叶子向根节点做 DP。</p><p>在每个节点时聚合所有儿子的信息，可能需要多遍 dfs&#x2F;bfs 。</p><h2 id="点数"><a href="#点数" class="headerlink" title="点数"></a>点数</h2><blockquote><p>一个 $n$ 个点的树，问这个树有多少个点？</p></blockquote><p><del>很显然是n。</del></p><p>考虑用树形 DP 来解决这个问题。</p><p>树形DP的**第一个维度一般是 $f_i$**，代表以 $i$ 为根的子树。</p><p>在这里表示以 $i$ 为根的子树有多少个点。</p><p>所以我们要求的就是 $f_1$。</p><p>初始化？我们需要把所有叶子节点的子树大小初始化为 $1$。</p><p><strong>初始化的一般是叶子节点</strong></p><p>转移？<strong>由儿子向父亲转移，把所有儿子的信息合在一起</strong>。</p><p>$f_u&#x3D;\sum{f_v}+1$</p><p>树形 DP 的时候我们一般会进行 DFS，同时记录当前点和它的父亲。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(e[i].to,u);</span><br><span class="line">            f[u]+=f[v];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="直径"><a href="#直径" class="headerlink" title="直径"></a>直径</h2><blockquote><p>求树的直径，直径定义为树上两个最远距离的点的路径。</p></blockquote><p>树的直径无非是树上的两条链，而树上的一条链我们可以怎样表示？</p><p>假设从 $p_1$ 走到 $p_2$ ，那肯定是先走到它们的 $lca$ 再走到另一个点。</p><p>而对于一个点我只需要向下找两条尽量长的路径，拼起来就是以这个点为拐点的最长路径，这样对每个点的最长路径取一个 $max$ 就可以了。</p><p>那么怎么对每一个点都找到这样一条最长路径呢？</p><p>求以 $i$ 点出发向下的最长路和次长路，分别用 $f_i$ 和 $g_i$ 来表示。</p><p>对于叶子节点，两个量都是 0。</p><p>转移？</p><p>$f_i&#x3D;max(f_{p_j})+1$，$g_i$呢？，假如先走了 $p_3$ ，那么次长路就一定不能是 $p_3$ 因为这样就把 $i\leftrightarrow{p_3}$ 走了两遍，所以 $g_i&#x3D;second_max(f_{p_j})+1$</p><p>最后的答案为 $max(f_i+g_i)$</p><p>复杂度为 $O(n)$</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><blockquote><p>求树上所有路径长度和</p></blockquote><p>$f_i$ 表示以 $i$ 为根节点的子树的路径和，叶子节点为0，转移？没法转移，因为会有跨越不同子树的路径，还要维护一个 $g_i$ 表示所有点到根节点的距离之和。</p><p>$g_{p_1}+siz_{p_1}$ 就是所有点到 $i$ 的路径长度之和，它们到其它子树也要算上，也就是 $(g_{p_1}+siz_{p_1})\times(siz_i-siz_{p_1})$ ，因为这跳路径会被算这么多次。</p><p>所以：</p><p>$$<br>f_i&#x3D;\sum_{j\in{son_i}}f_{p_j}+(g_{p_j}+siz_{p_j}\times{val_{i\leftrightarrow{j}}})\times(siz_i-siz_{p_j})<br>$$</p><p>但是这样太复杂了，怎么优化呢？</p><p>其实我们只需要 DP 一个东西： $siz_i$</p><p>这个就已经足够了。</p><p>答案式：</p><p>$$<br>\sum_{i&#x3D;2}^n{siz_i\times{n-siz_i}\times{2}}<br>$$</p><p>刚才我们是以点的角度考虑的，不妨换一种角度，考虑每条边。</p><p>考虑有多少条路径包含了这条边，这条边的左边有一个子树，在这个子树内任意一个点出发，以这个子树外任意一点为终点，都会经过这条边，而起点和终点又可以交换，所以是这些。<strong>注意不包含根节点，因为我们实际考虑的是边的贡献</strong>。</p><h2 id="树的最大独立集"><a href="#树的最大独立集" class="headerlink" title="树的最大独立集"></a>树的最大独立集</h2><blockquote><p>问一个树最多能取出多少个点使得这些点都不相邻。</p></blockquote><p>状态为 $f_{i,0&#x2F;1}$ 代表第 $i$ 个点选&#x2F;不选时子树最大独立集的大小。</p><p>初始化的话就是对于每个叶子节点，$f_{i,0}&#x3D;0,f_{i,1}&#x3D;1$</p><p>那么转移呢？</p><p>如果 $i$ 这个点选了，那么它所有的儿子都不能选，也就是：</p><p>$f_{i,1}&#x3D;\sum_{j\in{son_i}}f_{j,0}+1$</p><p>不选就无所谓了</p><p>$f_{i,0}&#x3D;\sum_{j\in{son_i}}\max(f_{j,0},f_{j,1})$</p><h2 id="士兵"><a href="#士兵" class="headerlink" title="士兵"></a>士兵</h2><blockquote><p>在一棵树上布置士兵，每个士兵在节点上，每个士兵可以守护与其相连的点，问最少需要多少个士兵。</p></blockquote><p>第一维还是指以 $i$ 为根的子树，这个根节点有三种情况，一个是自己守护自己，一个是它的儿子守护它，一个是它的父亲守护它。</p><p>$0-son,1-self,2-fa$</p><p>对于叶子节点，$f_{i,0}&#x3D;inf,f_{i,1}&#x3D;1,f_{i,2}&#x3D;0$</p><p>转移？</p><p>$$<br>\begin{aligned}<br>f_{i,0}&amp;&#x3D;\sum_{j\in{son_i}}\<br>f_{i,1}&amp;&#x3D;\sum_{j\in{son_i}}\min(f_{j,0},f_{j,1},f_{j,2})+1\<br>f_{i,2}&amp;&#x3D;\sum_{j\in{son_i}}f_{j,0}\<br>\end{aligned}<br>$$</p><p>被父亲守护时，不能被儿子守护，因为这样会重复计算，同理在计算被儿子守护时不能计算被父亲守护。</p><p>被儿子守护时，至少一个儿子要有士兵，常见技巧：聚合儿子时，需要用另外一个 DP 来维护转移。</p><p>设 $g_{k,0&#x2F;1}$ 代表已经考虑完了前 $k$ 个儿子，是否至少有一个儿子放了士兵的所得到的最小士兵数量。</p><p>转移：</p><p>$$<br>g_{k,0}&#x3D;g_{k-1,0}+f_{p_k,0}<br>$$</p><p>$$<br>g_{k,1}&#x3D;\min(g_{k-1,0}+f_{p_k,1},g_{k-1,1}+f_{p_k,0},g_{k-1,1}+f_{p_k,1})<br>$$</p><p>这个 DP 就是为了聚合转移 $f_{i,0}$ 的。</p><p>假如 $i$ 有 $r$ 个儿子，那么 $f_{i,0}&#x3D;g_{r,1}$</p><p>树形DP的时候常用DP来做聚合。</p><h2 id="依赖背包-1"><a href="#依赖背包-1" class="headerlink" title="依赖背包"></a>依赖背包</h2><blockquote><p><strong>树形背包</strong><br>$n$ 个物品彼此组成一个树，如果想选第 $i$ 种物品，必须先选它的父亲，问获得的最大价值。</p></blockquote><p>状态：$f_{i,j}$ 前 $i$ 种物品用了 $j$ 的体积所得到的最大价值 $\to$ 在 $i$ 的子树中选一些物品用了 $j$ 的体积所能获得的最大价值。</p><p>初始化： 叶子节点 $f_{i,0}&#x3D;0,f_{i,w_i}&#x3D;v_i,f_{i,j}&#x3D;-inf$</p><p>转移： 聚合的时候就要再做一个背包：</p><p>$g_{i,j}$ 代表前 $i$ 个儿子的子树已经用掉了 $j$ 的体积得到的最大价值，$g_{0,0}&#x3D;0,g_{0,j}&#x3D;-inf$，转移就枚举一下第 $i$ 个儿子用掉了多少个体积：</p><p>$$<br>g_{i,j}&#x3D;\max_{0\le{k}\le{j}}(g_{i-1,j-k}+f_{i,k})<br>$$</p><p>$$<br>f_{i,0}&#x3D;0,f_{i,j}&#x3D;g_{r,j-v_i}+w_i<br>$$</p><p>所以这是一个不断用 $f$ 求 $g$ ，再用 $g$ 求 $f$ 的做法。</p><p>复杂度为 $O(n\times{m^2})$</p><hr><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2014">选课<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">305</span>;</span><br><span class="line"><span class="type">int</span> n,m,edcnt;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m<span class="number">+1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)</span><br><span class="line">                f[u][j]=<span class="built_in">max</span>(f[u][j],f[v][k]+f[u][j-k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;k,&amp;s[i]);</span><br><span class="line">        f[i][<span class="number">1</span>]=s[i];</span><br><span class="line">        <span class="built_in">add</span>(k,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">0</span>][m<span class="number">+1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h1><h2 id="DP-方式"><a href="#DP-方式" class="headerlink" title="DP 方式"></a>DP 方式</h2><blockquote><p><a class="link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/613107701">参考文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>迭代 or 记搜？</p></blockquote><p>记搜！</p><p>不要写迭代，又难想又难调。</p><p>常用形参：</p><ul><li><p>$pos$ 代表当前枚举到的位置，</p></li><li><p>$limit$ 代表当前这位所受限制（true 有限制，false 无限制）</p></li><li><p>$ans$ 记录前 $i$ 位的答案。</p></li></ul><p>设状态 $f_{pos,sum}$ 代表位置 $[pos+1,len]$ 已经填完了，这些数位之和在 $sum$ 的情况下，数位 $[1,pos]$ 无 $limit$ 的情况下，所有数的数位之和。</p><ul><li>$last$ 记录上一位选的数，通常是为了限制当前位。</li><li>$lead$ 是否有前导零。</li><li>$r$ 余数</li><li>$st$ 状态压缩</li></ul><p>一般递归树中只有叶子节点存储的是该节点状态的答案，其它节点都是累加了它以及它子树的状态的答案。</p><p>而且初始状态已经以形参的形式传入到函数当中，无需费心初始化。</p><p>$\text{dp}$ 数组的下标表示的是一种状态，独一无二的状态，一个状态是否要记录取决于它是否足够特殊，是否对答案有影响。</p><p>而有限制和无限制对应的状态又不同，因此当限制对答案数会产生影响时，要先判断没有限制，再记忆答案。</p><p>如何判断记忆化的值能否复用？</p><p>看下每次递归，影响答案的参数是否有改变？</p><p>是否是在非限制条件下记录的答案？</p><p>是否是在没有前导零的条件下记录的答案？</p><p>是否模数不同？</p><p>都要考虑。</p><h2 id="数的个数"><a href="#数的个数" class="headerlink" title="数的个数"></a>数的个数</h2><p>举个例子：给你两个整数 $l,r$，问 $[l,r]$ 有多少个数，显然答案是 $r-l+1$ ，那么怎么用数位DP来解决，数位DP的特征一般为 $[l,r]$ 中满足某种条件的数有多少个。</p><p>那就可以转化为 $[0,r]$ 中满足条件的数的个数减去 $[0,l-1]$ 之间满足条件的数。</p><p>所以我们就是询问 $[0,x]$ 这段区间内有多少个数了。</p><p>把 $x$ 的每一位 $x_i$ 都写下来，最高位为 $k$。</p><p>我现在要找 $y$ 满足 $0\le{y}\le{x}$，把 $y$ 的每一位 $y_i$ 也写下来，</p><p>也就是 $y_i$ 有多少种方案使得每一位的 $y\le x$ ，所以就从高位往低位依次去填，</p><p><strong>状态</strong> $f_{i,0&#x2F;1}$ 代表<strong>从高到低</strong>填到第 $i$ 位了当前已经填的这些位是<strong>等于</strong> $x$ 的这些位<strong>还是小于</strong> $x$ 的这些位，这种情况下的方案数。</p><p>其中，$0\to&lt;,1\to&#x3D;$</p><p>初始化 $f_{k+1,1}&#x3D;1$，第$k+1$ 位两个数都是零，所以两数相等。</p><p>转移：</p><p>$$<br>f_{i-1,0}+&#x3D;f_{i,0}\times{10}<br>$$</p><p>因为高位已经小于了，所以再往低一位填 $0\sim{9}$ 都可以，所以就是乘十。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=x[i<span class="number">-1</span>];j++)</span><br><span class="line">	f[i<span class="number">-1</span>][x[i<span class="number">-1</span>]==j]+=f[i][<span class="number">1</span>]; <span class="comment">// 如果这一位还相等，那么就转移后还想等，否则填完后就是小于。</span></span><br></pre></td></tr></table></figure></div><p>最后的答案就是 $f_{1,0}+f_{1,1}$ 代表 $0\sim{x}$ 小于等于 $x$ 的数的个数。</p><p>数位DP很常用一个前缀和优化。</p><p>状态设计常用 $f_{i,j}$，$i$ 表示填到第 $i$ 位了，$j$ 通常表示条件是否满足，以此决定下一位能填的数是多少，初始化就要保证两个数都没开始填的方案为 $1$，转移就枚举下一位填什么数。</p><h2 id="数位之和"><a href="#数位之和" class="headerlink" title="数位之和"></a>数位之和</h2><blockquote><p>求一个 $[l,r]$ 每个数每一位加起来的结果。</p></blockquote><p>先转为前缀和：$[0,x]$</p><p>还是老状态 $g_{i,0&#x2F;1}$ 值便为此时的数位之和，在你填下一位的时候，要考虑当前有多少个数，而数位之和就会多出这么多倍，所以我还要维护这样的数有多少个，把上一个题的 $f_{i,j}$ 代表这样的数有多少个。</p><p>转移和上面是同样的，只不过要加上当前填的数能填多少个 $+&#x3D;x\times{f_{i,j}}$，$x$为当前位置填的数。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g[i<span class="number">-1</span>][j&amp;&amp;(r==y[i<span class="number">-1</span>])]+=g[i][j]+f[i][j]*r;</span><br></pre></td></tr></table></figure></div><p>$g$ 代表数位之和。</p><p>合并一下：</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">+1</span>;i&gt;=<span class="number">2</span>;i--)<span class="comment">//第i位已经填好了，要填的是第i-1位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1</span>;j++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;=<span class="number">9</span>;r++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==<span class="number">1</span>&amp;&amp;r&gt;y[i<span class="number">-1</span>]) <span class="keyword">continue</span>;<span class="comment">//break;// 不用转移，因为假如相等后再有一个大于 x 的数，那么这整个数就更大了</span></span><br><span class="line">			f[i<span class="number">-1</span>][j&amp;&amp;(r==y[i<span class="number">-1</span>])]+=f[i][j]; <span class="comment">// 都满足才相等</span></span><br><span class="line">			g[i<span class="number">-1</span>][j&amp;&amp;(r==y[i<span class="number">-1</span>])]+=g[i][j]+f[i][j]*r;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></div><p>答案就是 $g_{1,0}+g_{1,1}$。</p><h2 id="差二"><a href="#差二" class="headerlink" title="差二"></a>差二</h2><blockquote><p>求 $[l,r]$ 之间满足相邻两个数之间差<strong>至少为</strong> $2$ 的数有多少个</p></blockquote><p>题目加了一个条件，很自然的想法就是再加一个维度，并且这个维度必然会影响我的转移，不然有啥价值。</p><p>设 $f_{i,j,k}$ 前两维都一样，第三维记录了 $i$ 这一位填什么。</p><p>填第 $i-1$ 位的时候，使得 $r-k\ge{2}$ 就可以了。</p><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2657">P2657<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p>注：而这个题还需要处理前导零的情况。</p><h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><blockquote><p>求 $[l,r]$ 之间有多少个回文数，不允许前导零存在。</p></blockquote><p>设 $f_{i,j,k}$ 前两维依旧相同，而找回文数的时候，我们不仅要比较高位与 $x$ 的大小关系，还要比较低位与 $x$ 的大小关系。</p><p>所以 $k$ 取 $0,1,2$ ，分别代表小于，等于，大于。</p><p>$j$ 代表正着填时与 $x$ 的大小关系，而 $k$ 代表对称那边与 $x$ 的大小关系。</p><p>因为只要前面比 $x$ 小，后面是可以比 $x$ 大的，所以可以填 $2$。</p><p>然后枚举一遍就可以了。</p><h2 id="积K"><a href="#积K" class="headerlink" title="积K"></a>积K</h2><blockquote><p>求 $[l,r]$ 之间满足各位数字之积为 $K$ 的数的个数，$l,r,k\le{10^{18}}$。</p></blockquote><p>设 $f_{i,j,r}$ 代表各位数之积为 $r$ 的方案数，虽然开不下，但是先这么想再考虑优化。</p><p>假如使 $K&#x3D;111$，那么一定在某个位置有 $3\times{37}$，而由于是一位一位的乘，所以最后它一定只有 $4$ 个质因子：$2,3,5,7$，因为一旦有其它质因子就直接输出无解就可以了。</p><p>所以 $f_{i,j,a,b,c,d}$ 把乘积为 $r$ 换成了 乘积用 $2^a+3^b+5^c+7^d$ 表示。</p><p>这个时候就可以正常进行 DP 了。</p><p>这样还没完，要考虑 $K$ 是否为 $0$，如果为 $0$，那么一定存在某位是 $0$，需要再开一维记录前 $i$ 位是否有 $0$；如果不是那么必然不存在某位为 $0$。</p><p>还要处理一下前导零的情况。</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote><p>给定一个区间 $[l,r]$，定义函数 $f(x)$ 代表 $x$ 每相邻两位差的绝对值之和，现在要在 $[l,r]$ 之间找这样一个最大的 $f(x)$。</p></blockquote><p>这道题还能拆成前缀和来做吗？</p><p>$\max$ 不可以通过前缀和来做的，所以 $l,r$ 拆不开了。</p><p>定义 $f_{i,j,k}$ 代表从高向低填到第 $i$ 位，$j$ 代表当前填的数与 $r$ 的这些位数相比是小于还是等于，$k$ 代表当前填的这些数与 $l$ 的这些位数是大于还是等于。</p><p>既然有两个限度，那就再开一维记录。</p><p>同时还要记录一下当前这位填的是什么： $f_{i,j,k,p}$</p><p>这样进行转移就可以了。</p><h2 id="棋盘"><a href="#棋盘" class="headerlink" title="棋盘"></a>棋盘</h2><blockquote><p>在 $n\times{m}$ 的棋盘上放若干个炮使得其互相不攻击的方案数。$n,m\le{100}$</p></blockquote><p>如果两个炮之间可以互相攻击，那么这一行或者这一列一定至少存在三个炮，所以每一行每一列放炮的数量就要 $\le{2}$。</p><p>用 $f_{i,j,k,l}$ 代表前 $i$ 行已经放好炮了，有 $j$ 列有一个炮，有 $k$ 列有一个炮，有 $l$ 列有两个炮。</p><p>但是 $j+k+l&#x3D;m$，所以可以去除冗余变量，那就把 $l$ 删掉，</p><p>那么最后就是 $f_{i,j,k}$ 代表这种情况下的方案数。</p><p>转移：</p><p>已经放好了前 $i$ 行的炮，现在要放第 $i+1$ 行的炮，</p><ul><li>放 $0$ 个炮：$f_{i+1,j,k}+&#x3D;f_{i,j,k}$</li><li>放 $1$ 个炮：<ul><li>放在有 $0$ 个炮的列：$f_{i+1,j-1,k+1}+&#x3D;f_{i,j,k}\times{j}$</li><li>放在有 $1$ 个炮的列：$f_{i+1,j,k-1}+&#x3D;f_{i,j,k}\times{k}$</li></ul></li><li>放 $2$ 个炮 ：<ul><li>一个放在 $0$ 个炮的列，一个放在 $1$ 个炮的列：$f_{i,j-1,k}+&#x3D;f_{i,j,k}\times{j}\times{k}$</li><li>两个都放在 $0$ 个炮的列：$f_{i+1,j-2,k+2}+&#x3D;f_{i,j,k}\times{C(j,2)}$</li><li>两个都放在 $1$ 个炮的列：$f_{i+1,j,k-2}+&#x3D;f_{i,j,k}\times{C(k,2)}$</li></ul></li></ul><p>其实可以发现一个性质，在求方案数时，其实我们是不关心到底是怎么放的，只关心这样放会有多少种方案，所以要记录与方案有关的信息。</p><h1 id="排列DP"><a href="#排列DP" class="headerlink" title="排列DP"></a>排列DP</h1><blockquote><p>这种题会告诉你有一个 $1\sim{n}$ 的排列，求其中满足某个条件的排列有多少个。<br>一共有 $n!$ 个排列。</p></blockquote><h2 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h2><blockquote><p>求 $1\sim{n}$ 的排列种，逆序对数量位偶数的排列数。</p></blockquote><p>答案是 $\frac{n!}{2}$，但是怎么用DP来解？</p><p>假设这里有一个 $1\sim{i}$ 的排列，在这里插入一个 $i+1$，就会变成一个 $1\sim{i+1}$ 的排列，所以我就可以不断插入数来得到最终的排列。</p><p>设 $f_{i,j}$ 已经处理完了所有 $1\sim{i}$ 的排列（填到了 $i$）此时逆序对数量为 $j$ 的方案数。</p><p>这就是排列DP常用的状态：$1\sim{i}$ 的排列已经处理完了且满足条件数量为 $j$ 的方案数。</p><p>初始化： $f_{1,0}&#x3D;1$</p><p>转移：枚举第 $i+1$ 个数插到哪里。有 $i$ 个数，$i+1$ 个位置，分别编号 $0\sim{i}$，那么插入到第 $k$ 个位置，由于我插入的是第 $i+1$ 个数，因此它比之前所有数都大，也就是说第 $k$ 个位置之后的数都比它小，这就是新产生的逆序对的个数 $i-k$。</p><p>优化：只关心奇偶性，并不关心到底是多少，所以第二维模二即可。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=i;k++)</span><br><span class="line">                f[i<span class="number">+1</span>][(j+i-k)%<span class="number">2</span>]+=f[i][j];</span><br></pre></td></tr></table></figure></div><p>排列DP不一定是从小到大或者从大到小插入，所以要根据不同情况定不同的状态，每次考虑下一个数怎么插入。</p><h2 id="激动"><a href="#激动" class="headerlink" title="激动"></a>激动</h2><blockquote><p>对于一个排列，它的激动值维序列中严格大于前面所有数的元素的个数。<br>给定 $n$ 个数，求它们每个数的所有排列中，激动值不超过 $k$ 的个数。</p></blockquote><p>这道题就要从大到小插入。</p><p>设 $f_{i,j}$ 代表从大到小已经把 $i\sim{n}$ 的数插入进来了，这个时候的激动值是 $j$ 的方案数。</p><p>这样每次插入的都是最小的数，无论把它插到哪里都不会影响原来的数的激动值，所以我们就只需要枚举它在哪里，只有它在最前面的时候激动值会加一，其它的时候激动值不变。</p><h2 id="LIS-1"><a href="#LIS-1" class="headerlink" title="LIS"></a>LIS</h2><blockquote><p>$1\sim{n}$ 的所有排列中，LIS 不超过 2 的排列数</p></blockquote><p>设 $f_{i,j}$ 代表已经插入了 $1\sim{i}$ 最长上升子序列的个数</p><p>假设从小到大插，插入了 $1\sim{i}$，下一个插入的是 $i+1$，前面所有的最长上升子序列要么是1要么是2。</p><p>最长上升子序列长度为1，当且仅当这个序列是降序排列，特殊处理一下即可。</p><p>最长上升子序列长度为2，$i+1$ 一定不能插入到任何一个最长上升子序列的右边，所以我要插到所有长度为2的上升子序列中最左边的右端点的左边。</p><p>$f_{i,j}$ 代表已经插完了 $1\sim{i}$，此时最长上升子序列最左端的右端点是 $j$。</p><p>这样就可以枚举 $0\sim{j-1}$ 就可以了，把 $i+1$ 插进去。</p><ul><li>$k!&#x3D;0:f_{i+1,j+1}+&#x3D;f_{i,j}$</li><li>$k&#x3D;0:f_{i+1,k}+&#x3D;f_{i,j}$</li></ul><h1 id="博弈DP"><a href="#博弈DP" class="headerlink" title="博弈DP"></a>博弈DP</h1><h1 id="DP-的单调队列优化"><a href="#DP-的单调队列优化" class="headerlink" title="DP 的单调队列优化"></a>DP 的单调队列优化</h1><p>对朴素 DP 进行等价变形。</p><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/137/">最大子段和<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>对于一个对应右端点，要找到一个左端点使得左端点前缀和最小。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> s[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = INT_MIN;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>; <span class="comment">// 0 号元素 sum0 = 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[hh] &lt; i - m) hh++; <span class="comment">// i 为窗口右端点的下一个位置</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, s[i] - s[q[hh]]);</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; s[q[tt]] &gt;= s[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="旅行问题"><a href="#旅行问题" class="headerlink" title="旅行问题"></a><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1090/">旅行问题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>破环成链。</p><p>所有前缀和都大于等于零，才能安全到达。</p><p>也就是区间和最小大于等于零，区间长度为 $n$。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL s[N];</span><br><span class="line"><span class="type">int</span> o[N], d[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;o[i], &amp;d[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        s[i] = s[i + n] = o[i] - d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++)</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + n; i; i--) <span class="comment">// 顺时针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &gt;= i + n) hh++;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; s[q[tt]] &gt;= s[i]) tt--;</span><br><span class="line">        q[++tt] = i; <span class="comment">// 包含 s_i 要先更新</span></span><br><span class="line">        <span class="comment">// 这里 i 为滑动窗口左端点</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= n) <span class="comment">// 小于等于 n 才能更新答案</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[q[hh]] &gt;= s[i - <span class="number">1</span>]) st[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">0</span>] = d[n]; <span class="comment">// 预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        s[i] = s[i + n] = o[i] - d[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++) s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++) <span class="comment">// 逆时针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - n) hh++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n) <span class="comment">// 这里 i 为滑动窗口右端点下一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[q[hh]] &lt;= s[i]) st[i - n] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; s[q[tt]] &lt;= s[i]) tt--;</span><br><span class="line">        q[++tt] = i; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="built_in">puts</span>(<span class="string">&quot;TAK&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="烽火传递"><a href="#烽火传递" class="headerlink" title="烽火传递"></a><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1091/">烽火传递<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// 点前 i 个且第 i 个必点的最小代价</span></span><br><span class="line"><span class="comment">// f[i] = min(f[j]) (i - m &lt;= j &lt; i) + w[i]</span></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>; <span class="comment">// 窗口内一开始有 0 这个元素</span></span><br><span class="line">    <span class="comment">// f[0] = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[hh] &lt; i - m) hh++;</span><br><span class="line">        f[i] = f[q[hh]] + a[i];</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; f[q[tt]] &gt;= f[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - m + <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 最后一段放一个烽火台</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, f[i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="绿色通道"><a href="#绿色通道" class="headerlink" title="绿色通道"></a><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1092/">绿色通道<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>上一道题加一个二分答案即可。</p><p>注意边界问题。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// 前 i 道题且第 i 道必写的最小时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[hh] &lt; i - mid - <span class="number">1</span>) hh++; <span class="comment">// 空了 mid 道</span></span><br><span class="line">        f[i] = f[q[hh]] + w[i];</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; f[q[tt]] &gt;= f[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - mid; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (f[i] &lt;= m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="修剪草坪"><a href="#修剪草坪" class="headerlink" title="修剪草坪"></a><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1089/">修剪草坪<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>$f_i$ 表示从前 $i$ 头奶牛中选且合法的所有方案中的最大价值。</p><p>不同点：第 $i$ 头牛选或者不选。</p><p>不选的话就是 $f_{i-1}$</p><p>选的话，最后一段的长度可能是 $[1,m-1]$</p><p>于是我们维护一段长度为 $m$ 的滑动窗口，里面元素的值为 $f_{j-1}-s_j$。</p><p>这样当 $j&#x3D;i-m$ 时刚好是 $s_i-s_{i-m}$ 为 $[i-m+1,i]$，这个时候 $i-j$ 是不能选的，因此只能保留 $f_{j-1}$</p><p>即 $f_i&#x3D;f_{i-j-1}+s_i-s_j$</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL s[N];</span><br><span class="line">LL f[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">g</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[i - <span class="number">1</span>] - s[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;s[i]);</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[hh] &lt; i - m) hh++;</span><br><span class="line">        f[i] = <span class="built_in">max</span>(f[i - <span class="number">1</span>], <span class="built_in">g</span>(q[hh]) + s[i]);</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">g</span>(q[tt]) &lt;= <span class="built_in">g</span>(i)) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="理想的正方形"><a href="#理想的正方形" class="headerlink" title="理想的正方形"></a><a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1093/">理想的正方形<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>先看一维，每一个点存的是以它为右端点长度为 $n$ 的区间的极值。</p><p>我们把所有行处理完了以后，再处理一遍列即可。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> row_max[N][N], row_min[N][N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_min</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[hh] &lt;= i - k) hh++; <span class="comment">// 包含右端点</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        b[i] = a[q[hh]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_max</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[hh] &lt;= i - k) hh++;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        b[i] = a[q[hh]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">get_min</span>(w[i], row_min[i], m);</span><br><span class="line">        <span class="built_in">get_max</span>(w[i], row_max[i], m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> a[N], b[N], c[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) a[j] = row_min[j][i];</span><br><span class="line">        <span class="built_in">get_min</span>(a, b, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) a[j] = row_max[j][i];</span><br><span class="line">        <span class="built_in">get_max</span>(a, c, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = k; j &lt;= n; j++)</span><br><span class="line">            res = <span class="built_in">min</span>(res, c[j] - b[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>Title:</strong> DP</li><li><strong>Author:</strong> Falling_Sakura</li><li><strong>Created at :</strong> 2023-03-26 20:53:16</li><li><strong>Updated at :</strong> 2025-09-24 10:24:52</li><li><strong>Link:</strong> https://vercel.fallingsakura.top/48659.html</li><li><strong>License: </strong>This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.</li></ul></div></div><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/915ab73.html"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item truncate max-w-48">NOIP-数学</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/34778.html"><span class="title flex justify-center items-center"><span class="post-nav-title-item truncate max-w-48">图论</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">Comments</div><div class="twikoo-container"><script data-swup-reload-script src="https://cdnjs.cloudflare.com/ajax/libs/twikoo/1.6.10/twikoo.all.min.js"></script><div id="twikoo-comment"></div><script data-swup-reload-script>function loadTwikoo() {
                twikoo.init({
                    el: '#twikoo-comment',
                    envId: 'https://twikoo.fallingsakura.top',
                });
            }

            if ('true') {
                const loadTwikooTimeout = setTimeout(() => {
                    loadTwikoo();
                    clearTimeout(loadTwikooTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadTwikoo);
            }</script></div></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">On this page</div><div class="page-title">DP</div><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7DP"><span class="nav-number">1.</span> <span class="nav-text">线性DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%8A%B6%E6%80%81"><span class="nav-number">1.1.</span> <span class="nav-text">1.状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">2.转移方程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E4%BE%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">典例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="nav-number">1.3.</span> <span class="nav-text">3.记忆化搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AB%E5%BC%8F%E6%80%9D%E8%80%83%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">闫式思考法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E8%B7%AF%E7%BA%BF%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.1.</span> <span class="nav-text">矩阵路线问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LIS"><span class="nav-number">1.4.2.</span> <span class="nav-text">LIS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA"><span class="nav-number">1.4.3.</span> <span class="nav-text">导弹拦截</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.4.4.</span> <span class="nav-text">最长公共子序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%88%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%EF%BC%89"><span class="nav-number">1.5.</span> <span class="nav-text">组合数问题（杨辉三角）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%B2%B3%E5%8D%92%E4%BD%86%E6%98%AF%E6%B2%A1%E6%9C%89%F0%9F%90%8E"><span class="nav-number">1.6.</span> <span class="nav-text">过河卒但是没有🐎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">1.7.</span> <span class="nav-text">数字三角形</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E7%89%88"><span class="nav-number">1.7.1.</span> <span class="nav-text">正常版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EX%E7%89%88"><span class="nav-number">1.7.2.</span> <span class="nav-text">EX版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A23"><span class="nav-number">1.7.3.</span> <span class="nav-text">数字三角形3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A24"><span class="nav-number">1.7.4.</span> <span class="nav-text">数字三角形4</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88Longest-Increasing-Subsequence%EF%BC%89"><span class="nav-number">1.8.</span> <span class="nav-text">最长上升子序列（Longest Increasing Subsequence）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%B1%82%E6%9C%80%E9%95%BF%E9%95%BF%E5%BA%A6"><span class="nav-number">1.8.1.</span> <span class="nav-text">1.求最长长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%B1%82%E6%96%B9%E6%A1%88%E6%95%B0"><span class="nav-number">1.8.2.</span> <span class="nav-text">2.求方案数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BE%93%E5%87%BA%E4%B8%80%E7%A7%8D%E6%96%B9%E6%A1%88%E6%95%B0"><span class="nav-number">1.8.3.</span> <span class="nav-text">3.输出一种方案数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-P2501"><span class="nav-number">1.8.4.</span> <span class="nav-text">4.P2501</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BC%98%E5%8C%96"><span class="nav-number">1.8.5.</span> <span class="nav-text">5.优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="nav-number">1.9.</span> <span class="nav-text">练习题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%91%E9%9B%AA%EF%BC%9A"><span class="nav-number">1.9.1.</span> <span class="nav-text">滑雪：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%8C%E9%BE%9F%E6%A3%8B"><span class="nav-number">1.9.2.</span> <span class="nav-text">乌龟棋</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E5%8C%85DP"><span class="nav-number">2.</span> <span class="nav-text">背包DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85"><span class="nav-number">2.1.</span> <span class="nav-text">01背包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E6%96%B9%E6%A1%88%E6%95%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">求方案数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E6%96%B9%E6%A1%88"><span class="nav-number">2.1.2.</span> <span class="nav-text">求方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.</span> <span class="nav-text">二维费用的背包问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E7%B1%BB"><span class="nav-number">2.3.</span> <span class="nav-text">初始化分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E7%A9%B7%E8%83%8C%E5%8C%85"><span class="nav-number">2.4.</span> <span class="nav-text">无穷背包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E6%96%B9%E6%A1%88%E6%95%B0-1"><span class="nav-number">2.4.1.</span> <span class="nav-text">求方案数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E9%99%90%E8%83%8C%E5%8C%85"><span class="nav-number">2.5.</span> <span class="nav-text">有限背包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E8%83%8C%E5%8C%85"><span class="nav-number">2.6.</span> <span class="nav-text">限制背包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"><span class="nav-number">2.7.</span> <span class="nav-text">分组背包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85"><span class="nav-number">2.8.</span> <span class="nav-text">混合背包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E8%83%8C%E5%8C%85"><span class="nav-number">2.9.</span> <span class="nav-text">依赖背包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%BD%E9%87%8F%E7%9F%B3%E9%97%AE%E9%A2%98"><span class="nav-number">2.10.</span> <span class="nav-text">能量石问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">状态机模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8A%B6%E5%8E%8BDP"><span class="nav-number">4.</span> <span class="nav-text">状压DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%8B%E7%9B%98%E5%BC%8F%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%BF%9E%E9%80%9A%E6%80%A7%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">棋盘式（基于连通性）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%EF%BC%88TSP%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">旅行商问题（TSP）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F%EF%BC%88%E5%9F%BA%E4%BA%8E%E9%9B%86%E5%90%88%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">愤怒的小鸟（基于集合）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4DP"><span class="nav-number">5.</span> <span class="nav-text">区间DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E7%9F%B3%E5%AD%90"><span class="nav-number">5.2.</span> <span class="nav-text">合并石子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">矩阵乘法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#POJ2955-%E6%9C%80%E9%95%BF%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="nav-number">5.4.</span> <span class="nav-text">POJ2955 最长括号匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#POJ1651-%E5%88%A0%E6%95%B0"><span class="nav-number">5.5.</span> <span class="nav-text">POJ1651 删数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HDU4632-%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">5.6.</span> <span class="nav-text">HDU4632 回文子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="nav-number">5.7.</span> <span class="nav-text">凸多边形</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2DP"><span class="nav-number">6.</span> <span class="nav-text">树形DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%82%B9%E6%95%B0"><span class="nav-number">6.1.</span> <span class="nav-text">点数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E5%BE%84"><span class="nav-number">6.2.</span> <span class="nav-text">直径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84"><span class="nav-number">6.3.</span> <span class="nav-text">路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86"><span class="nav-number">6.4.</span> <span class="nav-text">树的最大独立集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%AB%E5%85%B5"><span class="nav-number">6.5.</span> <span class="nav-text">士兵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E8%83%8C%E5%8C%85-1"><span class="nav-number">6.6.</span> <span class="nav-text">依赖背包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E4%BD%8DDP"><span class="nav-number">7.</span> <span class="nav-text">数位DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DP-%E6%96%B9%E5%BC%8F"><span class="nav-number">7.1.</span> <span class="nav-text">DP 方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">数的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E4%BD%8D%E4%B9%8B%E5%92%8C"><span class="nav-number">7.3.</span> <span class="nav-text">数位之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%AE%E4%BA%8C"><span class="nav-number">7.4.</span> <span class="nav-text">差二</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E6%95%B0"><span class="nav-number">7.5.</span> <span class="nav-text">回文数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%AFK"><span class="nav-number">7.6.</span> <span class="nav-text">积K</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#F"><span class="nav-number">7.7.</span> <span class="nav-text">F</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%8B%E7%9B%98"><span class="nav-number">7.8.</span> <span class="nav-text">棋盘</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%88%97DP"><span class="nav-number">8.</span> <span class="nav-text">排列DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-number">8.1.</span> <span class="nav-text">逆序对</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BF%80%E5%8A%A8"><span class="nav-number">8.2.</span> <span class="nav-text">激动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LIS-1"><span class="nav-number">8.3.</span> <span class="nav-text">LIS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%9A%E5%BC%88DP"><span class="nav-number">9.</span> <span class="nav-text">博弈DP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DP-%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96"><span class="nav-number">10.</span> <span class="nav-text">DP 的单调队列优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C"><span class="nav-number">10.1.</span> <span class="nav-text">最大子段和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%85%E8%A1%8C%E9%97%AE%E9%A2%98"><span class="nav-number">10.2.</span> <span class="nav-text">旅行问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%83%BD%E7%81%AB%E4%BC%A0%E9%80%92"><span class="nav-number">10.3.</span> <span class="nav-text">烽火传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%BF%E8%89%B2%E9%80%9A%E9%81%93"><span class="nav-number">10.4.</span> <span class="nav-text">绿色通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E5%89%AA%E8%8D%89%E5%9D%AA"><span class="nav-number">10.5.</span> <span class="nav-text">修剪草坪</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-number">10.6.</span> <span class="nav-text">理想的正方形</span></a></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="customize-info my-1">人类的悲欢本不相通我只觉得他们吵闹.</div><div class="text-center">&copy; <span>2023</span> - 2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">Falling_Sakura</a><p class="post-count space-x-0.5"><span>33 posts in total </span><span>176.7k words in total</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">VISITOR COUNT</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">TOTAL PAGE VIEWS</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span> <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span></div><div>Blog up for <span class="odometer" id="runtime_days"></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec</div><script data-swup-reload-script>try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/Swup.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/SwupSlideTheme.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/SwupProgressPlugin.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/SwupScrollPlugin.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });</script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/tools/imageViewer.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/utils.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/main.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/layouts/navbarShrink.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/tools/scrollTopBottom.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/tools/lightDarkSwitch.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/layouts/categoryList.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/tools/localSearch.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/tools/codeBlock.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/layouts/lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/tools/runtime.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/assets/odometer-theme-minimal.css"><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/Typed.min.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/plugins/typed.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/mermaid.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/plugins/mermaid.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/minimasonry.min.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/plugins/masonry.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/plugins/tabs.js" data-swup-reload-script></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/layouts/essays.js" data-swup-reload-script></script></body></html>