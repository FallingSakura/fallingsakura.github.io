<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Base64 Encoding</title>
    <url>/c499c9c8.html</url>
    <content><![CDATA[<h1 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h1><p><a href="https://www.json.cn/document/base64"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202409111035330.webp"
                      alt="image.png"
                ></a></p>
<p>讲解一下它的编码过程。</p>
<p>首先把字符转换成 ASCII 编码，然后把它的 ASCII 编码转换为八位二进制码，按顺序连接在一起，然后从最开始六个二进制码对应一个 0～63 的数字，对应到 Base64 编码表，每 3 个字符对应得到 4 个编码后的结果，某一个 6 位中不全则用 0 补齐，若 6 位都是空则对应编码为 <code>=</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202409111047913.webp"
                      alt="image.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202409111047613.webp"
                      alt="image.png"
                ></p>
<p>ASCII (American Standard Information Interchange):</p>
<p><a class="link"   href="https://www.json.cn/document/ascii/" >Link<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>encode</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++/C# Note</title>
    <url>/edeb27c6.html</url>
    <content><![CDATA[<blockquote>
<p>三种语言的相似之处有很多，先后学了 <code>c++</code> <code>c</code> <code>c#</code>，把一些之前不知道的东西记录一下，写过很多遍的就不整理了。</p>
</blockquote>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><blockquote>
<p>c++&#x2F;c#</p>
</blockquote>
<p>枚举 <code>enum</code> 是一种用户定义的类型，它由一组命名的整数常量组成。枚举类型的主要目的是提高代码的可读性和可维护性，特别是在处理一组相关的常量时。</p>
<p><strong>示例</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">eDirection</span> &#123; STOP = <span class="number">0</span>, LEFT, RIGHT, UP, DOWN &#125;;</span><br><span class="line">eDirection dir;</span><br></pre></td></tr></table></figure></div>

<p>这里就定义了一个枚举类型 <code>eDirection</code>，和这个类型的一个变量 <code>dir</code>，它只可以取其中这些常量的值。</p>
<p>里面的值可以设定，默认是递增的。</p>
<p>访问即 <code>dir.LEFT</code>，这样可以使代码更直观</p>
<h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><h2 id="conio-h"><a href="#conio-h" class="headerlink" title="conio.h"></a>conio.h</h2><blockquote>
<p>c++</p>
</blockquote>
<p><strong><code>_kbhit()</code></strong></p>
<p>如果有键盘输入，则返回 1.</p>
<p>否则返回 0.</p>
<p>它是非阻塞的，这点与 <code>_getch()</code> 不同。</p>
<p><strong><code>_getch()</code></strong></p>
<p>从控制台中读取单个字符，不需要回车键。</p>
<p>且读取的字符不会在控制台中显示。</p>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><blockquote>
<p>c#</p>
</blockquote>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>关键字 <code>static</code>。</p>
<p>每一个 <code>class</code> 都有它的变量、函数等。</p>
<p><strong>对象</strong>是<strong>类</strong>的<strong>实例</strong>。</p>
<p>如果是 <code>static</code> 类型的变量，那么无需为这个 <code>class</code> 实例化（即创建一个对象）便可以修改它的值。</p>
<p>示例：</p>
<div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Myclass</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">int</span> staticNum;</span><br><span class="line">	<span class="built_in">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line">Myclass myclass = <span class="keyword">new</span> Myclass();</span><br><span class="line">myclass.num = <span class="number">6</span>;</span><br><span class="line">Myclass.staticNum = <span class="number">6</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><ul>
<li><code>public</code></li>
</ul>
<p>修饰类时，代表它可以被任何文件的任何代码访问。</p>
<p>修饰成员时，表示这个对象可以在任何位置被访问。</p>
<ul>
<li><code>private</code></li>
</ul>
<p>只能修饰成员，表示这个变量只可以在对象内部被访问。</p>
<ul>
<li><code>internal</code></li>
</ul>
<p>类或成员只能被一个程序集中的代码访问，类的默认修饰符。</p>
<ul>
<li><code>protected</code></li>
</ul>
<p>子类可以访问，而外部不可访问。</p>
<h2 id="Class-与-Struct"><a href="#Class-与-Struct" class="headerlink" title="Class 与 Struct"></a>Class 与 Struct</h2><p>它们的区别在何处？</p>
<p><code>class</code> 变量储存的是地址，而 <code>sruct</code> 变量储存的是值。</p>
<p>也就是说，如果将一个 <code>class</code> 赋值给另一个 <code>class</code>，那么这两个 <code>class</code> 所指向的是相同的变量。</p>
<p>而如果把一个 <code>struct</code> 赋值给另一个 <code>struct</code>，那么这两个 <code>struct</code> 是两个值相同的不同的变量。</p>
<p>同样，当 <code>class</code> 作为形参传入一个函数时，它的值会受到函数内修改的影响，因为访问的都是同一个地址。</p>
<p>而 <code>struct</code> 作为值只是复制了一份传入函数，函数内修改的是复制体，并不会影响到外面的值。</p>
<p>对 <code>struct</code> 使用 <code>ref</code> 关键字，即取地址，即可实现和 <code>class</code> 一样的效果。</p>
<hr>
<p><code>struct</code> 不能继承 <code>struct</code> 或者 <code>class</code>，无法被继承，只能继承接口。</p>
<p><code>class</code> 可以继承一个父类，也可以继承接口。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><code>public class A : B</code> 表示类 A 继承类B，A 是子类，B 是父类，子类可以使用父类中的变量。</p>
<p>而如果子类中某个函数不想使用父类中的函数，可以采用 <code>override</code> 关键字重新定义这个函数。</p>
<div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">fn</span>()</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>同时需要在父类的这个函数中添加 <code>virtual</code> 关键字表示这个函数允许被重写。</p>
<div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fn</span>()</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要注意，父类变量可以存储子类变量的值，但子类变量不可以存储父类变量的值。</p>
<p>所有类型的基类是 <code>object</code>。</p>
<h2 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h2><p>在类前加上此关键字可以在各个文件中写这个类，并且它们最终会合并在一起。</p>
<div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">p</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在类前加上 <code>interface</code> 便可以作为一个接口。</p>
<p>接口内定义若干方法，而不定义它们的实现，且不能添加访问修饰符，默认 <code>public</code>。</p>
<p>接口只提供声明，不提供实现。</p>
<p>所以继承接口后需要给出它相应的实现。</p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>添加 <code>abstract</code> 的类无法被实例化，并且可以暂时不实现接口。</p>
<p><code>abstract</code> 也可以修饰函数，只声明不实现，留给子类实现。</p>
<p>抽象类中可以实现接口。</p>
<p>类只能继承一个抽象类。</p>
<p>抽象类也可以自己声明函数、属性并实现。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GV</span>&lt;<span class="title">T</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> T x;</span><br><span class="line">	<span class="keyword">public</span> T y;</span><br><span class="line">&#125;</span><br><span class="line">GV&lt;<span class="built_in">int</span>&gt; giv = <span class="keyword">new</span> GV&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure></div>

<p>这样就可以实现同一份代码的不同类型。</p>
<p>泛型方法：</p>
<div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attack</span>&lt;<span class="title">T</span>&gt;(<span class="params">T a, T b</span>) <span class="keyword">where</span> T : Actor</span>&#123;</span><br><span class="line">	a.Attack();</span><br><span class="line">	b.Attack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要说明这个泛型继承自哪个类，否则默认就是 <code>object</code>。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>使用 <code>delegate</code> 声明一个类型，它可以储存多个相同形式的函数并依次执行，通过 <code>+=</code> 和 <code>-=</code> 控制里面的函数。</p>
<p>包括这个函数的类型，形参等。</p>
<div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">float</span> <span class="title">CalcFn</span>(<span class="params"><span class="built_in">float</span> v1, <span class="built_in">float</span> v2</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">float</span> <span class="title">Add</span>(<span class="params"><span class="built_in">float</span> a, <span class="built_in">float</span> b</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">float</span> <span class="title">Mul</span>(<span class="params"><span class="built_in">float</span> a, <span class="built_in">float</span> b</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CalcFn p = Add;</span><br><span class="line">p(<span class="number">1f</span>, <span class="number">2f</span>);</span><br><span class="line">p += Mul;</span><br><span class="line">p(<span class="number">1f</span>, <span class="number">2f</span>);</span><br></pre></td></tr></table></figure></div>

<p>相当于一个函数集合。</p>
<p><code>Func&lt;T1, T2, TResult&gt;</code> 表示一个委托类型，前面几个是输入参数的类型，最后一个是返回值的类型。</p>
<p><code>Action&lt;T1, T2&gt;</code> 是无返回值</p>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>c season</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBase_Note</title>
    <url>/2c7dde30.html</url>
    <content><![CDATA[<p>数据库是一种组织、存储和管理数据的系统。它允许用户以结构化的方式存储和检索数据，通常通过数据库管理系统（DBMS）进行操作。</p>
<h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><ol>
<li><strong>关系型数据库</strong>：如 MySQL、PostgreSQL、Oracle。使用<strong>表格</strong>来组织数据，通过 SQL 进行操作（这么说 Excel 也可以是一种数据库）。</li>
<li><strong>非关系型数据库（NoSQL）</strong>：如 MongoDB、Cassandra。用于处理大规模和非结构化数据，灵活性更高。</li>
<li><strong>内存数据库</strong>：如 Redis、Memcached。用于需要高速读写的数据，数据存储在内存中。</li>
</ol>
<table>
<thead>
<tr>
<th>概念</th>
<th>关系型数据库（如MySQL）</th>
<th>非关系型数据库（如MongoDB）</th>
</tr>
</thead>
<tbody><tr>
<td>表&#x2F;集合</td>
<td>表（Table）</td>
<td>集合（Collection）</td>
</tr>
<tr>
<td>行&#x2F;文档</td>
<td>行（Row）</td>
<td>文档（Document）</td>
</tr>
<tr>
<td>列&#x2F;字段</td>
<td>列（Column）</td>
<td>字段（Field）</td>
</tr>
<tr>
<td>模式</td>
<td>固定模式（Schema）</td>
<td>无模式（Schema-less）</td>
</tr>
<tr>
<td>关系</td>
<td>支持复杂的表与表之间的关系</td>
<td>不直接支持</td>
</tr>
</tbody></table>
<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><p>那就从 MongoDB 开始学起，原因是之前配置 twikoo 的评论系统时误打误撞用到过，现在的一个新项目需要用到数据库。</p>
<p>MongoDB 是一种文档型 NoSQL 数据库，主要有以下特点：</p>
<ul>
<li><strong>文档型存储</strong>：数据以文档的形式存储，文档是JSON格式的（MongoDB中称为BSON格式，二进制形式的JSON）。</li>
<li><strong>无模式</strong>：与传统数据库不同，MongoDB中的文档不需要固定的表结构，可以灵活地存储不同结构的数据。</li>
<li><strong>横向扩展</strong>：MongoDB可以很容易地通过增加更多的服务器节点来应对数据的增长，而不需要更强的硬件。</li>
</ul>
<p>可以下载 <a class="link"   href="https://www.mongodb.com/try/download/compass" >Compass<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 使用它的 GUI 界面。</p>
<p>它的结构是，Cluster（集群）里有多个数据库，每个数据库是相同的，这样一个分布式结构保证它的安全稳定。</p>
<p>Database（数据库）中有多个 Collection（集合），在集合中有多个 Document（文档），文档就是存储数据的地方，它的格式是 BSON（JSON 的二进制格式，便于存储），Field（字段）就是键，以及它有对应的值。</p>
<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p>Create, Read, Update, Delete，四种数据库的基本操作。</p>
<p><a class="link"   href="https://www.mongodb.com/zh-cn/docs/manual/crud/" >文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Install &amp; Usage</title>
    <url>/4a7ef8fa.html</url>
    <content><![CDATA[<blockquote>
<p>In ubuntu24.04</p>
</blockquote>
<p>Docker Desktop is not supported for ubuntu24.04.</p>
<ol>
<li>卸载旧版本</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get remove docker \</span><br><span class="line">               docker-engine \</span><br><span class="line">               docker.io</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>更新系统软件包</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>安装依赖</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release \</span><br><span class="line">    software-properties-common \</span><br><span class="line">    uidmap </span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>配置软件源</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | <span class="built_in">sudo</span> gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>安装 Docker</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure></div>

<p>使用 <code>docker --version</code> 验证是否安装成功。</p>
<ol start="6">
<li>启动 Docker</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure></div>

<ol start="7">
<li>添加用户组</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></div>

<ol start="8">
<li>测试</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image <span class="string">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">c1ec31eb5944: Pull complete </span><br><span class="line">Digest: sha256:91fb4b041da273d5a3273b6d587d62d518300a6ad268b28628f74997b93171b2</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure></div>

<ol start="9">
<li>终端登陆 Dockerhub</li>
</ol>
<p>先去 <a class="link"   href="https://hub.docker.com/" >Dockerhub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 注册一个账号，然后在右上角点击头像，点击 <code>Account Settings</code>，在 <code>Security</code> 中点击 <code>Personal access tokens</code>，然后新建一个 Token，编辑对应名称和权限后，使用它所给出的命令即可。</p>
<p>若出现 <code>Error saving credentials: error storing credentials - err: exec: &quot;docker-credential-desktop&quot;: executable file not found in $PATH, out: `` </code>，则编辑 <code>~/.docker.config.json</code>，把 <code>credsStore</code> 一项删除即可。</p>
<ol start="10">
<li>设置开机自启动</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure></div>

<ol start="11">
<li>检查 Docker 服务状态</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status docker</span><br><span class="line"></span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">     Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; preset: enabled)</span><br><span class="line">    Drop-In: /etc/systemd/system/docker.service.d</span><br><span class="line">             └─http-proxy.conf</span><br><span class="line">     Active: active (running) since Fri 2024-09-13 12:42:41 CST; 41min ago</span><br><span class="line">TriggeredBy: ● docker.socket</span><br><span class="line">       Docs: https://docs.docker.com</span><br><span class="line">   Main PID: 142120 (dockerd)</span><br><span class="line">      Tasks: 20</span><br><span class="line">     Memory: 23.8M (peak: 29.9M)</span><br><span class="line">        CPU: 788ms</span><br><span class="line">     CGroup: /system.slice/docker.service</span><br><span class="line">             └─142120 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.s</span><br></pre></td></tr></table></figure></div>

<ol start="12">
<li>配置 rootless（选）</li>
</ol>
<p>放个<a class="link"   href="https://docs.docker.com/engine/security/rootless/" >官方文档链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ol start="13">
<li>通过 Github Action 实现 Docker 镜像自动化构建和推送</li>
</ol>
<div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Push</span> <span class="string">Docker</span> <span class="string">Image</span> <span class="string">with</span> <span class="string">Incremental</span> <span class="string">Tagging</span> <span class="string">and</span> <span class="string">Version</span> <span class="string">Bump</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">repository</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">fetch-depth:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">tags:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">the</span> <span class="string">latest</span> <span class="string">Git</span> <span class="string">tag</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">get_tag</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        TAG=$(git describe --tags --abbrev=0 || echo &quot;v0.0&quot;)</span></span><br><span class="line"><span class="string">        echo &quot;Latest tag: $TAG&quot;</span></span><br><span class="line"><span class="string">        echo &quot;CURRENT_TAG=$TAG&quot; &gt;&gt; $GITHUB_ENV</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Calculate</span> <span class="string">new</span> <span class="string">tag</span> <span class="string">with</span> <span class="string">version</span> <span class="string">bump</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">calc_new_tag</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        CURRENT_TAG=$&#123;&#123; env.CURRENT_TAG &#125;&#125;</span></span><br><span class="line"><span class="string">        VERSION=$(echo $CURRENT_TAG | sed &#x27;s/v//g&#x27;)  </span></span><br><span class="line"><span class="string">        MAJOR=$(echo $VERSION | cut -d. -f1)  </span></span><br><span class="line"><span class="string">        MINOR=$(echo $VERSION | cut -d. -f2)  </span></span><br><span class="line"><span class="string"></span>        </span><br><span class="line">        <span class="string">if</span> [ <span class="string">$MINOR</span> <span class="string">-lt</span> <span class="number">9</span> ]<span class="string">;</span> <span class="string">then</span></span><br><span class="line">          <span class="string">NEW_MINOR=$((MINOR+1))</span>  </span><br><span class="line">          <span class="string">NEW_TAG=&quot;v$MAJOR.$NEW_MINOR&quot;</span></span><br><span class="line">        <span class="string">else</span></span><br><span class="line">          <span class="string">NEW_MAJOR=$((MAJOR+1))</span>  </span><br><span class="line">          <span class="string">NEW_MINOR=0</span>  </span><br><span class="line">          <span class="string">NEW_TAG=&quot;v$NEW_MAJOR.$NEW_MINOR&quot;</span></span><br><span class="line">        <span class="string">fi</span></span><br><span class="line"></span><br><span class="line">        <span class="string">echo</span> <span class="string">&quot;New tag: $NEW_TAG&quot;</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">&quot;NEW_TAG=$NEW_TAG&quot;</span> <span class="string">&gt;&gt;</span> <span class="string">$GITHUB_ENV</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Log</span> <span class="string">in</span> <span class="string">to</span> <span class="string">DockerHub</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">docker/login-action@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKERHUB_USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKERHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">tag</span> <span class="string">Docker</span> <span class="string">image</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        docker build -t $&#123;&#123; secrets.DOCKERHUB_USERNAME &#125;&#125;/technews-frontend:$&#123;&#123; env.NEW_TAG &#125;&#125; .</span></span><br><span class="line"><span class="string">        docker tag $&#123;&#123; secrets.DOCKERHUB_USERNAME &#125;&#125;/technews-frontend:$&#123;&#123; env.NEW_TAG &#125;&#125; $&#123;&#123; secrets.DOCKERHUB_USERNAME &#125;&#125;/technews-frontend:latest</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Push</span> <span class="string">Docker</span> <span class="string">image</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        docker push $&#123;&#123; secrets.DOCKERHUB_USERNAME &#125;&#125;/technews-frontend:$&#123;&#123; env.NEW_TAG &#125;&#125;</span></span><br><span class="line"><span class="string">        docker push $&#123;&#123; secrets.DOCKERHUB_USERNAME &#125;&#125;/technews-frontend:latest</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Git</span> <span class="string">credentials</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        git config user.name &quot;github-actions[bot]&quot;</span></span><br><span class="line"><span class="string">        git config user.email &quot;github-actions[bot]@users.noreply.github.com&quot;</span></span><br><span class="line"><span class="string">        git remote set-url origin https://x-access-token:$&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;@github.com/$&#123;&#123; github.repository &#125;&#125;.git</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">new</span> <span class="string">Git</span> <span class="string">tag</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        git tag $&#123;&#123; env.NEW_TAG &#125;&#125;</span></span><br><span class="line"><span class="string">        git push origin $&#123;&#123; env.NEW_TAG &#125;&#125;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Note</title>
    <url>/d51d3626.html</url>
    <content><![CDATA[<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="特殊关键字"><a href="#特殊关键字" class="headerlink" title="特殊关键字"></a>特殊关键字</h2><p>如 <code>inherit</code> <code>initial</code> <code>unset</code> 这三个属性值，在任何属性中均可用。</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>我们可以通过添加 <code>class</code> 或者 <code>id</code> 的方式来选择特定的元素为它添加特定的样式。</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">	<span class="comment">/* .class to choose a class */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#id</span> &#123;</span><br><span class="line">	<span class="comment">/* #id to choose an id */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="根选择器"><a href="#根选择器" class="headerlink" title="根选择器"></a>根选择器</h3><p><strong><code>:root</code></strong></p>
<p>在 HTML 文件中通常是 <code>&lt;html&gt;</code> 元素，具有全局性和高优先级。</p>
<p>适合定义 CSS 变量。</p>
<p>为什么不使用 <code>*</code> 来定义变量呢？</p>
<ul>
<li><strong>性能问题</strong>：通配选择器会匹配文档中的每一个元素，可能会影响性能，尤其是在大型文档中。</li>
<li><strong>优先级较低</strong>：通配选择器的优先级较低，定义在其中的变量可能会被其他样式覆盖。</li>
<li><strong>语义不明确</strong>：使用 <code>*</code> 来定义全局变量不够直观，无法清楚表达这些变量是全局的，可能会导致混淆。</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>一个元素可以有多个类名，在引号内用空格隔开。</p>
<p>这时我们想选择既是这个元素同时还有这个类名，那么可以这样写：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span><span class="selector-class">.class</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意这里两者之间没有空格。</p>
<p>当两者间有空格时，代表 <code>.class</code> 是 <code>body</code> 的后代中的一个类。</p>
<h2 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h2><p>值得一提的是，表单元素的默认样式会覆盖掉默认继承的样式，需要设置为 <code>inherit</code>。</p>
<h2 id="Var"><a href="#Var" class="headerlink" title="Var"></a>Var</h2><p>CSS 变量。</p>
<p>变量使用 <code>--</code> 开头，并通过 <code>var()</code> 函数调用。</p>
<p>可以添加默认值，当该变量未定义时，便可以使用默认值。</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--undefined-color, <span class="number">#000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h2><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>: [color];</span><br></pre></td></tr></table></figure></div>

<p><code>color</code> 可以是色名，可以是 rgb，可以是 rgba，可以是十六进制数。</p>
<h2 id="Font"><a href="#Font" class="headerlink" title="Font"></a>Font</h2><p>导入字体。</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">../fonts/None.ttf</span>);</span><br><span class="line">  <span class="attribute">font-family</span>: None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>url</code> 填写字体文件的本地地址&#x2F;云端地址。</p>
<p>导入后为它设定一个 <code>font-family</code>（好听的名字），</p>
<p>然后就可以调用它了。</p>
<h2 id="Margin"><a href="#Margin" class="headerlink" title="Margin"></a>Margin</h2><p>外边距。</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin</span>: [length|percentage|auto]</span><br></pre></td></tr></table></figure></div>

<p>值有四个，顺序为<strong>上右下左</strong>，当某位置没有时将按照它对位的间距同步。</p>
<p>如只有两个值时，第一个代表上下外边距，第二个代表左右外边距。</p>
<p>下图为经典盒模型。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model/box-model.png"
                     
                ></p>
<h2 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h2><p>内边距。</p>
<p>即内容到 <code>border</code> 之间的空间。</p>
<h2 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h2><p>边框，其外是 <code>margin</code> 其内是 <code>padding</code>。</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: [width] [style] [color];</span><br></pre></td></tr></table></figure></div>

<p>具体的长度单位可以见<a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Values_and_units" >CSS 的值与单位 - 学习 Web 开发 | MDN (mozilla.org)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><strong><code>style</code></strong></p>
<ul>
<li><code>none</code>：去除</li>
<li><code>hidden</code>：隐藏，不占用空间，但在表单中可能有特殊行为</li>
<li><code>dotted</code>：圆点</li>
<li><code>dashed</code>：虚线</li>
<li><code>solid</code>：实线</li>
<li><code>double</code>：双实线</li>
<li><code>groove</code>：雕刻</li>
<li><code>ridge</code>：浮雕</li>
<li><code>inset</code>：陷入</li>
<li><code>outset</code>：突出</li>
</ul>
<p>颜色就不必多说了。</p>
<p><code>border-radius</code> 属性可以改 <code>border</code> 的圆角大小。</p>
<p>MDN 样例：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.5rem</span> outset pink;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">0.5rem</span> solid khaki;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2rem</span> skyblue;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">font</span>: bold <span class="number">1rem</span> sans-serif;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">outline-offset</span>: <span class="number">0.5rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202403160529773.webp"
                      alt="image.png"
                ></p>
<p>需要注意的是，<code>border</code> 是有体积的，并且会随着缩放而变化，所以如果要计算宽度需要格外注意。</p>
<p>所以如果想固定盒子的实际大小的话，可以使用<strong>替代盒模型</strong>。</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样盒子的实际大小完全由 <code>width</code> 和 <code>height</code> 来决定，减去 <code>padding</code> 和 <code>border</code> 即为 <code>content</code> 的大小。</p>
<p>如果想全局都使用此模型，可以这样写：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*,</span><br><span class="line">*<span class="selector-pseudo">::before</span>,</span><br><span class="line">*<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>渐变边框：</strong></p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-image</span>: &lt;source&gt; &lt;slice&gt; / &lt;width&gt; / &lt;outset&gt; &lt;repeat&gt;;</span><br></pre></td></tr></table></figure></div>

<p>比较推荐的做法是盒子嵌套一下，外面整上 <code>padding</code> 模拟边框。</p>
<h2 id="Opacity"><a href="#Opacity" class="headerlink" title="Opacity"></a>Opacity</h2><p>透明度，该元素及其后代元素的透明度都会受到影响，若不想后代元素受到影响，可以通过 <code>background-color</code> 来调整背景透明度。</p>
<h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><p>与 Border 类似，但是不占用空间，属性值为 大小、颜色、样式，顺序不重要。</p>
<p><code>outline-offset</code> 用来设置元素边缘与 <code>outline</code> 之间的间隙。</p>
<h2 id="Shadow"><a href="#Shadow" class="headerlink" title="Shadow"></a>Shadow</h2><h3 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h3><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: [inset] [x-offset] [y-offset] [blur-radius] [spread-radius] [color];</span><br></pre></td></tr></table></figure></div>

<p>第一个参数为可选项，加上 <code>inset</code> 即为内阴影，不写时默认为外阴影。</p>
<h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">text-shadow</span>: [x-offset] [y-offset] [blur-radius] [color];</span><br></pre></td></tr></table></figure></div>

<p>与 <code>box-shadow</code> 类似。</p>
<p><code>shadow</code> 可以重叠，用 <code>,</code> 隔开即可。</p>
<h2 id="Text-decoration"><a href="#Text-decoration" class="headerlink" title="Text-decoration"></a>Text-decoration</h2><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">text-decoration</span>: [underline/overline/line-through] [color] [style] [thickness]</span><br></pre></td></tr></table></figure></div>

<p><strong>示例：</strong></p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">text-decoration</span>: underline <span class="number">#ff7d31</span> solid <span class="number">3px</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h2><p>使一个元素浮动在容器的某个位置，行内元素可以环绕它。</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">float</span>: left/right/none/inline-start/inline-end;</span><br></pre></td></tr></table></figure></div>

<h2 id="Clear"><a href="#Clear" class="headerlink" title="Clear"></a>Clear</h2><p>可用于清除浮动。</p>
<h2 id="Overflow"><a href="#Overflow" class="headerlink" title="Overflow"></a>Overflow</h2><p>处理溢出的元素。</p>
<ul>
<li><code>visible</code>：内容不被裁剪。</li>
<li><code>hidden</code>： 裁剪使其适应溢出，不支持滚动。</li>
<li><code>clip</code>：裁剪，代码层面不支持滚动。<ul>
<li><code>overflow-clip-margin</code>：裁剪范围。</li>
</ul>
</li>
<li><code>scroll</code>：总显示滚动条</li>
<li><code>auto</code>：若不溢出则不显示滚动条，否则显示。</li>
</ul>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><blockquote>
<p>改变你的网页背景</p>
</blockquote>
<p>可以通过 <code>background</code> 同时添加多个属性值，也可拆分来写。</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>();</span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">rgb</span>();</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line"><span class="attribute">background-position</span>: center;</span><br><span class="line"><span class="attribute">background-attachment</span>: fixed;</span><br><span class="line"><span class="attribute">background-size</span>: cover;</span><br></pre></td></tr></table></figure></div>

<br>

<p><code>background-repeat</code></p>
<ul>
<li><code>repeat-x/repeat-y</code>：可以控制横向还是纵向重复，也可以使用双值分别为不同的重复样式。</li>
<li><code>repeat</code>：重复填充背景，溢出部分将裁剪。</li>
<li><code>space</code>：不会裁剪，第一个和最后一个图像会贴合边缘，使空白均匀。</li>
<li><code>round</code>：通过拉伸图像使得重复填充</li>
<li><code>no-repeat</code>：不重复。</li>
</ul>
<br>

<p><code>background-position</code></p>
<p>关键字：<code>center/top/left/bottom/right</code></p>
<p>指定为对应边界中间位置。</p>
<p>也可以采用两个值分别对应 <code>x/y</code> 坐标。</p>
<br>

<p><code>background-size</code></p>
<ul>
<li><code>length</code>：可以是一个值也可以是两个值。</li>
<li><code>percentage</code>：可以设置相对于内容和内边距的百分比。</li>
<li><code>auto</code>：自动缩放。</li>
<li><code>cover</code>：使背景覆盖。</li>
<li><code>contain</code>：使包含背景。</li>
</ul>
<h2 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h2><p>设置元素的外部显示类型。</p>
<ul>
<li><code>block</code>：块级元素。</li>
<li><code>inline</code>：内联元素，无法应用宽度&#x2F;高度属性。</li>
<li><code>inline-block</code>：内联元素，但可以应用宽度&#x2F;高度属性。</li>
<li><code>none</code>：清除该元素。</li>
<li><code>contents</code>：只显示子代元素，不显示本身。</li>
<li><code>flex</code>：弹性盒模型。</li>
<li><code>grid</code>：网格模型。</li>
</ul>
<p>此处与 <code>visibility: hidden</code> 区分，后者只会使元素不可见，但依旧占据空间。</p>
<h2 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h2><p>CSS <strong><code>position</code></strong> 属性用于指定一个元素在文档中的定位方式。<code>top</code>，<code>right</code>，<code>bottom</code> 和 <code>left</code> 属性则决定了该元素的最终位置。</p>
<p>而上面那四个位置属性可以简写为 <code>inset</code>，四个参数分别代表 <code>top</code>，<code>right</code>，<code>bottom</code>，<code>left</code>。</p>
<p>而 <code>absolute</code> 元素没有设置大小，如果四个位置都有属性，那么就会相对最近非 <code>static</code> 祖先设置大小。</p>
<ul>
<li><code>static</code>：指定元素为默认布局，无法通过其它元素改变位置。</li>
<li><code>relative</code>：相对于默认布局的位置偏移。</li>
<li><code>absolute</code>：不会为该元素预留空间，相对于最近的非 <code>static</code> 祖先的位置。</li>
<li><code>fixed</code>：不会为该元素预留空间，相对于屏幕视口的位置。</li>
<li><code>sticky</code>：到达特定位置为 <code>fixed</code> 否则为 <code>relative</code>。比如设置 <code>top: 50px</code>，当该元素到达距离视口上端 <code>50px</code> 后，相对视口不动，直到 <code>containing block</code> 脱离视口。</li>
</ul>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line">linear-gradient(<span class="selector-attr">[angle|to &lt;side-or corner]</span>, &lt;<span class="attribute">color</span>-<span class="selector-tag">stop</span>-list&gt;)</span><br></pre></td></tr></table></figure></div>

<p>第一个参数可以是 <code>angle</code>，即 <code>[number]deg</code>，顺时针为正值，或者 <code>to</code> 加方向，如 <code>top</code>、<code>right</code> 等，代表渐变的方向。</p>
<p>而 <code>color-stop</code> 可以有多个，可以只有色值，也可以色值+长度或者百分比，代表该颜色渐变的范围&#x2F;长度，可以是单值也可以是双值，单值代表从什么地方开始，双值代表从什么地方开始和结束，前一个颜色比后一个颜色优先级更高，即不存在后对前覆盖。</p>
<p><strong>示例：</strong></p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">217deg</span>, <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">8</span>), <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>) <span class="number">70.71%</span>),</span><br><span class="line">            <span class="built_in">linear-gradient</span>(<span class="number">127deg</span>, <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>,.<span class="number">8</span>), <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>) <span class="number">70.71%</span>),</span><br><span class="line">            <span class="built_in">linear-gradient</span>(<span class="number">336deg</span>, <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>,.<span class="number">8</span>), <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>) <span class="number">70.71%</span>);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202405272257567.webp"
                      alt="image.png"
                ></p>
<h2 id="Z-index"><a href="#Z-index" class="headerlink" title="Z-index"></a>Z-index</h2><p><code>z-index</code> 属性用于控制元素在 Z 轴（即垂直于屏幕的轴）上的叠放顺序。当元素重叠时，<code>z-index</code> 值较大的元素会覆盖 <code>z-index</code> 值较小的元素。</p>
<p>类似于图层的概念。</p>
<h2 id="Pseudo"><a href="#Pseudo" class="headerlink" title="Pseudo"></a>Pseudo</h2><blockquote>
<p>伪类和伪元素。</p>
</blockquote>
<h3 id="Pseudo-classes"><a href="#Pseudo-classes" class="headerlink" title="Pseudo-classes"></a>Pseudo-classes</h3><ul>
<li><code>:hover</code>：鼠标悬浮</li>
<li><code>:active</code>：点击时</li>
<li><code>:visited</code>：点击后</li>
<li><code>:not()</code>：某行为的反行为</li>
</ul>
<h3 id="Pseudo-elements"><a href="#Pseudo-elements" class="headerlink" title="Pseudo-elements"></a>Pseudo-elements</h3><ul>
<li><code>::first-letter</code>：第一个字符</li>
<li><code>::first-line</code>：第一行</li>
<li><code>::selection</code>：所选择的文本</li>
<li><code>::before</code></li>
<li><code>::after</code></li>
<li><code>::marker</code></li>
</ul>
<h2 id="Text-align"><a href="#Text-align" class="headerlink" title="Text-align"></a>Text-align</h2><p>设置行内元素的水平对齐方式。</p>
<ul>
<li><code>start</code></li>
<li><code>end</code></li>
<li><code>left</code></li>
<li><code>right</code></li>
<li><code>center</code>：居中</li>
<li><code>justify</code>：向两侧对齐，对最后一行无效</li>
</ul>
<h2 id="Vertical-align"><a href="#Vertical-align" class="headerlink" title="Vertical-align"></a>Vertical-align</h2><p>设置行内元素的垂直对齐方式。</p>
<ul>
<li><code>baseline</code></li>
<li><code>top</code></li>
<li><code>middle</code></li>
<li><code>bottom</code></li>
<li><code>sub</code>：下标</li>
<li><code>super</code>：上标</li>
<li><code>text-top</code>：父元素的字体顶端</li>
<li><code>text-bottom</code>：父元素的字体底端</li>
</ul>
<h2 id="ScrollBar"><a href="#ScrollBar" class="headerlink" title="ScrollBar"></a>ScrollBar</h2><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><p>各个操作间用<strong>空格</strong>隔开。</p>
<h3 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h3><p>位移。</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>([x-offset], [y-offset]);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>translate()</code></li>
<li><code>translateX()</code></li>
<li><code>translateY()</code></li>
</ul>
<h3 id="Rotate"><a href="#Rotate" class="headerlink" title="Rotate"></a>Rotate</h3><p>旋转。</p>
<p>默认为 <code>rotateZ</code></p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">90deg</span>);</span><br><span class="line"><span class="comment">/* 沿着 X 轴旋转 90° */</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>rotateX()</code>：上下翻</li>
<li><code>rotateY()</code>：左右翻</li>
<li><code>rotateZ()</code>：旋转</li>
</ul>
<h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><p>缩放。</p>
<ul>
<li><code>scale()</code></li>
<li><code>scaleX()</code></li>
<li><code>scaleY()</code></li>
</ul>
<h3 id="Skew"><a href="#Skew" class="headerlink" title="Skew"></a>Skew</h3><p>倾斜（扭曲）。</p>
<ul>
<li><code>skewX()</code></li>
<li><code>skewY()</code></li>
<li><code>skew()</code></li>
</ul>
<h2 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h2><p>过渡效果。</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition</span>: [property] [duration] [timing-function] [delay];</span><br></pre></td></tr></table></figure></div>

<p><strong><code>property</code></strong></p>
<p>可省略，将应用到所有可过渡的属性上。</p>
<ul>
<li><code>width</code></li>
<li><code>height</code></li>
<li><code>transform</code></li>
<li><code>color</code></li>
</ul>
<p><strong><code>timing-function</code></strong></p>
<ul>
<li><code>ease</code></li>
<li><code>linear</code></li>
<li><code>ease-in</code></li>
<li><code>ease-out</code></li>
<li><code>cubic-bezier()</code></li>
</ul>
<h2 id="Gap"><a href="#Gap" class="headerlink" title="Gap"></a>Gap</h2><p>控制 <strong>flex</strong> 和 <strong>grid</strong> 布局中元素的间距。</p>
<p>当只有一个值时，同时应用于行间距和列间距。</p>
<p>当有两个值时，第一个值用于行间距，第二个值用于列间距。</p>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p><strong><code>hue-rotate(deg)</code></strong></p>
<p>色相扭曲函数。</p>
<p><strong><code>blur(px)</code></strong></p>
<p>高斯模糊。</p>
<p><strong><code>brightness(%)</code></strong></p>
<p>亮度。</p>
<p><strong><code>contrast(%)</code></strong></p>
<p>对比度。</p>
<p><strong><code>grayscale(%)</code></strong></p>
<p>灰度。</p>
<p><strong><code>invert(%)</code></strong></p>
<p>反转颜色。</p>
<p><strong><code>opacity(%)</code></strong></p>
<p>透明度。</p>
<p><strong><code>saturate(%)</code></strong></p>
<p>饱和度。</p>
<h2 id="Backdrop-filter"><a href="#Backdrop-filter" class="headerlink" title="Backdrop-filter"></a>Backdrop-filter</h2><p>与 <code>filter</code> 类似，但只影响它后面的背景，不影响本身元素。</p>
<h2 id="Pointer-events"><a href="#Pointer-events" class="headerlink" title="Pointer-events"></a>Pointer-events</h2><p><code>pointer-events</code> 属性用于控制元素如何响应鼠标事件。</p>
<ul>
<li><code>none</code></li>
<li><code>auto</code></li>
</ul>
<h2 id="Cursor"><a href="#Cursor" class="headerlink" title="Cursor"></a>Cursor</h2><p><code>cursor</code> 属性用于指定当鼠标悬停在元素上时应显示的光标样式。通过设置不同的光标样式，可以为用户提供视觉反馈，表示不同的交互状态。</p>
<ul>
<li><code>default</code>：默认光标（通常是箭头）。</li>
<li><code>pointer</code>：手形光标，通常用于表示链接。</li>
<li><code>text</code>：文本输入光标，通常用于可编辑的文本区域。</li>
<li><code>move</code>：移动光标，表示元素可以被拖动。</li>
<li><code>not-allowed</code>：表示某个操作被禁止的光标。</li>
<li><code>crosshair</code>：十字光标。</li>
<li><code>help</code>：帮助光标，通常用于表示有更多信息可用。</li>
<li><code>wait</code>：等待光标，表示操作正在进行中。</li>
<li>自定义光标：可以使用 URL 指定一个自定义光标图像。</li>
</ul>
<h2 id="List-style"><a href="#List-style" class="headerlink" title="List-style"></a>List-style</h2><p><code>list-style</code> 属性是一个简写属性，用于同时设置列表项标记的类型、位置和图像。</p>
<p><code>list-style-type</code></p>
<ul>
<li><code>none</code>：无标记。</li>
<li><code>disc</code>：实心圆（默认值）。</li>
<li><code>circle</code>：空心圆。</li>
<li><code>square</code>：实心方块。</li>
<li><code>decimal</code>：数字（1, 2, 3, …）。</li>
<li><code>decimal-leading-zero</code>：前导零数字（01, 02, 03, …）。</li>
<li><code>lower-roman</code>：小写罗马数字（i, ii, iii, …）。</li>
<li><code>upper-roman</code>：大写罗马数字（I, II, III, …）。</li>
<li><code>lower-alpha</code>：小写字母（a, b, c, …）。</li>
<li><code>upper-alpha</code>：大写字母（A, B, C, …）。</li>
</ul>
<h2 id="Pagination"><a href="#Pagination" class="headerlink" title="Pagination"></a>Pagination</h2><div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../css/index07.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Pagination<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor, sit amet consectetur adipisicing elit. Dolores pariatur repellat illum, reprehenderit quidem ab expedita, dicta debitis animi velit laborum molestias. Qui assumenda porro praesentium. Corporis molestiae necessitatibus incidunt.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;fruit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;apple&quot;</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;orange&quot;</span>&gt;</span>orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;banana&quot;</span>&gt;</span>banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is page #1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet consectetur adipisicing elit. Blanditiis voluptatum nesciunt, facilis commodi id fuga iusto. Delectus, quis labore assumenda enim, aspernatur eaque accusantium eum ullam, recusandae quaerat vel veniam?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pagination&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 向左向右只能手动为每一页填写它对应的上一页和下一页 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="symbol">&amp;lt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index07.html&quot;</span> <span class="attr">class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index00.html&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index01.html&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index02.html&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index03.html&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index04.html&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index05.html&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index06.html&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::first-letter</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">233</span>, <span class="number">233</span>, <span class="number">106</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::selection</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">background-color</span>: grey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* #fruit li::before &#123;</span></span><br><span class="line"><span class="comment">  content: &quot;✅&quot;;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="selector-id">#apple</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;🍎&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#orange</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;🍊&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#banana</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;🍌&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#fruit</span> <span class="selector-tag">li</span><span class="selector-pseudo">::marker</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;√&quot;</span>;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pagination</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pagination</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pagination</span> <span class="selector-tag">a</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">124</span>, <span class="number">255</span>, <span class="number">124</span>);</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pagination</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.active</span>) &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0.561</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Dropdown"><a href="#Dropdown" class="headerlink" title="Dropdown"></a>Dropdown</h2><div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Dropdown<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../css/index08.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dropdown&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Food<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet consectetur adipisicing elit. A corrupti sed consequatur. Eius consectetur sunt error, aliquid nihil ipsum a ut explicabo placeat perspiciatis quisquam in maxime eaque, quos facilis?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.dropdown</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.dropdown</span> <span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">hsl</span>(<span class="number">0</span>, <span class="number">0%</span>, <span class="number">80%</span>);</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.dropdown</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.dropdown</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">hsl</span>(<span class="number">0</span>, <span class="number">0%</span>, <span class="number">95%</span>);</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">5px</span> <span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">0%</span>, <span class="number">0%</span>, <span class="number">0.77</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.dropdown</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.dropdown</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0.487</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.dropdown</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">172</span>, <span class="number">255</span>, <span class="number">47</span>, <span class="number">0.598</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h2><div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Navigation<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../css/index09.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Falling Sakura<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;navbar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Products<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>This is the Home page<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Doloribus aliquid at provident ad, quidem consequuntur expedita a necessitatibus. Dolor aut praesentium laudantium voluptate laborum delectus illum, perferendis tempore ut? Repellendus!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>: none;</span><br><span class="line">  <span class="comment">/* 去除圆点 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">0%</span>, <span class="number">50%</span>, <span class="number">0.356</span>);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">0%</span>, <span class="number">50%</span>, <span class="number">0.556</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">80</span>, <span class="number">243</span>, <span class="number">80</span>, <span class="number">0.428</span>);</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h1><h2 id="普通文档流"><a href="#普通文档流" class="headerlink" title="普通文档流"></a>普通文档流</h2><p>所有元素按照先后位置从上到下布局。</p>
<p>行内元素占满一行后换行，块级元素被渲染为一个单独的行。</p>
<p>这是所有元素的默认定位。</p>
<h2 id="语义标签"><a href="#语义标签" class="headerlink" title="语义标签"></a>语义标签</h2><ul>
<li><code>header</code></li>
<li><code>nav</code></li>
<li><code>main</code><ul>
<li><code>section</code></li>
<li><code>aside</code></li>
<li><code>artible</code></li>
</ul>
</li>
<li><code>footer</code></li>
</ul>
<h2 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h2><blockquote>
<p>弹性盒模型。</p>
</blockquote>
<ul>
<li><code>flex-direction</code>：<ul>
<li>将会改变主轴和交叉轴的方向，默认 <code>row</code> 是水平方向上是主轴，竖直方向上是交叉轴。</li>
<li><code>row/row-reverse/column/column-reverse</code></li>
</ul>
</li>
<li><code>flex-wrap</code>：<ul>
<li><code>no-wrap</code>：所有子元素显示在一行。</li>
<li><code>wrap</code>：自动换行排列。</li>
<li><code>wrap-reverse</code></li>
</ul>
</li>
<li><code>justify-content</code>：<ul>
<li><code>flex-start</code>：左对齐。</li>
<li><code>flex-end</code>：右对齐。</li>
<li><code>center</code>：沿主轴居中。</li>
<li><code>space-between</code>：间隙平分。</li>
<li><code>space-around</code>：每个子元素周围都有相同的间隙，即子元素之间的间隙为子元素到边框的间隙的二倍。</li>
<li><code>space-evenly</code>：子元素之间和边框到子元素之间的间隙相同。</li>
</ul>
</li>
<li><code>align-items</code>：<ul>
<li><code>flex-start</code>：上对齐。</li>
<li><code>flex-end</code>：下对齐。</li>
<li><code>center</code>：沿交叉轴居中。</li>
<li><code>stretch</code>：若元素未设置高度，将占满高度。</li>
<li><code>baseline</code>：基于元素的第一行文字的基线对齐。</li>
</ul>
</li>
<li><code>align-self</code>：控制单独子元素的对齐方式。</li>
<li><code>flex</code><ul>
<li><code>flex-grow</code>：元素的放大比例，默认为 0</li>
<li><code>flex-shrink</code>：元素的缩小比例，默认为 1</li>
<li><code>flex-basis</code>：元素在主轴方向的初始大小。</li>
</ul>
</li>
</ul>
<p>为什么没有 <code>justify-items</code> 属性，什么时候可以使用 <code>align-content</code> ？</p>
<p>因为 flex 布局在主轴方向上就是一个块啊，它在主轴方向上没有多个 <code>item</code> 所以它其实就是沿着交叉轴方向的一个一维的直线（默认 <code>flex-wrap</code> 属性值为 <code>nowrap</code>，那它实际上就是一个点，只有当它有多行内容时 <code>align-content</code> 才有意义。</p>
<p><code>align-content</code> 和 <code>justify-content</code> 是控制<strong>多行</strong>内容的对齐方式。</p>
<p>注意，当你将 <code>flex-wrap</code> 设置为 <code>wrap</code> 后，即使容器内的元素不足以换行，但还是会被识别为“多行内容”，此时 <code>align-content</code> 会生效。</p>
<p><code>align-items</code> 和 <code>justify-items</code> 是控制<strong>单行</strong>内容的对齐方式。</p>
<h2 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h2><p>网格布局。</p>
<ul>
<li><code>grid-template-rows</code>：行轨道的尺寸。</li>
<li><code>grid-template-columns</code>：列分别的宽度，可以是固定的宽度，也可以用 <code>fr</code> 表示浮动宽度（特有单位），可以使用重复函数节省编码时间：<code>repeat(3, 1fr)</code> 。</li>
<li><code>column-gap</code>：列间距。</li>
<li><code>row-gap</code>：行间距。</li>
<li><code>gap</code>：间距。</li>
<li><code>grid-template-areas</code>：排列元素。<ul>
<li>示例：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202406182023359.webp"
                      alt="image.png"
                ></li>
<li>然后给子元素分别设置 <code>grid-area</code> 为 <code>header</code>&#x2F;<code>content</code>&#x2F;<code>sidebar</code>&#x2F;<code>footer</code> 即可。</li>
</ul>
</li>
<li><code>align-items</code>：交叉轴方向上对齐。</li>
<li><code>justify-items</code>：主轴方向上对齐。</li>
</ul>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><blockquote>
<p>Block Format Context<br>块格式化上下文</p>
</blockquote>
<p>可以看作是元素的一个属性，当它拥有这个属性时，可以看作是独立的一个容器，容器里的元素不会影响到外面的元素，它计算高度时会把浮动元素的高度也计算进来，且浮动元素与 BFC 元素区域不会叠加。</p>
<p>如何开启？</p>
<ol>
<li>根元素 <code>&lt;html&gt;</code></li>
<li>浮动元素（<code>float</code> 不为 <code>none</code>）</li>
<li>绝对定位元素（<code>position</code> 为 <code>absolute</code> 或 <code>fixed</code>）</li>
<li><code>display</code> 值为 <code>inline-block</code>, <code>table-cell</code>, <code>table-caption</code>, <code>table</code>, <code>table-row</code>, <code>table-row-group</code>, <code>table-header-group</code>, <code>table-footer-group</code>, <code>inline-table</code>, <code>flow-root</code>, <code>flex</code>, <code>inline-flex</code>, <code>grid</code>, <code>inline-grid</code>, <code>inline-block</code></li>
<li><code>overflow</code> 值不为 <code>visible</code> 的块元素</li>
<li><code>contain</code> 值为 <code>layout</code>, <code>content</code>, <code>paint</code> 的元素</li>
<li>多列容器</li>
</ol>
<p>可以避免间距重叠，清除浮动带来的父元素高度塌陷（父元素是由子元素所撑开的，当子元素浮动后脱离文档流父元素便没有高度），避免浮动覆盖。</p>
<h1 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h1><blockquote>
<p>keyframes<br>关键帧动画</p>
</blockquote>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> [name] &#123;</span><br><span class="line">	<span class="selector-attr">[percentage]</span> &#123;</span><br><span class="line">		<span class="selector-attr">[animation]</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>from</code> 与 <code>0%</code> 等价，<code>to</code> 与 <code>100%</code> 等价。</p>
<p>代表关键帧动画中的一个节点。</p>
<p>然后进行一些操作就可以了。</p>
<p>给元素应用动画：</p>
<ul>
<li><code>animation-name</code>：名字</li>
<li><code>animation-duration</code>：持续时间</li>
<li><code>animation-iteration-count</code>：迭代次数</li>
<li><code>animation-direction</code>：动画时间方向<ul>
<li><code>normal</code></li>
<li><code>reverse</code></li>
<li><code>alternate</code></li>
<li><code>alternate-reverse</code></li>
</ul>
</li>
<li><code>animation-play-state</code>：播放状态<ul>
<li><code>paused</code></li>
<li><code>running</code></li>
</ul>
</li>
<li><code>animation-timing-function</code>：时间函数曲线可以通过 <code>F12</code> 调节对应曲线得到相应参数<ul>
<li><code>ease-in-out</code>(default)</li>
<li><code>linear</code></li>
<li><code>steps([number])</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter Note</title>
    <url>/7b1ef955.html</url>
    <content><![CDATA[<p><a href="https://flutter.dev/"><code>Flutter</code></a> 是基于 <a href="https://dart.dev/"><code>dart</code></a> 的一个跨平台框架。</p>
<p><code>dart</code> 是与 <code>C#</code> 相似的面向对象编程语言。</p>
<p>Core concept is: Widget inside Widget.</p>
<p>对象嵌套对象。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>有以下类型的变量：</p>
<ul>
<li><code>var</code>：带有强类型推断</li>
<li><code>int</code></li>
<li><code>String</code></li>
<li><code>List</code></li>
<li><code>Map</code></li>
<li><code>double</code></li>
</ul>
<p>有以下关键字：</p>
<ul>
<li><code>const</code>：编译时常量</li>
<li><code>final</code>：运行时常量</li>
</ul>
<hr>
<p>需要有一个 <code>main()</code> 函数，这点与 <code>c++</code> 类似。</p>
<hr>
<p>可以通过 <code>@override</code> 关键字覆写方法。</p>
<p>匿名函数实现：</p>
<div class="code-container" data-rel="Dart"><figure class="iseeu highlight dart"><table><tr><td class="code"><pre><span class="line">() &#123;</span><br><span class="line">	<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// equal to</span></span><br><span class="line"></span><br><span class="line">() =&gt; <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure></div>

<p>不同的是，箭头函数只可以有一行。</p>
<p>访问颜色需要通过 <code>Colors</code> 对象。</p>
<p>访问图标需要通过 <code>Icons</code> 对象。</p>
<p>访问图像时：</p>
<ul>
<li>如果是网页图片，使用 <code>Image.network(url)</code></li>
<li>如果是本地图片，需要先在 <code>pubspec.yml</code> 中添加 assets 路径，然后使用 <code>Image.asset(path)</code></li>
</ul>
<p>有以下几大主要组件：</p>
<ul>
<li><code>Row</code></li>
<li><code>Column</code></li>
</ul>
<p>这两者对应 <code>flex</code> 方向为行和列的容器，也有主轴和交叉轴的概念。</p>
<p>默认主轴方向无限长，此时如果有子元素的宽度&#x2F;高度和主轴一样是 <code>double.infinity</code> 会报错。</p>
<p>交叉轴方向大小由父元素决定。</p>
<ul>
<li><code>Center</code></li>
</ul>
<p>居中元素。</p>
<ul>
<li><code>Container</code></li>
</ul>
<p>等价于 <code>&lt;div&gt;</code> 标签，可以设置颜色大小，margin、padding和各种装饰。</p>
<ul>
<li><code>SizedBox</code></li>
</ul>
<p>仅仅能设置大小的一个盒子，用于优化性能。</p>
<ul>
<li><code>Padding</code></li>
</ul>
<p>仅仅能设置 padding 的一个盒子，用于优化性能。</p>
<ul>
<li><code>Text</code></li>
<li><code>ListTile</code><ul>
<li><code>leading</code></li>
<li><code>title</code></li>
<li><code>titleColor</code></li>
<li><code>trailing</code></li>
<li><code>title</code></li>
<li><code>onTap</code></li>
</ul>
</li>
</ul>
<p>一个占据整行的盒子，可以设置各种样式和点击事件。</p>
]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Embedding FlowFerry into your Obsidian workflow</title>
    <url>/49904686.html</url>
    <content><![CDATA[<p>前段时间，经朋友推荐，我入手了一款 App：<strong>FlowFerry</strong>，经过一段时间的使用之后，我发现它可以很好地嵌入到我的 Obsidian 工作流中。</p>
<p>我的原始工作流充斥着重复劳动：复制内容，在 Obsidian 新建文档、粘贴、排版，最后才是整合。那么有没有什么办法把其中一部分步骤拆分出来,利用碎片化的时间进行处理呢？</p>
<p>FlowFerry 给出了答案。它拥有跨平台的生态，当我出门在外使用手机浏览，遇到了一篇很打动我的文章时，我就可以使用 FlowFerry 将这篇文章暂存本地，等待处理，完成信息获取。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202502151906647.png"
                      alt="image.png|400"
                ></p>
<p>就这吗？FlowFerry 可不止于此。</p>
<p>很多软件都有「收藏」的功能，但不同信息来源的文章缺少一个统一的「收藏夹」，这经常导致印象里上次看到的很好的文章却想不起来放在了哪个收藏夹里——它们总是被遗忘。</p>
<p>当你使用 FlowFerry 后，无论在哪里看到的一篇好文章，随时都可以将其内容抓取到本地并打上标签，建立一个专属于你的本地文章精选集。它支持<strong>本地离线阅读</strong>，在一些没有网络的环境中，我也可以随时打开它阅读文章。</p>
<p>当我再次坐到电脑面前时，通过 FlowFerry 的多端同步，我便可以直接将文章发送至 Obsidian 仓库，进行下一步的分类、整合，这些切切实实地提高了我处理信息的效率。</p>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>obsidian</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/4a17b156.html</url>
    <content><![CDATA[<h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><h3 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h3><h4 id="H4"><a href="#H4" class="headerlink" title="H4"></a>H4</h4><h5 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h5><h6 id="H6"><a href="#H6" class="headerlink" title="H6"></a>H6</h6><p><strong>Bold</strong></p>
<p><em>Italic</em></p>
<p><del>remove</del></p>
<p>text</p>
<p><code>code inline</code></p>
<pre class="mermaid">pie
title P
"1" : 10
"2" : 10
"3" : 50
"4" : 30</pre>


  <div class="note-large 信息">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>Note</p>

    </div>
    <div class="notel-content markdown-body">
      <p>换行测试<br>换行测试<br>换行测试</p>

    </div>
  </div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nx = t.x + dx[i];</span><br><span class="line">            <span class="type">int</span> ny = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dist[nx][ny] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dist[nx][ny] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">    <span class="built_in">BFS</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dist[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>$$<br>\begin{aligned}<br>a + b &amp; &#x3D; 2 \<br>&amp; &#x3D; 1 \<br>&amp; &#x3D; a - b \<br>\end{aligned}<br>$$</p>
<p>$a + b &#x3D; 1$</p>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>信息</p>

    </div>
    <div class="notel-content markdown-body">
      <p>换行测试<br>换行测试<br>换行测试</p>

    </div>
  </div>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>换行测试<br>换行测试<br>换行测试</p>

    </div>
  </div>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>自定义标题</p>

    </div>
    <div class="notel-content markdown-body">
      <p>换行测试<br>换行测试<br>换行测试</p>

    </div>
  </div>


  <div class="note p-4 mb-4 rounded-small markdown-body default">
    <p>默认 提示块标签</p>

  </div>

  <div class="note p-4 mb-4 rounded-small markdown-body default">
    <p>default 提示块标签</p>

  </div>

  <div class="note p-4 mb-4 rounded-small markdown-body primary">
    <p>primary 提示块标签</p>

  </div>

  <div class="note p-4 mb-4 rounded-small markdown-body success">
    <p>success 提示块标签</p>

  </div>

  <div class="note p-4 mb-4 rounded-small markdown-body info">
    <p>info 提示块标签</p>

  </div>

  <div class="note p-4 mb-4 rounded-small markdown-body warning">
    <p>warning 提示块标签</p>

  </div>

  <div class="note p-4 mb-4 rounded-small markdown-body danger">
    <p>danger 提示块标签</p>

  </div>

  <div class="note p-4 mb-4 rounded-small markdown-body red icon-padding">
    <i class="note-icon fa-solid fa-bolt"></i><p>自定义提示块标签</p>

  </div>

<details class="blue" data-header-exclude>
    <summary><i class="fa-solid fa-chevron-right"></i>Folding 测试： 点击查看更多 </summary>
    <div class='content markdown-body'>
      <p>啊啊啊啊啊</p>
  <div class="note p-4 mb-4 rounded-small markdown-body danger">
    <p>danger 提示块标签</p>

  </div>
 

  <div class="note p-4 mb-4 rounded-small markdown-body tip">
    <p>tip 提示块标签</p>

  </div>
 
    </div>
  </details>

<details class="red" data-header-exclude>
    <summary><i class="fa-solid fa-chevron-right"></i>title </summary>
    <div class='content markdown-body'>
      <p>Yes.</p>

    </div>
  </details>

<div class="tabs" id="tab-first-unique-name"><ul class="nav-tabs"><li class="tab active"><a class="#first-unique-name-1">First Tab</a></li><li class="tab"><a class="#first-unique-name-2">Second Tab</a></li><li class="tab"><a class="#first-unique-name-3">Third Tab</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-pane" id="first-unique-name-2"><p><strong>This is Tab 2.</strong></p>
<p>This is Tab 2.</p></div><div class="tab-pane" id="first-unique-name-3"><p><strong>This is Tab 3.</strong></p>
<p>This is Tab 3.</p>
<p>This is Tab 3.</p></div></div></div>

<p>不设置任何参数的 <a class="button " href='/' title='按钮'>按钮</a> 适合融入段落中。</p>
<p>regular 按钮适合独立于段落之外：</p>
<a class="button regular" href='https://www.ohevan.com' title='示例博客'><i class='fa-solid fa-play-circle'></i> 示例博客</a>
<a class="button regular" href='https://www.ohevan.com' title='示例博客'><i class='fa-solid fa-play-circle'></i> 示例博客</a>
<p>large 按钮更具有强调作用，建议搭配 center 使用：</p>
<a class="button center large" href='https://redefine-docs.ohevan.com' title='开始使用'><i class='fa-solid fa-download'></i> 开始使用</a>

]]></content>
      <categories>
        <category>world</category>
      </categories>
      <tags>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGPT：开启个人成长的新纪元</title>
    <url>/5a99080f.html</url>
    <content><![CDATA[
  <div class="note p-4 mb-4 rounded-small markdown-body pink icon-padding">
    <i class="note-icon fa-solid fa-lightbulb"></i><p>本文标题及封面均使用 ChatGPT 生成。</p>

  </div>

<h1 id="ChatGPT-与个人能力"><a href="#ChatGPT-与个人能力" class="headerlink" title="ChatGPT 与个人能力"></a>ChatGPT 与个人能力</h1><blockquote>
<p>视频原地址：<a class="link"   href="https://www.bilibili.com/video/BV1th4y137yh/" >ChatGPT 是少数强者的【外挂】｜ChatGPT使用教程_哔哩哔哩_bilibili<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h2 id="快速学习"><a href="#快速学习" class="headerlink" title="快速学习"></a>快速学习</h2><blockquote>
<p>你想做的事情，99.99% 别人都做过，而且做的比你好，你只需要搜到它，然后改良它。</p>
</blockquote>
<p>SECI 模型，即显性知识和隐形知识之间的相互转化。</p>
<p>社会化、外在化、联结化、内在化。</p>
<p>这里写一条我自己的感悟：只有显性知识才是能作为笔记的，隐形知识需要你上手去做。</p>
<p><strong>搜索力</strong></p>
<p>常用为 Bilibili，Google，Youtube，ChatGPT，sci-hub.</p>
<p>并且 ChatGPT 可以把一个知识以 SECI 的三个阶段和学习力的三个层次有针对性地展开为你讲解，这是一般搜索引擎做不到的。</p>
<p>强者的<strong>五大核心竞争力</strong>（使用工具的能力）。</p>
<ul>
<li>快速学习的能力（三个层次：有人手把手教，自己从书上学，探索未知）</li>
<li>提问能力（高质量问题）</li>
<li>批判性思考（苏格拉底提问）</li>
<li>结构化思考（构建模型）</li>
<li>创新（延续性创新）</li>
</ul>
<p>而想使用好 ChatGPT 这个工具，最需要的就是提问能力。</p>
<h2 id="提问能力"><a href="#提问能力" class="headerlink" title="提问能力"></a>提问能力</h2><blockquote>
<p>最重要、最艰难的工作，从来不是找到对的答案，而是问出正确的问题。——彼得</p>
</blockquote>
<p><strong>我不擅长提问。</strong></p>
<p>这里有一个<strong>布鲁姆教育目标分类模型</strong>，可以基于此进行提问。</p>
<p>利用 Chat GPT 训练你的提问能力。</p>
<p>你也可以向它提问如何更好地利用它，如何向它提问。</p>
<p>你的问题质量越高、描述的越清楚、越详细，你得到的它的答案也就越详细越准确，越能得到你想要的信息。</p>
<p>问题之间可以组合，但数量不宜过多。（因为它有字数限制）</p>
<h2 id="批判性思考"><a href="#批判性思考" class="headerlink" title="批判性思考"></a>批判性思考</h2><blockquote>
<p><strong>批判性思考本质上是思考观点背后的思考过程</strong></p>
</blockquote>
<p>任何<em>观点</em>，都是针对某个<em>论题</em>，基于特定的<em>概念</em>、<em>证据事实</em>和<em>假设</em>，站在特定的<em>立场</em>，进行<em>推理和解释</em>，从而支持某个<em>结论</em>。</p>
<p>包括观点、论题、证据事实、结论、推理理解的过程、假设、概念、立场。</p>
<p>可以问它观点的各个论证部分，也可以让它针对各个论证部分进行批判。</p>
<p>最简单的批判方式就是批判概念。</p>
<ul>
<li><strong>苏格拉底提问方法</strong></li>
<li><strong>基于结构化分析问题&#x2F;创新的目的，让它为你提供一些批判句式</strong></li>
<li><strong>结合论证谬误提问</strong></li>
</ul>
<p>这些就不详细展开了（可以问 GPT）。</p>
<h2 id="结构化思考"><a href="#结构化思考" class="headerlink" title="结构化思考"></a>结构化思考</h2><p>学会 MECE 的分类方法（相互独立且完全穷尽）。</p>
<p>把隐性的知识显性化。</p>
<p>让⌈它⌋给你推荐不同结构的模型，并且教给你这些模型具体该怎么使用，有哪些局限，具体的例子有哪些，分析这个模型的应用场景和它的结构，并根据你的需求推荐相应的模型。</p>
<h2 id="创新"><a href="#创新" class="headerlink" title="创新"></a>创新</h2><p><em>颠覆性创新&#x2F;延续性创新</em></p>
<p>需要了解创新者的五个工具。</p>
<p>对于一个问题，你可以让 ChatGPT 基于一个特定的思考结构进行发散。</p>
<p>比如：让它扮演不同角色的人，站在不同的立场对一个问题进行讨论。</p>
<p>比如：基于某种背景，让它预测未来的发展趋势。</p>
<p>比如：给它一些需求，问它有没有好的解决办法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>快速学习显性知识，通过提出高质量问题内化成自己批判性思考的能力、结构化思考能力，最终实现创新。</p>
<h1 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h1><p>以下是⌈它们⌋针对我“请介绍一下你自己的功能以及我该如何使用。”的问题作出的回答。</p>
<h2 id="WebPilot"><a href="#WebPilot" class="headerlink" title="WebPilot"></a>WebPilot</h2><p>你好，WebPilot 是一个强大的 ChatGPT 插件，专为增强您的在线浏览体验而设计。以下是 WebPilot 插件的详细功能以及使用方法：</p>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><ol>
<li><p><strong>网页内容总结</strong></p>
<ul>
<li>输入一个网页 URL，WebPilot 将提取网页内容并返回简明扼要的总结，帮助您快速了解网页的主要内容。</li>
</ul>
</li>
<li><p><strong>视频内容总结</strong></p>
<ul>
<li>输入一个 YouTube 视频的 URL，WebPilot 将分析视频内容并提供详细的总结，确保您无需观看完整视频即可掌握核心信息。</li>
</ul>
</li>
<li><p><strong>信息搜索和翻译</strong></p>
<ul>
<li>输入您的查询，WebPilot 将使用您设定的语言进行搜索，并返回相关信息。支持将查询转换为不同语言并提供多种资源链接。</li>
</ul>
</li>
</ol>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li><p><strong>网页内容总结</strong></p>
<ul>
<li>直接输入您要浏览的网页 URL。</li>
<li>WebPilot 将分析该网页，并以项目符号的形式呈现关键点，最后提供一个主要结论。</li>
</ul>
</li>
<li><p><strong>视频内容总结</strong></p>
<ul>
<li>直接输入 YouTube 视频的 URL。</li>
<li>WebPilot 将总结视频的主要内容，列出详细的要点，并提供一个关键结论。</li>
</ul>
</li>
<li><p><strong>信息搜索</strong></p>
<ul>
<li>提出您的查询问题，如“法国最好的餐厅在哪里？”。</li>
<li>WebPilot 将搜索相关信息并以设定语言返回结果，同时提供多个资源链接供参考。</li>
</ul>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li><p><strong>网页总结</strong></p>
<ul>
<li>输入：“<a class="link"   href="https://example.com”/" >https://example.com”<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>返回：该网页的关键点总结和主要结论。</li>
</ul>
</li>
<li><p><strong>视频总结</strong></p>
<ul>
<li>输入：“<a class="link"   href="https://www.youtube.com/watch?v=example%E2%80%9D" >https://www.youtube.com/watch?v=example”<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>返回：该视频的详细要点总结和主要结论。</li>
</ul>
</li>
<li><p><strong>信息搜索</strong></p>
<ul>
<li>输入：“巴黎最佳景点？”</li>
<li>返回：有关巴黎最佳景点的多种资源链接和总结信息。</li>
</ul>
</li>
</ul>
<h2 id="Code-Copilot"><a href="#Code-Copilot" class="headerlink" title="Code Copilot"></a>Code Copilot</h2><p>我是 Code Copilot，您的编程助手，旨在帮助您完成各种编程任务。以下是我的功能和使用指南：</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol>
<li><strong>代码编写</strong>：编写高效、可读、清晰且可维护的代码。</li>
<li><strong>代码调试</strong>：分析和修复代码中的错误。</li>
<li><strong>代码解释</strong>：逐步解释代码的工作原理。</li>
<li><strong>代码审查</strong>：检查代码的功能，确保其无错误，并提供改进建议。</li>
<li><strong>API 文档阅读</strong>：帮助解析和理解 API 文档。</li>
<li><strong>实时搜索</strong>：执行实时搜索以检索最新数据或信息。</li>
<li><strong>单元测试编写</strong>：编写单元测试以验证代码的功能。</li>
</ol>
<h3 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h3><ol>
<li><strong>指定语言</strong>：使用命令<code>/start(language?: string)</code>指定或输入您要使用的编程语言。</li>
<li><strong>代码编写与调试</strong>：<ul>
<li>粘贴您的代码、文档或描述具体的编码问题。</li>
<li>使用命令<code>/quick_fix(any: string)</code>进行快速修复。</li>
<li>使用命令<code>/fix(any: string)</code>进行详细的调试。</li>
</ul>
</li>
<li><strong>代码解释与审查</strong>：<ul>
<li>使用命令<code>/explain(any: string)</code>逐步解释代码。</li>
<li>使用命令<code>/review(any: string)</code>审查代码并提供改进建议。</li>
</ul>
</li>
<li><strong>API 文档阅读</strong>：提供 API 文档的链接，我将帮助解析和理解。<ul>
<li>使用命令<code>/read(urls: string[])</code>读取网页内容。</li>
</ul>
</li>
<li><strong>实时搜索</strong>：使用命令<code>/search(any: string)</code>执行实时搜索以检索最新信息。</li>
</ol>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol>
<li><strong>粘贴代码或文档</strong>：提供您当前的代码片段、文档或描述您遇到的问题。</li>
<li><strong>选择合适的命令</strong>：根据您的需求选择上述命令之一。</li>
<li><strong>获得帮助</strong>：查看我的响应，获取解决方案或进一步指导。</li>
</ol>
<h2 id="Code-Tutor"><a href="#Code-Tutor" class="headerlink" title="Code Tutor"></a>Code Tutor</h2><p>你好！我是一个名为Khanmigo Lite的AI学习助手，由Khan Academy与OpenAI合作开发，旨在帮助你学习编程和计算机科学。我可以帮助你理解编程概念，解决代码中的问题，以及指导你如何改进你的编程技能。</p>
<p>你可以这样使用我：</p>
<ol>
<li><strong>代码问题</strong>：如果你在编写代码时遇到了问题，可以把代码粘贴过来，告诉我你卡在哪个部分。我会帮助你找到问题并指导你如何解决。</li>
<li><strong>概念理解</strong>：如果你对某个编程概念不太理解，可以向我提问，我会帮助你理清思路。</li>
<li><strong>算法设计</strong>：如果你需要设计一个算法或解决一个特定的问题，可以告诉我你的想法，我会引导你一步步完成。</li>
</ol>
<p>为了更好地帮助你，请把你的代码或问题详细描述一下，并告诉我你目前遇到的困难。我会根据你的描述，提供指导和建议。你准备好开始了吗？可以先上传你的作业或代码，让我们看看你正在处理什么问题。</p>
<h2 id="Scholar-GPT"><a href="#Scholar-GPT" class="headerlink" title="Scholar GPT"></a>Scholar GPT</h2><p>你好！我是Scholar GPT，你的多功能研究助手。我可以帮助你进行数据分析、学术研究、数学问题求解以及在线信息检索。以下是我的一些主要功能和使用方法：</p>
<h3 id="1-数据分析与可视化"><a href="#1-数据分析与可视化" class="headerlink" title="1. 数据分析与可视化"></a>1. 数据分析与可视化</h3><p>我可以使用Python库（如Pandas、Matplotlib等）进行数据分析和可视化。如果你有数据集需要分析，可以将数据上传给我，我可以为你生成图表和统计报告。</p>
<h3 id="2-学术研究"><a href="#2-学术研究" class="headerlink" title="2. 学术研究"></a>2. 学术研究</h3><p>我可以搜索和获取学术论文和研究文章的信息。你可以提供具体的研究主题或关键词，我会为你找到相关的学术资源，并提供引用和链接。</p>
<h3 id="3-专利检索"><a href="#3-专利检索" class="headerlink" title="3. 专利检索"></a>3. 专利检索</h3><p>我可以帮助你检索专利信息。只需提供关键词和其他过滤条件（如国家、时间范围），我会找到相关的专利并提供详细信息。</p>
<h3 id="4-数学问题求解"><a href="#4-数学问题求解" class="headerlink" title="4. 数学问题求解"></a>4. 数学问题求解</h3><p>我可以解决复杂的数学问题，包括符号运算和数值计算。如果你有特定的数学问题，请描述问题的详细内容，我会为你提供解答步骤和结果。</p>
<h3 id="5-网页数据处理"><a href="#5-网页数据处理" class="headerlink" title="5. 网页数据处理"></a>5. 网页数据处理</h3><p>我可以从网页上提取和处理数据。如果你有特定的网址需要分析，可以提供链接，我会从中提取有用的信息。</p>
<h3 id="6-自然语言处理"><a href="#6-自然语言处理" class="headerlink" title="6. 自然语言处理"></a>6. 自然语言处理</h3><p>我可以进行文本分析和情感分析等自然语言处理任务。如果你有文本需要分析，例如情感倾向分析或关键词提取，可以将文本提供给我。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><ol>
<li><strong>数据分析</strong>：上传一个CSV文件，并告诉我你希望分析的内容。</li>
<li><strong>学术研究</strong>：告诉我你感兴趣的研究主题，例如“机器学习在医学中的应用”，我会为你找到相关的学术文章。</li>
<li><strong>专利检索</strong>：提供关键词和过滤条件，例如“人工智能专利在美国”，我会为你检索相关专利。</li>
<li><strong>数学问题</strong>：描述你的数学问题，例如“求解微分方程y’’ + y &#x3D; 0”，我会为你提供解答。</li>
</ol>
<h2 id="Write-For-Me"><a href="#Write-For-Me" class="headerlink" title="Write For Me"></a>Write For Me</h2><p>当然！我是一个专门为内容创作和优化设计的聊天机器人，具备以下功能：</p>
<ol>
<li><p><strong>理解用户需求</strong>：</p>
<ul>
<li>我会询问你的具体需求，包括使用目的、目标受众、语气、字数、风格和内容格式等，以确保我能提供最合适的内容。</li>
</ul>
</li>
<li><p><strong>创建内容大纲</strong>：</p>
<ul>
<li>根据你的要求，我首先会创建详细的大纲，将内容分成不同部分，并对每个部分进行总结，分配字数。</li>
</ul>
</li>
<li><p><strong>字数管理</strong>：</p>
<ul>
<li>我在写作过程中会时刻跟踪字数，确保符合你的要求，并在各部分之间进行平滑过渡。</li>
</ul>
</li>
<li><p><strong>创意扩展</strong>：</p>
<ul>
<li>我会使用各种策略来丰富内容，例如扩展讨论、加入要点和有趣的事实，同时保持内容的相关性和质量。</li>
</ul>
</li>
<li><p><strong>分段写作和交付</strong>：</p>
<ul>
<li>我会按部分逐步写作和交付内容，随时向你更新进度，并计划下一部分的内容。</li>
</ul>
</li>
<li><p><strong>内容质量</strong>：</p>
<ul>
<li>我会整合SEO策略，确保内容具有吸引力，适合目标受众和发布平台。</li>
</ul>
</li>
<li><p><strong>内容格式</strong>：</p>
<ul>
<li>默认格式为markdown，但我可以根据你的需求调整为任何格式。</li>
</ul>
</li>
<li><p><strong>延伸互动</strong>：</p>
<ul>
<li>对于复杂话题或长篇内容，我会提前告知需要多次回复，以确保整个内容的连贯性。</li>
</ul>
</li>
<li><p><strong>问题解决</strong>：</p>
<ul>
<li>我会以解决问题的心态来处理任务，旨在满足你的具体需求和挑战。</li>
</ul>
</li>
</ol>
<p>这些功能旨在为你提供高质量、定制化的内容创作服务。如果你有任何具体需求或问题，请随时告诉我！</p>
<h2 id="Translate-GPT"><a href="#Translate-GPT" class="headerlink" title="Translate GPT"></a>Translate GPT</h2><p>这个没什么好说的。</p>
<h2 id="Image-Generator"><a href="#Image-Generator" class="headerlink" title="Image Generator"></a>Image Generator</h2><p>这是用它生成的一张科幻风格的宇宙插画。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202405212116475.webp"
                      alt="DALL·E 2024-05-21 21.15.12 - A detailed sci-fi style illustration of the universe. The scene includes a vast expanse of space filled with colorful nebulae, distant galaxies, and b.webp"
                ></p>
<p>还是很不错的。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>我们通过各种插件，能够使用 ChatGPT 联网了解到最新的信息，为不同领域的人提供垂直信息，增强了信息的准确度和专业性，查找论文、文档，总结视频等等。</p>
<p>还有艺术创新类的工作，比如生成图片&#x2F;视频&#x2F;图标，这些都大大提高了我们的工作效率。</p>
<p>我初次对 GPT-4 进行较为深入的体验，之前一直用的是 Bing 的 3.5 模型，感觉也不过如此，但现在确实被 GPT-4 的强大功能所震撼到。它能够节省很多我们在查找筛选整合信息的时间，通过它能锻炼我们提问、思考、内化的能力，未来，会使用工具是一个必不可少的能力。</p>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>chatgpt</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Note</title>
    <url>/772e1c59.html</url>
    <content><![CDATA[<blockquote>
<p>东拼西凑的 <code>python</code> 初学之路。</p>
</blockquote>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>制表符：<code>\t</code></li>
<li>换行符：<code>\n</code></li>
<li>去除右边空白：<code>.rstrip()</code></li>
<li>去除左边空白：<code>.lstrip()</code></li>
<li>去除左右两边空白（包括换行符）：<code>.strip()</code></li>
<li>字符串内使用引号：<code>\&quot;</code></li>
<li>首字母大写：<code>.title()</code></li>
<li>全部大写：<code>.upper()</code></li>
<li>全部小写：<code>.lower()</code></li>
<li>构造字符串（花括号内为变量）：&#96;f”Hello,{variant}.”</li>
<li>去除前缀：<code>.removeprefix(&quot;string&quot;)</code></li>
<li>去除后缀：<code>.removesuffix(&quot;.txt&quot;)</code></li>
</ul>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><ul>
<li>乘法：<code>*</code></li>
<li>除法（返回浮点数）：<code>/</code></li>
<li>大数易读：<code>1_000_000_000</code></li>
<li>同时赋值：<code>x, y, z = 0, 2, 7</code></li>
<li>同时输出：<code>print(x, y, z)</code></li>
<li>幂次：<code>**</code></li>
<li>Python 之禅：<code>import this</code></li>
</ul>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>定义：方括号扩死，里面元素用逗号隔开。</p>
<p>下标和数组一样，从零开始。</p>
<p>负数下标表示倒数第几个。</p>
<ul>
<li>末尾插入元素：<code>.append()</code></li>
<li>对应位置插入元素：<code>.insert(1, &#39;fgh&#39;)</code></li>
<li>删除对应位置的元素：<code>del b[1]</code></li>
<li>弹出末尾元素：<code>.pop()</code></li>
<li>访问弹出元素：<code>a = b.pop()</code></li>
<li>弹出对应位置的元素：<code>.pop(1)</code></li>
<li><code>pop</code> 和 <code>del</code> 的区别在于 <code>pop</code> 可访问删除的元素，<code>del</code> 不行。</li>
<li>根据值删除<strong>一个</strong>元素：<code>.remove(&quot;spw&quot;)</code></li>
<li>排序（列表中元素类型要一样才能排序，按照字典序排序）：<code>.sort()</code></li>
<li>倒序：<code>.sort(reverse = True)</code></li>
<li>临时排序，不改变列表，可加入参数：<code>sorted(b, reverse = True)</code></li>
<li>访问列表中元素个数：<code>len(b)</code></li>
</ul>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Implementing Vue Reactivity Using Javascript</title>
    <url>/57511a32.html</url>
    <content><![CDATA[<p>代码思路：</p>
<p>先将每个变量注入到 Vue 实例中，使我们不必通过 data 访问，可以直接通过 Vue 实例访问。</p>
<p>然后为每一个键（变量）创建一个 Observer。</p>
<p>最后解析整个页面模板，为所有的引用变量的地方创建一个 Watcher，然后把它加到对应的 Dep 中，一个变量对应一个 Dep 但是一个变量可以被多次引用，每一个引用都是一个 Watcher，这样在一个 Watcher 改变时，它的 setter 就会触发它所在的 Dep 的更新。</p>
<p>中间对于数据的替换和更新用到了一系列的字符串操作和正则表达式。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, key, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callback</span> = callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// target 在使用时不需要显式声明</span></span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">oldValue</span> = vm[key];</span><br><span class="line">    <span class="comment">// 激活 getter，将这个值的 Watcher 添加到它所在对象的 Sub</span></span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 重置 target</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newValue = <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>];</span><br><span class="line">    <span class="keyword">if</span> (newValue === <span class="variable language_">this</span>.<span class="property">oldValue</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">callback</span>(newValue);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">oldValue</span> = newValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compile</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">el</span> = vm.<span class="property">$el</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">compile</span>(<span class="variable language_">this</span>.<span class="property">el</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">compile</span>(<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> childNodes = el.<span class="property">childNodes</span>;</span><br><span class="line">    <span class="title class_">Array</span>.<span class="title function_">from</span>(childNodes).<span class="title function_">forEach</span>(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">3</span>) &#123; <span class="comment">// text</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">compileText</span>(node);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">1</span>) &#123; <span class="comment">// element</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">compileElement</span>(node);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 还有子节点</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">childNodes</span> &amp;&amp; node.<span class="property">childNodes</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">compile</span>(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">compileElement</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/^v-([\w-]+)$/</span>;</span><br><span class="line">    <span class="keyword">const</span> regx = <span class="regexp">/:([\w-]+)=&quot;([^&quot;]+)&quot;/</span>;</span><br><span class="line">    <span class="title class_">Array</span>.<span class="title function_">from</span>(node.<span class="property">attributes</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">attr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> match = regx.<span class="title function_">exec</span>(<span class="string">`<span class="subst">$&#123;attr.name&#125;</span>=&quot;<span class="subst">$&#123;attr.value&#125;</span>&quot;`</span>);</span><br><span class="line">      <span class="keyword">if</span> (match) &#123;</span><br><span class="line">        <span class="keyword">const</span> name = match[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">const</span> value = match[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, value, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">          node.<span class="title function_">setAttribute</span>(name, newValue);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((match = reg.<span class="title function_">exec</span>(attr.<span class="property">name</span>))) &#123;</span><br><span class="line">        <span class="keyword">const</span> opName = match[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">const</span> value = attr.<span class="property">value</span>; <span class="comment">// string</span></span><br><span class="line">        <span class="comment">// ( _ ) 捕获从 1 下标开始</span></span><br><span class="line">        <span class="keyword">switch</span> (opName) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;model&quot;</span>:</span><br><span class="line">            node.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">vm</span>[value];</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, value, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">              node.<span class="property">value</span> = newValue;</span><br><span class="line">            &#125;);</span><br><span class="line">            node.<span class="title function_">addEventListener</span>(<span class="string">&quot;input&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="variable language_">this</span>.<span class="property">vm</span>[value] = event.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;if&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;on&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;else&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;else-if&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;for&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">compileText</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>;</span><br><span class="line">    <span class="comment">// const value = node.textContent.replace(/\s/g, &#x27;&#x27;);</span></span><br><span class="line">    <span class="keyword">const</span> value = node.<span class="property">textContent</span>;</span><br><span class="line">    <span class="keyword">const</span> tokens = [];</span><br><span class="line">    <span class="keyword">let</span> result,</span><br><span class="line">      index,</span><br><span class="line">      lastIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((result = reg.<span class="title function_">exec</span>(value))) &#123;</span><br><span class="line">      index = result.<span class="property">index</span>;</span><br><span class="line">      <span class="keyword">if</span> (index &gt; lastIndex) &#123;</span><br><span class="line">        tokens.<span class="title function_">push</span>(value.<span class="title function_">slice</span>(lastIndex, index));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> key = result[<span class="number">1</span>].<span class="title function_">trim</span>();</span><br><span class="line">      tokens.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">vm</span>[key]);</span><br><span class="line">      lastIndex = index + result[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> pos = tokens.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// update</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, key, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">        tokens[pos] = newValue;</span><br><span class="line">        node.<span class="property">textContent</span> = tokens.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastIndex &lt; value.<span class="property">length</span>) &#123;</span><br><span class="line">      tokens.<span class="title function_">push</span>(value.<span class="title function_">slice</span>(lastIndex));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tokens.<span class="property">length</span>) &#123;</span><br><span class="line">      node.<span class="property">textContent</span> = tokens.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []; <span class="comment">// watchers</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">sub</span>) =&gt;</span> sub.<span class="title function_">update</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">walk</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">walk</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> <span class="title function_">defineProperty</span>(data, key, data[key]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为每个属性值添加 getter 和 setter，这是响应式的基础</span></span><br><span class="line"><span class="comment">// 同时为每个对象添加一个 dep</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineProperty</span>(<span class="params">data, key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">  <span class="comment">// is a object</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="title class_">Object</span> &amp;&amp; value !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Observer</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span> &amp;&amp; dep.<span class="title function_">addSub</span>(<span class="title class_">Dep</span>.<span class="property">target</span>); <span class="comment">// Watcher initualize</span></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value === newValue) <span class="keyword">return</span>;</span><br><span class="line">      value = newValue;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="title class_">Object</span> &amp;&amp; value !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Observer</span>(value);</span><br><span class="line">        <span class="comment">// 如果更改的值是一个对象，也要对每个对象的值进行观察初始化</span></span><br><span class="line">      &#125;</span><br><span class="line">      dep.<span class="title function_">notify</span>();</span><br><span class="line">      <span class="comment">// 触发每一个 Sub 的更新。</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$options</span> = options || &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span> || &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> el = options.<span class="property">el</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="keyword">typeof</span> el === <span class="string">&quot;string&quot;</span> ? <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(el) : el;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入</span></span><br><span class="line">    <span class="title function_">proxy</span>(<span class="variable language_">this</span>, <span class="variable language_">this</span>.<span class="property">$data</span>);</span><br><span class="line">    <span class="comment">// vm.$data.prop -&gt; vm.prop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 观察</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="variable language_">this</span>.<span class="property">$data</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板分析</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Compile</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="comment">// 找到一开始需要响应式的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">proxy</span>(<span class="params">target, data</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, &#123;</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[key];</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        data[key] = newValue;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>My Website Dev Log</title>
    <url>/51cade6f.html</url>
    <content><![CDATA[<h1 id="2024"><a href="#2024" class="headerlink" title="2024"></a>2024</h1><h2 id="July"><a href="#July" class="headerlink" title="July"></a>July</h2><h3 id="29"><a href="#29" class="headerlink" title="29"></a>29</h3><p>刚有点想法，利用 <code>create-nuxt-app</code> 创建了一个 nuxt2 的项目，很多配置项我都没见过，一一了解了一遍。</p>
<p>比如一个网站的开发流程啊，动态静态网站区别，网站部署，框架有什么用，选什么框架，UI框架又是什么。</p>
<p>框架选了 Nuxt，UI 框架选了 Tailwind css</p>
<p>和铃仙交流了很多，我们都收获不少。</p>
<h3 id="30"><a href="#30" class="headerlink" title="30"></a>30</h3><p>继续昨天的任务。</p>
<p>简单完成了主页和一个没有什么用的 Nav，做了一个小 NavButton，试了试 Tailwind UI 的 404 页面，顺便把它变成了一个路由页面。</p>
<p>然后把网站利用 gh-pages 包部署到 github pages 上。</p>
<p>在晚上意识到原来用的是老版本的 Nuxt，于是将项目迁移到最新的 Nuxt3.12 版本。</p>
<h3 id="31"><a href="#31" class="headerlink" title="31"></a>31</h3><p>重头戏，写了好多东西（其实也没有多少）</p>
<p>把项目重构了一遍，结构更加清晰。</p>
<p>使用路由，重载路由规则。</p>
<p>学习 Typescript，这玩意越来越像 C++ JAVA C# 这种语言了。</p>
<p>然后学习项目结构配置，</p>
<p>将包管理器换为 pnpm，</p>
<p>完善了 Nav 布局，</p>
<p>简单入门 layouts，middleware，</p>
<p>配置一下 404 的路由规则。</p>
<p>把 NavButton 的 Props 加上了，简单写了几个待完善的页面。</p>
<p>分别为默认和 layouts 配置了页面切换动画。</p>
<p>Vsc 插件生态。</p>
<p>添加了 font-awesome 图标支持，只需要在 config 里添加需要用的图标名称，然后在对应组件里添加：<code>&lt;font-awesome icon=&quot;name&quot; /&gt; </code> 即可。</p>
<p>github pages url 容易出问题，要么尽量使用相对路径，要么还是换个域名吧，然后我就部署到 vercel 了。</p>
<h2 id="Auguest"><a href="#Auguest" class="headerlink" title="Auguest"></a>Auguest</h2><p>label</p>
<h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><p>完善布局。</p>
<h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><p>咕咕咕</p>
<h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><p>完善侧边栏，文章组件卡片和 NavBar 以及布局。</p>
<p>完善 Archives Albums About 页面。</p>
<p>先这样吧。</p>
<h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><p>修复 bug，适配响应式。</p>
<h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><p>没做什么，用 js 模拟了一下 vue 的响应式，算是稍微深入了解了一下原理。</p>
<h3 id="06"><a href="#06" class="headerlink" title="06"></a>06</h3><p>更新卡片以及链接的样式，很好看。</p>
<h3 id="07"><a href="#07" class="headerlink" title="07"></a>07</h3><p>着手个人作品集网站的整理和开发，使用 Vue 框架，打算做简单点不需要太多功能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202408081146820.webp"
                      alt="image.png"
                ></p>
<p>目前是打算先把之前写过的各种东西组件化放进来。</p>
<p>才整了三个组件我就觉得麻烦了，然后写了两个脚本分别生成卡片组和路由。</p>
<h3 id="08"><a href="#08" class="headerlink" title="08"></a>08</h3><p>完善个人网站响应式，优化项目结构，研究了一下，使得局域网设备可以实时预览项目（改一下 <code>vite.config.js</code>，防火墙的锅）</p>
<p>简单学习了解了一下浏览器的工作原理，堪比一个操作系统的复杂度。</p>
<h3 id="09"><a href="#09" class="headerlink" title="09"></a>09</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202408091138933.webp"
                      alt="image.png"
                ></p>
<p>完善了下按钮样式和其它布局。</p>
<p>把所有的旧组件都添加完成了！</p>
<p>接下来可以开始新的练习了。</p>
<p>很棒！</p>
<h3 id="26"><a href="#26" class="headerlink" title="26"></a>26</h3><p>中间忘记写日志了，现在是这样的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202408281739379.webp"
                      alt="image.png"
                ></p>
<p><strong>UPDATES:</strong></p>
<ul>
<li>把所有的小项目组件化</li>
<li>完善主页样式和其它页面样式</li>
<li>添加了新项目 CalendarView：<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202408281740987.webp"
                      alt="Snipaste_2024-08-28_17-40-13.png"
                ></li>
<li>介绍一下，这是一个记录 App，日历仅用于索引，左键可以将当天的感受指数 $+1$，右键是 $-1$,会根据感受指数显示不同的颜色，控制面板现在有两个按钮，第一个是定位到当天，第二个是显示年视图。做了好看的切换动画。后端使用 Express，暂时只运行在本地，用 <code>json</code> 文件作为数据库存储数据，目前仅个人使用。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>logs</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Note</title>
    <url>/fbbf86b6.html</url>
    <content><![CDATA[
  <div class="note p-4 mb-4 rounded-small markdown-body warning icon-padding">
    <i class="note-icon fa-solid fa-hand-point-right"></i><p>本 <strong>Note</strong> 记录学习过程中遇到的一些问题，学到哪里便记到哪里，<strong>不适合作为系统学习的参考</strong>，持续更新。</p>

  </div>

<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><p><code>var</code> 为全局作用域，可以理解为所有的 <code>var</code> 相当于都出现在文件开头，在全局内都有效。</p>
<p><code>let</code> 为块级作用域。</p>
<p>举个例子：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a ,b);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p>这段代码中，<code>b</code> 会报错，而 <code>a</code> 不会。</p>
<p><code>const</code> 为常量，不可修改，需要在初始化时声明数值。。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ob = &#123;</span><br><span class="line">  [key]: [value],</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></div>

<p>对象的 <code>key</code> 可以是字符串、非字符串（会转换为字符串），符号。</p>
<p>通常对象的键不可以是函数，我们可以把函数转化为相应的字符串，或者使用 <code>Map</code> 数据结构。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>以创建一个长度为 <code>num</code> 且初始化全部是 0 为例子。</p>
<h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>; <span class="comment">// 假设数组长度为 10</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(num).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure></div>

<h3 id="from"><a href="#from" class="headerlink" title="from"></a>from</h3><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>; <span class="comment">// 假设数组长度为 10</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: num &#125;, <span class="function">() =&gt;</span> <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure></div>

<p><code>Array.from()</code> 可以将一个类数组对象转化为数组，这个对象需要有 <code>length</code> 属性，否则数组长度将为 0</p>
<p><strong>示例</strong></p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = &#123;<span class="number">1</span>: <span class="string">&#x27;1&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;haha&#x27;</span>, <span class="number">3</span>: <span class="number">3</span>, <span class="string">&#x27;length&#x27;</span>: <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr);</span><br></pre></td></tr></table></figure></div>

<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>朴素的 <code>for</code> 循环，这里就不献丑了。</p>
<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><h3 id="简单声明"><a href="#简单声明" class="headerlink" title="简单声明"></a>简单声明</h3><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...) &#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">  <span class="comment">// 执行一些操作</span></span><br><span class="line">  <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>示例：</strong></p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greet</span>(<span class="string">&quot;Alice&quot;</span>)); <span class="comment">// 输出: Hello, Alice!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>也可以赋值给一个变量：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 函数名 = <span class="keyword">function</span>(<span class="params">参数<span class="number">1</span>, 参数<span class="number">2</span>, ...</span>) &#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">  <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>示例：</strong></p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greet</span>(<span class="string">&quot;Bob&quot;</span>)); <span class="comment">// 输出: Hello, Bob!</span></span><br></pre></td></tr></table></figure></div>

<p>也可以使用 ES6 引入的<strong>箭头函数</strong>：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 函数名 = <span class="function">(<span class="params">参数<span class="number">1</span>, 参数<span class="number">2</span>, ...</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">  <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>如果只有一个表达式，那么可以进一步简化（省略 <code>return</code>）：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 函数名 = <span class="function">(<span class="params">参数<span class="number">1</span>, 参数<span class="number">2</span>, ...</span>) =&gt;</span> 返回值;</span><br></pre></td></tr></table></figure></div>

<p>箭头前是函数的形参，箭头后是函数体（返回值）。</p>
<p><strong>示例：</strong></p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化形式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = name =&gt; <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greet</span>(<span class="string">&quot;Charlie&quot;</span>)); <span class="comment">// 输出: Hello, Charlie!</span></span><br></pre></td></tr></table></figure></div>

<p>箭头函数只能被赋值给一个变量，或者作为其它表达式的一部分。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>接受一个&#x2F;多个函数作为参数，或者返回一个函数的函数。</p>
<p><strong>示例：</strong></p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">createMultiplier</span> = multiplier =&gt; <span class="function"><span class="params">number</span> =&gt;</span> number * multiplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> double = <span class="title function_">createMultiplier</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">double</span>(<span class="number">5</span>)); <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> triple = <span class="title function_">createMultiplier</span>(<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">triple</span>(<span class="number">5</span>)); <span class="comment">// 输出: 15</span></span><br></pre></td></tr></table></figure></div>

<p><strong>解释</strong>：</p>
<ul>
<li><code>createMultiplier</code> 是一个高阶函数，它接受一个参数 <code>multiplier</code>。</li>
<li>它返回一个新的箭头函数 <code>number =&gt; number * multiplier</code>。</li>
<li>返回的函数接收一个参数 <code>number</code>，并返回 <code>number</code> 与 <code>multiplier</code> 的乘积。</li>
</ul>
<ol>
<li>接受函数作为参数</li>
</ol>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isEven</span> = num =&gt; num % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> evenNumbers = numbers.<span class="title function_">filter</span>(isEven);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(evenNumbers); <span class="comment">// 输出: [2, 4]</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>filter</code> 方法接受一个回调函数 <code>isEven</code>，该函数判断一个数是否为偶数。</li>
<li><code>filter</code> 方法遍历 <code>numbers</code> 数组，并返回所有使回调函数返回 <code>true</code> 的元素组成的新数组。</li>
</ul>
<ol start="2">
<li>一个简单的缓存函数</li>
</ol>
<p><strong>示例：</strong></p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">cacheFunction</span> = fn =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(args);</span><br><span class="line">    <span class="keyword">if</span> (!cache[key]) &#123;</span><br><span class="line">      cache[key] = <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[key];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br><span class="line"><span class="keyword">const</span> cachedAdd = <span class="title function_">cacheFunction</span>(add);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cachedAdd</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 输出: 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cachedAdd</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 输出: 3（从缓存中获取）</span></span><br></pre></td></tr></table></figure></div>

<p>详细解释一下这个缓存函数：</p>
<ul>
<li><code>cacheFunction</code> 是一个高阶函数，接受一个函数 <code>fn</code> 作为参数。</li>
<li><code>cache = &#123;&#125;</code> 是用来初始化一个空对象，用于存储函数的计算结果。这个对象的键是<strong>函数参数的字符串表示</strong>（通过剩余参数将所有参数存入一个数组中，然后将这个数组转化为 JSON 字符串，作为 <code>cache</code> 对象的键），值是函数执行的结果。</li>
<li>它返回一个新的函数，该函数使用一个对象 <code>cache</code> 来存储计算结果。</li>
<li>当调用返回的函数时，它会先检查 <code>cache</code> 中是否有结果，如果没有则计算并存储结果。</li>
</ul>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">...name</span><br></pre></td></tr></table></figure></div>

<p>表示函数的可变参数，所有传入的参数收集到一个 <code>name</code> 数组中。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">exampleFunction</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">exampleFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure></div>

<p>如本例中的 <code>args</code> 数组就是 <code>[1, 2, 3]</code>。</p>
<h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>函数在声明之前可以被调用，但是函数表达式不可以。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sayHello</span>()); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sayHello</span>()); <span class="comment">// 报错: sayHello is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sayHello = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>在对应参数名后面加上问号即可，所有可选参数需要放在尾部。</p>
<p>也可以通过设置默认值，这样可以写在头部。（不建议）</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = array.<span class="title function_">map</span>(<span class="title function_">callback</span>(currentValue[, index[, array]])[, thisArg])</span><br></pre></td></tr></table></figure></div>

<p>该方法对数组中的每个元素调用一次函数，得到的返回值作为新的数组值，最后得到一个新数组。</p>
<ul>
<li><code>callback</code>：用于生成新数组元素的函数，接受三个参数：<ul>
<li><code>currentValue</code>：当前正在处理的元素。</li>
<li><code>index</code>（可选）：当前正在处理的元素的索引。</li>
<li><code>array</code>（可选）：<code>map</code> 方法被调用的数组。</li>
</ul>
</li>
<li><code>thisArg</code>（可选）：执行回调时用作 <code>this</code> 值的对象。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数作为回调函数</span></span><br><span class="line"><span class="keyword">const</span> doubled = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doubled); <span class="comment">// 输出: [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Charlie&quot;</span>, <span class="attr">age</span>: <span class="number">35</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userNames = users.<span class="title function_">map</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userNames); <span class="comment">// 输出: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]</span></span><br></pre></td></tr></table></figure></div>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>用于数组，创建一个新数组。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = array.<span class="title function_">filter</span>(<span class="title function_">callback</span>(element[, index[, array]])[, thisArg])</span><br></pre></td></tr></table></figure></div>

<p>新数组将包含通过 <code>callback</code> 测试的元素。</p>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;&#125;, [time]);</span><br></pre></td></tr></table></figure></div>

<p><code>[time]</code> 为毫秒级单位，第一个参数是要执行的函数，第二个参数是延迟执行的时间。</p>
<p>如果要停止它：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="built_in">setTimeout</span>(...);</span><br><span class="line"><span class="built_in">clearTimeout</span>(fn);</span><br></pre></td></tr></table></figure></div>

<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p>按照一定时间间隔重复执行某个函数。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(callback, delay, ...args);</span><br></pre></td></tr></table></figure></div>

<p>参数分别为：函数，时间间隔，传递给函数的附加参数（可选）。</p>
<p>如果要停止它：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="built_in">setInterval</span>(...);</span><br><span class="line"><span class="built_in">clearInterval</span>(fn);</span><br></pre></td></tr></table></figure></div>

<h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">splice</span>(index, x);</span><br></pre></td></tr></table></figure></div>

<p>删除这个数组中从下标 <code>index</code> 开始的 <code>x</code> 项。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>数组对象的一个方法，对数组中的每个元素依次执行回调函数，并将所有的结果以某种方式累积为一个值。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">reduce</span>(<span class="title function_">callback</span>(accumulator, currentValue, currentIndex, array), initialValue)</span><br></pre></td></tr></table></figure></div>

<p><code>accumulator</code> 累积所有结果，<code>currentValue</code> 是当前正在处理的元素。</p>
<p><code>currentIndex</code>（可选）是当前正在处理的元素的索引。</p>
<p><code>array</code>（可选）是当前数组。</p>
<p><code>initialValue</code>（可选） 是 <code>accumulator</code> 的初始值。若没有，则以数组第一个元素为初始值，从第二个元素开始执行回调函数。</p>
<p>示例：数组求和</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 输出 15</span></span><br></pre></td></tr></table></figure></div>

<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>将一个字符串分割为子字符串数组。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">string.<span class="title function_">split</span>(separator, limit)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>separator</code>：必选，分割符（可以是字符串或者正则表达式）。</li>
<li><code>limit</code>：可选，最多返回几个字符。</li>
</ul>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>用于将一个数组内的全部元素都转变为字符串并用指定分隔符将它们连接成一个字符串作为返回值。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">join</span>(separator)</span><br></pre></td></tr></table></figure></div>

<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p><code>innerHTML</code> 属性用于获取或设置元素的 HTML 内容。它会将元素内部的所有 HTML 标签和文本内容作为一个字符串返回或设置。这意味着你可以使用 <code>innerHTML</code> 动态地插入 HTML 结构。</p>
<h3 id="innerText"><a href="#innerText" class="headerlink" title="innerText"></a>innerText</h3><p><code>innerText</code> 属性用于获取或设置元素的文本内容。它会忽略任何 HTML 标签，只返回或设置纯文本。这意味着 <code>innerText</code> 只会处理可见的文本内容，而不会包含任何 HTML 标签或嵌套结构。</p>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="CSS-选择器的区别"><a href="#CSS-选择器的区别" class="headerlink" title="CSS 选择器的区别"></a>CSS 选择器的区别</h2><ol>
<li><p><strong><code>.container &gt; .panel</code></strong></p>
<ul>
<li>选择所有直接子元素 <code>.panel</code>，它们的父元素是 <code>.container</code>。</li>
<li><strong>示例：</strong></li>
</ul>
</li>
</ol>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel&quot;</span>&gt;</span>直接子元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel&quot;</span>&gt;</span>不是直接子元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>仅选择第一个 <code>div.panel</code>，因为它是 <code>div.container</code> 的直接子元素。</p>
<ol start="2">
<li><p><strong><code>.container .panel</code></strong></p>
<ul>
<li>选择所有后代元素 <code>.panel</code>，它们位于 <code>.container</code> 内部，无论层级如何。</li>
<li><strong>示例：</strong></li>
</ul>
</li>
</ol>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel&quot;</span>&gt;</span>直接子元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel&quot;</span>&gt;</span>嵌套的子元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>选择两个 <code>div.panel</code>，因为它们都是 <code>div.container</code> 的后代元素。</p>
<ol start="3">
<li><p><strong><code>.container.panel</code></strong></p>
<ul>
<li>选择同时包含 <code>container</code> 和 <code>panel</code> 类的所有元素。</li>
<li><strong>示例：</strong></li>
</ul>
</li>
</ol>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container panel&quot;</span>&gt;</span></span><br><span class="line">  同时拥有 container 和 panel 类的元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel&quot;</span>&gt;</span>单独拥有 panel 类的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>仅选择第一个 <code>div</code>，因为它同时拥有 <code>container</code> 和 <code>panel</code> 类。</p>
<h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><p><code>window</code> 对象是 JavaScript 在浏览器环境中的全局对象，表示浏览器的窗口或框架。它包含了许多有用的属性和方法，用于操作浏览器窗口和与用户交互。在浏览器中，所有全局变量、函数和对象都是 <code>window</code> 对象的属性和方法。</p>
<p>它的属性和属性值过多，这里不多列举。</p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> elements = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selectors);</span><br></pre></td></tr></table></figure></div>

<p>返回的是匹配的第一个元素。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> elements = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(selectors);</span><br></pre></td></tr></table></figure></div>

<p>返回的是一个 NodeList，是一种类数组对象，表示文档中的一组节点，储存<strong>匹配选择器</strong>的所有元素。</p>
<p>不是数组，有 <code>length</code> 属性，可以通过索引访问其中的元素。</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>遍历数组或类数组对象，对数组中的每个元素执行一次提供（参数）的回调函数。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>currentValue</code> 必选，表示当前正在处理的元素。</li>
<li><code>index</code> 可选，表示当前正在处理的元素的索引，从 0 开始。</li>
<li><code>array</code> 可选，调用数组本身。</li>
</ul>
<h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, [<span class="keyword">function</span>]);</span><br></pre></td></tr></table></figure></div>

<p>向指定元素添加事件监听器，当事件（这里是点击）发生时，执行相应的回调函数。</p>
<p><strong>常用的事件</strong></p>
<ul>
<li><code>DOMContentLoaded</code>：文档内容加载完成</li>
<li><code>click</code></li>
<li><code>mouseover</code></li>
<li><code>keydown</code></li>
</ul>
<h3 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h3><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">item.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;[class]&#x27;</span>);</span><br><span class="line">item.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;[class]&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p>为当前元素添加&#x2F;删除 <code>class</code></p>
<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>了解 <code>call</code> 方法之前，先来了解一下 <code>this</code>。</p>
<p>在JavaScript中，<code>this</code>关键字总是指向一个对象，通常是指向调用函数的那个对象。<code>this</code>的值在函数被调用时才会确定，并且其值取决于函数是如何被调用的。</p>
<ol>
<li><strong>全局函数</strong>：在全局函数中，<code>this</code>指向全局对象（在浏览器中是<code>window</code>）。</li>
</ol>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayGlobal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayGlobal</span>(); <span class="comment">// 在浏览器中，控制台将显示window对象</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>对象的方法</strong>：当一个函数作为某个对象的方法被调用时，<code>this</code>指向该对象。</li>
</ol>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// 这里this指向person对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">sayName</span>(); <span class="comment">// 输出: Alice</span></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>构造函数</strong>：在构造函数中，<code>this</code>指向新创建的对象。</li>
</ol>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">make, model</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myCar = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;Toyota&#x27;</span>, <span class="string">&#x27;Corolla&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCar.<span class="property">make</span>); <span class="comment">// 输出: Toyota</span></span><br><span class="line"><span class="comment">// 在Car构造函数中，this指向新创建的myCar对象</span></span><br></pre></td></tr></table></figure></div>

<p><code>new</code> 用于新建一个对象，后面调用构造函数。</p>
<ol start="4">
<li><strong>事件处理器</strong>：在事件处理器中，<code>this</code>指向触发事件的对象。</li>
</ol>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="variable constant_">HTML</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;clickMe&quot;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// JavaScript</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;clickMe&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 这里this指向被点击的button元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&#x27;Button was clicked!&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li><strong>箭头函数</strong></li>
</ol>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// 这里this指向person对象，而不是全局对象或window</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">greet</span>(); <span class="comment">// 一秒钟后输出: Bob</span></span><br></pre></td></tr></table></figure></div>

<p><code>call</code>方法的作用是调用一个函数，并显式地设置函数体内的<code>this</code>对象，同时传递参数给这个函数。<code>call</code>方法的第一个参数是<code>this</code>的绑定对象，后面的参数是传递给函数的参数。</p>
<p><strong>例如：</strong></p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">introduce</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal = &#123; <span class="attr">name</span>: <span class="string">&quot;Dog&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用call方法借用Person的introduce方法</span></span><br><span class="line"><span class="keyword">var</span> animalIntroduce = <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">introduce</span>.<span class="title function_">call</span>(animal);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(animalIntroduce); <span class="comment">// 输出: My name is Dog</span></span><br></pre></td></tr></table></figure></div>

<p>这里 <code>.call(animal)</code> 就改变了一个<strong>原型构造函数</strong>的 <code>this</code> 值为对象 <code>animal</code>，实现了方法的借用。</p>
<p>其它的功能比如改变函数的调用上下文，实现继承等。</p>
<p><strong>示例：</strong></p>
<p>比如数组的一个方法 <code>filter</code>，想要作用于类数组对象上，可以这样写：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">[].<span class="property">filter</span>.<span class="title function_">call</span>(item.<span class="property">parentElement</span>.<span class="property">children</span>, <span class="function"><span class="params">el</span> =&gt;</span> el !== item)</span><br></pre></td></tr></table></figure></div>

<p>这里 <code>item.parentElement.children</code> 返回的是元素 <code>item</code> 的父元素的所有子元素的集合，是一个类数组对象，为了对它进行 <code>filter</code> 的方法，可以利用 <code>call</code>，实现方法的借用，后面 <code>el =&gt; el !== item</code> 是原 <code>filter</code> 函数的参数，表示 <code>callback</code> 筛选条件。</p>
<h3 id="toggle"><a href="#toggle" class="headerlink" title="toggle"></a>toggle</h3><p>切换某元素的某个 <code>class</code> 的开关状态，若存在则移除它，若不存在则添加它。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">element.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&quot;changed&quot;</span>, [<span class="literal">true</span>/<span class="literal">false</span>]);</span><br></pre></td></tr></table></figure></div>

<p>第二个参数可选，若 <code>true</code> 则强制添加，若 <code>false</code> 则强制删除。</p>
<h3 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h3><p>是元素的一个方法，返回一个包含该元素信息的 <code>DOMRect</code> 对象。</p>
<p>提供以下属性：</p>
<ul>
<li>**<code>top</code>**：元素上边缘到视口上边缘的距离。</li>
<li>**<code>right</code>**：元素右边缘到视口左边缘的距离。</li>
<li>**<code>bottom</code>**：元素下边缘到视口上边缘的距离。</li>
<li>**<code>left</code>**：元素左边缘到视口左边缘的距离。</li>
<li>**<code>width</code>**：元素的宽度（相当于 <code>right - left</code>）。</li>
<li>**<code>height</code>**：元素的高度（相当于 <code>bottom - top</code>）。</li>
</ul>
<h1 id="异步-asynchronous"><a href="#异步-asynchronous" class="headerlink" title="异步(asynchronous)"></a>异步(asynchronous)</h1><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>一个函数接受另一个函数作为参数，并在进行一系列操作之后回调这个函数。</p>
<p>示例：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="string">&quot;Data fetched&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchData</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// 输出 &quot;Data fetched&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><code>Promise</code> 对象返回一个异步操作的最终完成&#x2F;失败及其结果值，它可以将一个操作异步化。</p>
<p>什么是异步？什么是同步？</p>
<p>正常来讲一个 javascript 程序是按照顺序执行的，上一个函数执行完之前，底下的函数只能干等着。</p>
<p>如果这是一个非常耗时的网络请求，我们完全可以一边执行请求，一边执行其它的代码，这就是异步，反之等待请求完成后再执行其它代码就是同步。</p>
<p>创建一个 <code>Promise</code> 对象：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步操作的代码</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;成功的结果&#x27;</span>); <span class="comment">// 异步操作成功时调用</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;失败的原因&#x27;</span>); <span class="comment">// 异步操作失败时调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>一个 <code>Promise</code> 对象在被创建后里面的操作会立刻执行。</p>
<p>它有三种状态：</p>
<ul>
<li><code>pending</code></li>
<li><code>fulfilled</code></li>
<li><code>rejected</code></li>
</ul>
<p>比如我想实现两个异步操作都结束时将它们的结果值相加，那么可以使用 <code>Promise.all()</code> 函数，参数是一个 <code>Promise</code> 数组，当里面的 <code>Promise</code> 都成功时，返回一个数组，里面是各个 <code>Promise</code> 的结果值。</p>
<p>这样就可以让两个操作并行，节约时间。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span>), <span class="number">20</span>));</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="number">5</span>), <span class="number">60</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1, promise2]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://leetcode.cn/problems/add-two-promises/description/?envType=study-plan-v2&envId=30-days-of-javascript" >Leetcode 例题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>如果我想在超时之后返回 <code>reject</code> 并且终止进程防止内存泄漏，可以这样：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;                <span class="title function_">reject</span>(<span class="string">&quot;Time Limit Exceeded&quot;</span>);</span><br><span class="line">		&#125;, t);</span><br><span class="line">	<span class="title function_">fn</span>(...args).<span class="title function_">then</span>(resolve).<span class="title function_">catch</span>(reject).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="built_in">clearTimeout</span>(timeout));</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>还可以保证函数的正常运行，如果运行成功，那么 <code>.then(resolve</code>，否则就 <code>.catch(reject)</code>，并且最后结束这个 <code>timout</code>。</p>
<p><a class="link"   href="https://leetcode.cn/problems/promise-time-limit/description/?envType=study-plan-v2&envId=30-days-of-javascript" >Leetcode 例题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><p><code>async</code> 用于声明一个异步函数，使它返回一个 <code>Promise</code> 对象。</p>
<p><code>await</code> 只能在 <code>async</code> 函数内部使用，用于等待一个 <code>Promise</code> 完成，并返回 <code>Promise</code> 的结果。</p>
<p>这样可以使我们可以以同步的方式处理异步代码。</p>
<p><strong>注意：</strong></p>
<p>如果需要在循环中使用异步操作，那么是不可以使用 <code>forEach</code> 或者 <code>map</code> 这种方法的，它不会等待 <code>await</code> 执行完，而是直接进入下一个循环。</p>
<p><strong>如何解决？</strong></p>
<p>使用 <code>for...of</code> 循环。</p>
<p><strong>如何让所有的异步操作并发执行呢？</strong></p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> promises = [</span><br><span class="line">		<span class="title function_">someAsyncOperation</span>(),</span><br><span class="line">		<span class="title function_">someAsyncOperation</span>(),</span><br><span class="line">		<span class="title function_">someAsyncOperation</span>()</span><br><span class="line">	];</span><br><span class="line">	<span class="keyword">for</span> <span class="title function_">await</span> (<span class="keyword">let</span> result <span class="keyword">of</span> promises);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>promises</code> 中存储的是若干个 <code>Promise</code> 对象，这些对象在创建 <code>promises</code> 时即开始并发执行，用 <code>for await</code> 来依次等待它们完成（所有的 <code>Promise</code> 是同时运行的），这样就可以在它们都运行完成后退出循环进行下一步的操作。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">day, date</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">day</span> = day;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">date</span> = date;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>constructor</code> 构造函数中，成员变量不需要显式声明，使用 <code>new Day(day, date)</code> 进行实例化。</p>
<h2 id="Extends"><a href="#Extends" class="headerlink" title="Extends"></a>Extends</h2><p>类之间可以继承，子类可以继承父类的功能也可以重写父类的方法。</p>
<p>使用在子类中使用 <code>super()</code> 调用父类的构造函数。</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(string);</span><br></pre></td></tr></table></figure></div>

<p>用于将 JSON 字符串转换为 JS 对象。</p>
<h2 id="stringify"><a href="#stringify" class="headerlink" title="stringify"></a>stringify</h2><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj);</span><br></pre></td></tr></table></figure></div>

<p>将对象转换为 JSON 字符串。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="转换为-Object"><a href="#转换为-Object" class="headerlink" title="转换为 Object"></a>转换为 Object</h2><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(map);</span><br></pre></td></tr></table></figure></div>

<h2 id="转换为-Map"><a href="#转换为-Map" class="headerlink" title="转换为 Map"></a>转换为 Map</h2><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj); <span class="comment">// 转换为二维键值数组</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(temp)</span><br></pre></td></tr></table></figure></div>

<h1 id="Backend"><a href="#Backend" class="headerlink" title="Backend"></a>Backend</h1><h2 id="res"><a href="#res" class="headerlink" title="res"></a>res</h2><p>响应体，后端可以进行一些响应返回给前端。</p>
<p>常用：</p>
<ul>
<li><code>res.send()</code>：返回纯文本&#x2F; HTML 数据</li>
<li><code>res.json()</code>：将对象转化为 JSON 字符串并返回</li>
<li><code>res.status()</code>：设置 HTTP 状态码</li>
<li><code>res.sendFile()</code>：发送文件</li>
<li><code>res.setHeader()</code>：设置响应头</li>
<li><code>res.redirect()</code>：将客户端重定向到另一个 URL</li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Regex Note</title>
    <url>/23441a96.html</url>
    <content><![CDATA[<blockquote>
<p>regex</p>
</blockquote>
<p>推荐在线测试网站：<a class="link"   href="https://regex101.com/" >Link<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ul>
<li><code>?</code> 代表前面这个字符可有可无<ul>
<li><code>used?</code> 匹配的是 <code>use</code> 和 <code>used</code>。</li>
</ul>
</li>
<li><code>*</code> 代表前面这个字符可以出现 0 次到无数次。<ul>
<li><code>ab*c</code> 可以匹配 <code>ac</code>，也可以匹配 <code>abbbbc</code>。</li>
</ul>
</li>
<li><code>+</code> 与 <code>*</code> 类似，但不可以出现 0 次。</li>
<li><code>&#123;x, y&#125;</code> 代表前面的字符出现 x 到 y 次，如果只出现 x 次省略 <code>,y</code> ，如果出现大于等于 x 次那么省略 <code>y</code>。</li>
<li>如果想要匹配多个字符，那么用括号包裹它们。</li>
<li><code>(|)</code> 是或运算符，需要用括号包裹。<ul>
<li><code>a (cat|dog)</code> 可以匹配 <code>a cat</code> 或者 <code>a dog</code>。</li>
</ul>
</li>
<li><code>[]</code> 里的字符代表匹配的选择范围。<ul>
<li>如 <code>[abc]</code> <code>[a-z]</code> <code>[a-zA-z0-9]</code>。</li>
</ul>
</li>
<li><code>[^]</code> 表示非。<ul>
<li>如 <code>[^0-9]</code> 表示所有的非数字字符。</li>
</ul>
</li>
<li><code>\d</code> 表示数字字符，等同于 <code>[0-9]</code>。</li>
<li><code>\w</code> 表示单词字符，所有的字母加下划线。</li>
<li><code>\s</code> 表示空白符，包含 <code>tab</code> 和换行符。</li>
<li><code>\D</code> 代表非数字字符，其它以此类推。</li>
<li><code>.</code> 代表任意字符（不包括换行符）。</li>
<li><code>^</code> 表示从行首开始匹配，<code>$</code> 表示从行尾开始匹配。<ul>
<li>如 <code>^a</code> 表示只匹配行首的 <code>a</code>，<code>a$</code> 只匹配行尾的 <code>a</code>。</li>
</ul>
</li>
<li><code>+?</code> 会将匹配模式由默认的尽可能多的匹配变成尽可能少的匹配。</li>
<li><code>\b</code> 表示单词字符的边界。</li>
</ul>
<p><strong>小例子：</strong></p>
<ul>
<li>匹配十六进制色值：<code>/#[a-fA-F0-9]&#123;6&#125;\b/gm</code></li>
<li>匹配 <code>IPV4</code> 地址：<code>/\b((25[0-5]|2[0-4]\d|[01]?\d\d?)\.)&#123;3&#125;(25[0-5]|2[0-4]\d|[01]?\d\d?)\b/gm</code></li>
<li>匹配 vue 指令：<code>/^v-([\w-]+)$/</code></li>
</ul>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title>React Note</title>
    <url>/f139e650.html</url>
    <content><![CDATA[<blockquote>
<p>React 采用了一种全新的 JSX 格式，对原来 JS 的语法做了进一步的扩展，使你可以在里面使用 HTML 标签从而将它变成一个组件，它的组件化的设计理念与 Vue 有很多相似之处。</p>
</blockquote>
<h1 id="Basis"><a href="#Basis" class="headerlink" title="Basis"></a>Basis</h1><p>先说一下基础概念。</p>
<ul>
<li>**组件化(Component)**：和 Vue 基本相同，页面中所见皆是组件，不同的组件构成了一个页面。</li>
<li>**状态(State)**：状态是组件的数据，组件的显示内容可以根据状态的变化而变化。相当于 Vue 中的响应式变量。</li>
<li>**属性(Props)**：传递给组件的数据，相当于参数。</li>
</ul>
<p>不使用框架直接在 HTML 中使用可以引入两个 <code>script</code> 标签：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@18/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@18/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h1 id="State"><a href="#State" class="headerlink" title="State"></a>State</h1><p>状态，也就是 Vue 中的响应式数据。</p>
<p>直接修改状态的数据并不会导致页面更新，因为这个状态占用的内存地址没有发生改变，所以如果想要让页面更新，需要更新这个状态，用到 <code>setState</code> 方法：</p>
<div class="code-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">/* 调用父类的构造函数 */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>([arg1], [arg2])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以有两个参数：</p>
<ul>
<li>第一个参数：可以是对象或者函数，如果是对象则直接修改对应的键值，这里相当于将两个对象进行了合并，如果是函数则执行相应的操作。</li>
<li>第二个参数：回调函数，由于 <code>setState</code> 是一个异步操作，所以第二个参数就是在执行完成第一个参数后再执行的操作。</li>
</ul>
<p>在 React 的 HTML 标签中使用变量需要用到插值表达式，用花括号包裹即可，属性值是变量时不需要双引号包裹。</p>
<h1 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h1><p>先把根组件挂载到根元素上，这里在 <code>index.html</code> 中有一个 id 为 root 的元素，我们要把根组件挂载到这上面并渲染：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>)</span><br></pre></td></tr></table></figure></div>

<p><code>createRoot</code> 返回一个根对象，有一个 <code>render</code> 方法，可以将 React 组件渲染到页面。</p>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>类组件。</p>
<div class="code-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">/* 调用父类的构造函数 */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [component]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要有一个 <code>render</code> 方法来渲染组件，这个方法返回一个组件，组件只能由<strong>一个根元素包裹</strong>。有多行内容时，需要用小括号进行包裹。</p>
<p>但我们有时候并不想额外嵌套一个 <code>div</code> 标签，于是可以使用 <code>&lt;Fragment&gt;</code> 标签包裹，它不会被渲染，可以简写为 <code>&lt;&gt;&lt;/&gt;</code>。</p>
<p>组件挂载时会先执行 <code>render</code> 方法，因此不要有任何多余的操作。</p>
<p>只有状态值(state)或属性值(props)发生变化后才会触发重新渲染。</p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>函数组件。</p>
<div class="code-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要渲染什么直接 return 即可。</p>
<p>变量函数可以直接定义，但由于没有构造函数，需要使用 <code>useState()</code> 来初始化状态值。</p>
<div class="code-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title class_">React</span>.<span class="title function_">useState</span>([initValue]);</span><br></pre></td></tr></table></figure></div>

<p><code>useState()</code> 返回一个数组，第一个是初始化的状态值，第二个是设置这个状态值的函数，可以使用解构的方法得到。</p>
<p>这样使用变量就可以直接使用无需 <code>this.state</code>，修改只需要 <code>setState(newValue)</code> 而无需 <code>this.setState(&#123;key: newValue&#125;)</code>。</p>
<p>像极了 Vue 中的组合式 API 和选项式 API 之间的关系。</p>
<p>但是如果需要在挂载后执行 <code>fetch</code> 操作，可能会出现死循环，<code>fetch</code> 到数据后，状态修改，函数从头执行……</p>
<p>在类组件中我们可以使用生命周期方法，那函数组件呢？</p>
<p>这里需要使用 <code>useEffect</code>，<code>useEffect</code> 是 React 中的一个 Hook，用于在函数组件中处理副作用（side effects）。副作用是指那些在组件渲染过程中需要执行但不直接产生 UI 的代码，比如数据获取、订阅、手动修改 DOM、记录日志等。</p>
<p>第一个参数是要执行的函数，函数可以返回一个函数，作为清理函数；</p>
<p>第二个参数是一个依赖数组，如果为空代表只执行一次；如果没有那么每次渲染都会执行；如果数组包含一个或多个变量，那么会在依赖发生变化时才会执行。</p>
<p>函数组件的参数就是用来接收 props 的，也是一个对象。</p>
<h1 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h1><h2 id="style"><a href="#style" class="headerlink" title="style"></a>style</h2><p>可以在元素中添加 <code>style</code> 属性，但是属性值需要是一个对象，而由于变量需要用花括号包裹，所以需要用到两个花括号。</p>
]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu Configuration Diary</title>
    <url>/f24024d4.html</url>
    <content><![CDATA[<h1 id="Pre-Info"><a href="#Pre-Info" class="headerlink" title="Pre-Info"></a>Pre-Info</h1><p>一年前在移动硬盘上安装了 Ubuntu22.04，但也仅仅是安装，并没有使用，吃灰了几个月后被我清理。</p>
<p>最近有移动使用的需求，哪怕是在 100W PD充电的低功耗模式情况下，Windows11 的资源调度也是相当激进的，在同时打开 Edge、Vscode、Obsidian 和网易云音乐时风扇还是会转（图书馆里有点小吵），温度五六十度吧。</p>
<p>听说 Linux 负载小，那就换来试试，正好我也爱折腾这些。</p>
<p>于是三天过去了……</p>
<p>先看成果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202407191720315.webp"
                     
                ></p>
<p>在这个过程中，有几个能力是必不可少的：</p>
<ul>
<li>阅读文档</li>
<li>Google 英文搜索</li>
<li>ChatGPT 的辅助</li>
<li>看报错信息</li>
</ul>
<p>没办法，如此一个不算热门的领域，想要找到高质量且有体系的易懂的信息，很难很难。</p>
<p>最好的信息当属官方文档，当然全都是英文，需要较强的英文阅读能力。</p>
<p>文档不好啃，我有时候选择把它丢给 GPT 让它帮我分析然后通过文档回答我的问题。</p>
<p>其次中文语料的信息少得可怜，近年来中文互联网逐渐封闭化，越来越难以找到高质量的中文信息，之前全靠 CSDN，某乎，博客撑起一片天。用英文搜索的必要性日益显露。</p>
<p>最后就是看报错信息，日志之类的，大白话写得很清楚，就是全是英文的不好读，有问题也可以先去看看仓库的 Issue。</p>
<h1 id="Linux-Install"><a href="#Linux-Install" class="headerlink" title="Linux Install"></a>Linux Install</h1><blockquote>
<p>Ubuntu24.04 LTS</p>
</blockquote>
<p>准备一个 8GB 以上的 U盘，使用 rufus 制作启动盘。</p>
<p>在 BIOS 中改为以启动盘优先启动，这样就可以进入到 Ubuntu 的安装界面，接下去傻瓜操作即可。</p>
<p>分区手动配置：</p>
<p>正常来讲需要有这么几个分区：</p>
<ul>
<li><code>/</code> 根目录，相当于 C 盘。</li>
<li><code>/home</code>，相当于其它盘。</li>
<li><code>swap</code>，相当于虚拟内存。</li>
</ul>
<p>我的 RAM 是 16G，所以 <code>swap</code> 分区设置为 10G，<code>/</code> 设置 30G，<code>/home</code> 设置 60G，总共 100G。</p>
<p>但其实根本永不了这么多，<code>/home</code> 感觉 20～30G 就够用了。</p>
<p>听说现在 Linux 也可以安装 Steam 打游戏了，就是不知道兼容性怎么样。</p>
<p>震惊，预装 NVIDIA 显卡驱动！</p>
<blockquote>
<p>Linus 撤回了一个 Fu**</p>
</blockquote>
<h1 id="Apps-Install"><a href="#Apps-Install" class="headerlink" title="Apps Install"></a>Apps Install</h1><h2 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h2><p>Edge、Chrome 等浏览器不支持在 ROOT 用户下运行（出于安全考虑），我忘了我怎么解决这个问题了，没啥需求的话 FireFox、Opera 都挺好用的。</p>
<p>我尝试过的解决方向：</p>
<ul>
<li>按照网上教程修改配置文件 ❌</li>
<li>使用 Dev 版或者 Beta 版 ❌</li>
<li>创建其它用户，以非 ROOT 用户权限启动 ❓</li>
<li>把 <code>~/.config/microsoft-edge/</code> 下以 <code>singleton</code> 开头的文件删除 ❓</li>
<li>…</li>
</ul>
<p>反正最后解决了，stable 版的 Edge。</p>
<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p><a class="link"   href="https://obsidian.md/" >Obsidian<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> YYDS！</p>
<p>图床：<a class="link"   href="https://github.com/Molunerfinn/PicGo" >Picgo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><code>.snap</code> 格式的文件这样安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> snap install --dangerous [file_name]</span><br></pre></td></tr></table></figure></div>

<p>Picgo 插件无法安装的话，可以手动安装，</p>
<p>在 <code>~/snap/picgo/current/.config/picgo</code> 目录下使用 <code>npm install [picgo-plugin-name]</code> 即可。</p>
<p>安装 <code>npm</code> 和 <code>nvm</code> 以及 <code>node.js</code> 请自行搜索。</p>
<h2 id="Music"><a href="#Music" class="headerlink" title="Music"></a>Music</h2><p>没有好用的 Linux 版本的网易云音乐，于是改用 Spotify.</p>
<p>Snap 商店里就能下（就是自带的那个应用商店）。</p>
<p>但是有非常好用的第三方播放器，强烈推荐！</p>
<p><a class="link"   href="https://github.com/qier222/YesPlayMusic" >YesPlayMusic<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="Dev"><a href="#Dev" class="headerlink" title="Dev"></a>Dev</h2><ol>
<li>VScode 一键同步</li>
<li>NeoVim</li>
</ol>
<h2 id="Chat"><a href="#Chat" class="headerlink" title="Chat"></a>Chat</h2><p><a class="link"   href="https://github.com/lovechoudoufu/wechat_for_linux" >Wechat 下载链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>QQ 官网上有。</p>
<h2 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h2><p>ThunderBird</p>
<p>snap 商店可以下。</p>
<h1 id="Beautify"><a href="#Beautify" class="headerlink" title="Beautify"></a>Beautify</h1><h2 id="rEFInd"><a href="#rEFInd" class="headerlink" title="rEFInd"></a>rEFInd</h2><p>这个很早之前就做过了，只不过一直只有孤零零的一个 Windows 系统，还有点影响开机速度（毕竟没得选）。</p>
<p>配置教程 B 站有详细教程：<a class="link"   href="https://www.bilibili.com/video/BV1714y1c78z/" >链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>安装好 Linux 后直接出来四个图标，其中需要删掉两个不需要的，所以我们先不能安装主题，在默认主题下按 <code>del</code> 可以删除不需要的图标（前提是你得知道你要留哪些，这个可以试试）。</p>
<h2 id="Grub"><a href="#Grub" class="headerlink" title="Grub"></a>Grub</h2><p>安装 Linux 附赠的引导，只不过默认很丑只是 DOS 命令行。</p>
<p>进入 Linux，打开这个<a class="link"   href="https://www.gnome-look.org/browse?cat=109&ord=rating" >链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，</p>
<p>琳琅满目的 Grub Theme，挑一个喜欢的配置一下就好。</p>
<p>推荐这个：<a class="link"   href="https://github.com/vinceliuice/grub2-themes" >链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>按照仓库的教程安装即可。</p>
<p>这里可以安装一个 Grub Customizer，把 Grub 里多余的选项删除，</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install grub-customizer</span><br></pre></td></tr></table></figure></div>

<p>这样的坏处就是如果出问题你只能通过 <code>c</code> 使用命令行进入恢复模式了（好处是好看）。</p>
<h2 id="Gnome-Tweaks"><a href="#Gnome-Tweaks" class="headerlink" title="Gnome Tweaks"></a>Gnome Tweaks</h2><p>引导美化完了接下来该美化系统了。</p>
<p>Ubuntu 默认的图形化界面是 Gnome，我们可以安装 Gnome-Tweaks 来调整它的外观，不过最新的版本这个也是预装的，中文名称叫“优化”。</p>
<p>打开以后就可以调整字体，图标，主题等了，注意先不要调整鼠标指针为它自带的一些主题，可能缺失了什么文件，一选它就出 BUG，无法进入 GUI，只能对着 Grub 的命令行界面苦苦找寻解决方法一遍遍地试。</p>
<p>解决完这个问题以后我第一时间就去找了个喜欢的鼠标指针安装上。</p>
<h2 id="Cursor"><a href="#Cursor" class="headerlink" title="Cursor"></a>Cursor</h2><p>打开这个<a class="link"   href="https://www.gnome-look.org/browse?cat=107&ord=rating" >链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>是的没错还是这个网站，之后我们也会经常用到它。</p>
<p>下载后解压（图形界面双击压缩包就可以解压，再也不怕记错命令了）。</p>
<p>然后移动到 <code>~/.local/share/icons/</code> 目录下，然后在你的 <code>Tweaks</code> 里就可以看见它了。（看不到就重新打开一遍）</p>
<p>Icons 等其它选项也是同理，不过我没改，默认的都挺好。</p>
<h2 id="Dock"><a href="#Dock" class="headerlink" title="Dock"></a>Dock</h2><p>默认的底部 Dock 有点太丑了，使用 Dock 作为替代：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install plank</span><br></pre></td></tr></table></figure></div>

<p>安装后打开即可使用。</p>
<p>按住 <code>ctrl</code> 右键底部 Dock 中的图标，可以进入设置界面详细修改。</p>
<p>小部件如果不小心添加了，可以把它往上拖，它自己就没了。（当时找了半天也不知道怎么去掉）</p>
<p>此时 Plank 和 Ubuntu 自带的 Dock 会同时存在，怎么关掉自带的呢？</p>
<p>安装插件管理器（之后也要用到）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gnome-shell-extension-manager</span><br></pre></td></tr></table></figure></div>

<p>关掉 Ubuntu Dock 即可。</p>
<p>最后，在 Tweaks 中将 <code>Plank</code> 设置为开机自启。</p>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>默认的桌面主题中规中距，并不算好看。</p>
<p>在刚才安装的插件管理器中安装插件 <code>User Themes</code>。</p>
<p>打开<a class="link"   href="https://www.gnome-look.org/browse?cat=134&ord=rating" >链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>选一个喜欢的主题，下载，解压。</p>
<p>把主题文件复制到 <code>/home/fallingsakura/.local/share/themes/</code> 即可。</p>
<p><code>themes</code> 文件夹需要自己创建。</p>
<p>此时在 Tweaks 的外观中多出了一个 <code>shell</code> 选项，改为你想要的主题即可。</p>
<h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><p>炫酷的窗口动效！</p>
<p>在插件管理器中安装两个插件：</p>
<ul>
<li>Compiz alike magic lamp effect：暴风吸入式窗口最小化</li>
<li>Compiz windows effect：Q弹的窗口</li>
</ul>
<p>具体配置自己调整即可。</p>
<h2 id="Widgets"><a href="#Widgets" class="headerlink" title="Widgets"></a>Widgets</h2><p>桌面是很好看，但是感觉空荡荡的，加点小组件让它更好看吧！</p>
<p>效果图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202408191233291.webp"
                     
                ></p>
<p>（我的屏幕缩放比例比较低所以显得组件很小）</p>
<p>详细步骤看<a class="link"   href="https://blog.csdn.net/weixin_43268374/article/details/135755979" >这里<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="Zsh"><a href="#Zsh" class="headerlink" title="Zsh"></a>Zsh</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202407191727296.webp"
                      alt="image.png"
                ></p>
<p>美化命令行界面。</p>
<p>换为 zsh 命令行的 ohmyzsh 框架的 powerlevel10k 主题。</p>
<p>这几个关键词一艘教程一大把，在这里不过多赘述。</p>
<p>提几个注意事项：</p>
<ol>
<li>安装 <a class="link"   href="https://www.nerdfonts.com/" >Nerd 系列字体<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</li>
</ol>
<p>选一个自己喜欢的，安装。</p>
<p>然后在终端窗口右上角选择首选项，在配置栏中自己新建一个配置，把字体改为 Nerd 字体，否则一些图标不能正常显示。</p>
<p>这个在后续美化 NeoVim 的过程中也会用到，后面不再赘述。</p>
<ol start="2">
<li>切换系统语言为英文</li>
</ol>
<p>非必要，不知道为什么在中文语言系统下图形的 Unicode 编码渲染有问题，导致圆角、尖角等样式显示非常怪异（错位），最后切换语言解决了。</p>
<p>改变行高和字符宽度也会影响这个，看着调吧。</p>
<h2 id="NeoVim"><a href="#NeoVim" class="headerlink" title="NeoVim"></a>NeoVim</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202407191724952.webp"
                      alt="image.png"
                ></p>
<p>在 Ubuntu 24.04 为系统自带。</p>
<p>推荐 B 站<a class="link"   href="https://www.bilibili.com/video/BV1Td4y1578E/" >蛋老师的视频<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>从美化到配置一条龙服务，全程干货。</p>
<p>在他的基础上我修改了一些我自己需要的配置，比如不要烦人的 <code>swap file</code>、编译运行一些语言的快捷指令、<code>ctrl+w</code> 快捷关闭缓冲区等等。</p>
<div class="code-container" data-rel="Lua"><figure class="iseeu highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- options.lua</span></span><br><span class="line"><span class="keyword">local</span> opt = vim.opt</span><br><span class="line"></span><br><span class="line"><span class="comment">-- line number</span></span><br><span class="line">opt.relativenumber = <span class="literal">true</span></span><br><span class="line">opt.number = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- tab</span></span><br><span class="line">opt.tabstop = <span class="number">2</span></span><br><span class="line">opt.shiftwidth = <span class="number">2</span></span><br><span class="line">opt.expandtab = <span class="literal">true</span></span><br><span class="line">opt.autoindent = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--no-wrap</span></span><br><span class="line">opt.<span class="built_in">wrap</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--cursorline</span></span><br><span class="line">opt.cursorline = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--mouse</span></span><br><span class="line">opt.mouse:append(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--clipboard</span></span><br><span class="line">opt.clipboard:append(<span class="string">&quot;unnamedplus&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--newwindows</span></span><br><span class="line">opt.splitright = <span class="literal">true</span></span><br><span class="line">opt.splitbelow = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--search</span></span><br><span class="line">opt.ignorecase = <span class="literal">true</span></span><br><span class="line">opt.smartcase = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line">opt.termguicolors = <span class="literal">true</span></span><br><span class="line">opt.signcolumn = <span class="string">&quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- theme</span></span><br><span class="line">vim.cmd<span class="string">[[colorscheme catppuccin-frappe]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- foldenable</span></span><br><span class="line">vim.o.foldenable = <span class="literal">true</span></span><br><span class="line">vim.o.foldmethod = <span class="string">&#x27;manual&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- delete swapfile (anoying)</span></span><br><span class="line">vim.o.swapfile = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Compile &amp; Run Cpp</span></span><br><span class="line">vim.api.nvim_command(<span class="string">&#x27;command! CompileCpp !g++ % -o %:r&#x27;</span>)</span><br><span class="line">vim.api.nvim_command(<span class="string">&#x27;command! RunCpp !%:r&#x27;</span>)</span><br><span class="line">vim.api.nvim_command(<span class="string">&#x27;command! RunJs !node %&#x27;</span>)</span><br><span class="line">vim.api.nvim_command(<span class="string">&#x27;command! RunPy !python3 %&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Lua"><figure class="iseeu highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- keymaps.lua </span></span><br><span class="line">vim.g.mapleader = <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="keyword">local</span> keymap = vim.keymap</span><br><span class="line"></span><br><span class="line">keymap.set(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;:m &#x27;&gt;+1&lt;CR&gt;gv=gv&quot;</span>)</span><br><span class="line">keymap.set(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;K&quot;</span>, <span class="string">&quot;:m &#x27;&lt;-2&lt;CR&gt;gv=gv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- split vertical / horizonal</span></span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;sv&quot;</span>, <span class="string">&quot;&lt;C-w&gt;v&quot;</span>)</span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;sh&quot;</span>, <span class="string">&quot;&lt;C-w&gt;s&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- cancel hightlight</span></span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;ch&quot;</span>, <span class="string">&quot;:nohl&lt;CR&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- plugins</span></span><br><span class="line"><span class="comment">-- nvim-tree</span></span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;e&quot;</span>, <span class="string">&quot;:NvimTreeToggle&lt;CR&gt;&quot;</span>)</span><br><span class="line"><span class="comment">--buffer</span></span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;gt&quot;</span>, <span class="string">&quot;:bn&lt;CR&gt;&quot;</span>)</span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;gT&quot;</span>, <span class="string">&quot;:bp&lt;CR&gt;&quot;</span>)</span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;A-w&gt;&quot;</span>, <span class="string">&quot;:w | :bd | :bprevious&lt;CR&gt;&quot;</span>)</span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-s&gt;&quot;</span>, <span class="string">&quot;:w&lt;CR&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line">keymap.set(<span class="string">&quot;t&quot;</span>, <span class="string">&#x27;&lt;Esc&gt;&#x27;</span>, <span class="string">&#x27;&lt;C-\\&gt;&lt;C-n&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>各种语言的 LSP 也搞了好久，这方面的内容还没人做，我也只是略懂：</p>
<div class="code-container" data-rel="Lua"><figure class="iseeu highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lsp.lua</span></span><br><span class="line"><span class="keyword">local</span> servers = &#123;</span><br><span class="line">  <span class="string">&quot;lua_ls&quot;</span>,</span><br><span class="line">  <span class="string">&quot;volar&quot;</span>,</span><br><span class="line">  <span class="string">&quot;html&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tsserver&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cssls&quot;</span>,</span><br><span class="line">  <span class="string">&quot;clangd&quot;</span>,</span><br><span class="line">  <span class="string">&quot;vuels&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pyright&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pylsp&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;mason&quot;</span>).setup(&#123;</span><br><span class="line">  ui = &#123;</span><br><span class="line">      icons = &#123;</span><br><span class="line">          package_installed = <span class="string">&quot;✓&quot;</span>,</span><br><span class="line">          package_pending = <span class="string">&quot;➜&quot;</span>,</span><br><span class="line">          package_uninstalled = <span class="string">&quot;✗&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;mason-lspconfig&quot;</span>).setup(&#123;</span><br><span class="line">  <span class="comment">-- 确保安装，根据需要填写</span></span><br><span class="line">  ensure_installed = servers,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> capabilities = <span class="built_in">require</span>(<span class="string">&#x27;cmp_nvim_lsp&#x27;</span>).default_capabilities()</span><br><span class="line"><span class="keyword">local</span> lspconfig = <span class="built_in">require</span>(<span class="string">&quot;lspconfig&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- lspconfig.lua_ls.setup &#123;</span></span><br><span class="line"><span class="comment">--   capabilities = capabilities,</span></span><br><span class="line"><span class="comment">-- &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, lsp <span class="keyword">in</span> <span class="built_in">ipairs</span>(servers) <span class="keyword">do</span></span><br><span class="line">  lspconfig[lsp].setup &#123;</span><br><span class="line">    capabilities = capabilities,</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 防止 lua 报警告，看着烦人</span></span><br><span class="line">lspconfig.lua_ls.setup &#123;</span><br><span class="line">  settings = &#123;</span><br><span class="line">    Lua = &#123;</span><br><span class="line">      diagnostics = &#123; globals = &#123; <span class="string">&#x27;vim&#x27;</span> &#125;, &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>顺便学了一下 <code>lua</code>（</p>
<hr>
<p>NeoVim 中，使用 <code>:term</code> 即可进入终端模式，这是 Vim 所没有的。</p>
<p>退出终端模式原来是要 <code>ctrl+\</code> 然后 <code>ctrl+n</code>，嫌麻烦改成 ESC 了。</p>
<hr>
<p>建议全局将 Caps-Lock 和 ESC 交换，这个在 Tweaks 的键盘中，选额外设置，把 Caps-Lock 的行为中改为“交换 ESC 和 Caps-Lock“即可。</p>
<p>这个在 Vscode 的 Vim 插件中有点 BUG，需要先把全局键换回来在 VScode 中把快捷键改一下再换回去（不然在 VScode 里，点击改键，弹出框中你的 Caps-Lock 是 ESC，你的 ESC 还是 ESC，改不了一点）。</p>
<hr>
<p>有人要问了，既然 VScode 那么好用，IDE 也是现成的，甚至配置好的 Vim 也有现成的，何苦自己搞一个这么麻烦呢？</p>
<p>因为我随时可以修改它。</p>
<p>这是我的配置，独属于我的高度可定制化的配置，它是独一无二的。</p>
<p>无论是软件，还是系统，甚至是硬件。</p>
<p>最后是我这个人。</p>
<h1 id="Disk-Bug"><a href="#Disk-Bug" class="headerlink" title="Disk Bug"></a>Disk Bug</h1><p>可能会遇到插入移动硬盘无法挂载的问题，这个很好解决，在自带的硬盘管理中更改对应分区的挂载选项，取消默认的配置，自定义手动挂载即可。</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>没有总结，经过以上，你已经可以快乐地使用 Linux 进行日常使用和开发了，资源调度和占用真的很少，笔记本风扇几乎就没转过了。</p>
<p>很流畅，UI 很好看，喜欢。</p>
<p>Win11 以后就是专门拿来打游戏和做视频做渲染用的了。</p>
<p>以后看看把 Blender 和 Unity 也搬到 Linux 里。</p>
<p>有点想法再整一个 Arch Linux.</p>
<p>已经开始感觉头秃了。</p>
<p>To Be Continued…</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript Note</title>
    <url>/a4a6c774.html</url>
    <content><![CDATA[<blockquote>
<p>越来越像 c++ 了</p>
</blockquote>
<p>它是 JavaScript 的一个超集。</p>
<p>经过编译后变成 JavaScript 才可以在浏览器中运行。</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="自动识别类型"><a href="#自动识别类型" class="headerlink" title="自动识别类型"></a>自动识别类型</h2><div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line">num = <span class="string">&#x27;err&#x27;</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure></div>

<p>变量一经赋值，它的类型也就确定下来了，直接修改会报错。</p>
<h2 id="类型指定"><a href="#类型指定" class="headerlink" title="类型指定"></a>类型指定</h2><p>定义时我们便可以定义它的类型。</p>
<div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">numArr</span>: <span class="built_in">number</span>[]</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Arr</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt;</span><br><span class="line"><span class="comment">// equal</span></span><br></pre></td></tr></table></figure></div>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> result = numArr.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>) <span class="keyword">as</span> <span class="built_in">number</span></span><br><span class="line">result * <span class="number">5</span></span><br></pre></td></tr></table></figure></div>

<p>如果不加断言 <code>as number</code> 会导致错误，因为可能返回的值是 <code>undefined</code>，而 <code>undefined</code> 是不能进行数学运算的，如果我们确定它的值类型一定，便可以添加断言，这样就不会导致报错。</p>
<p>在 JavaScript  中，<code>undefined</code> 则会被当作 <code>NaN</code> 进行数学运算。</p>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>void<ul>
<li>值只有<code>undefined</code>，函数的类型</li>
</ul>
</li>
</ul>
<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>如果一个值可能有多个类型，定义时使用 <code>|</code> 隔开即可。</p>
<div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">v</span>: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure></div>

<p><code>null</code> 值默认可以分配给任意类型，开启严格配置后，只可以分配给 <code>null</code> 类型，所以需要通过这种方式声明一下。</p>
<p>也可以用它来限制取值，如：</p>
<div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">v</span>: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<p>这样它就只能取这三个值。</p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">t</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">number</span>?] = [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure></div>

<p>类似于数组，预定类型。</p>
<p>如果该值可选，加个问号即可。</p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">My</span> &#123;</span><br><span class="line">	A,</span><br><span class="line">	B,</span><br><span class="line">	C</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">My</span>.<span class="property">A</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">My</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></div>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">	<span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">Obj</span> = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Mytype</span> = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">Mytype</span></span><br></pre></td></tr></table></figure></div>

<h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> fn&lt;T&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: T): T[] &#123;</span><br><span class="line">	<span class="keyword">return</span> [a, b]</span><br><span class="line">&#125;</span><br><span class="line">fn&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="title function_">fn</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span> (<span class="params"><span class="attr">name</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span> (<span class="params"><span class="attr">age</span>: <span class="built_in">number</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">helllo</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span> + value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其实只保留最后一行函数定义也没问题，这样的好处是 vsc 会提示你函数结构。</p>
<h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">	<span class="attr">prop1</span>: <span class="built_in">string</span></span><br><span class="line">	<span class="attr">prop2</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">	<span class="attr">prop3</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h2><div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">	<span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">	<span class="attr">content</span>: <span class="built_in">string</span></span><br><span class="line">	<span class="title function_">constructor</span> (<span class="params"><span class="attr">title</span>: <span class="built_in">string</span>, <span class="attr">content</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">title</span> = title</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">content</span> = content</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="attr">_password</span>: <span class="built_in">string</span></span><br><span class="line">	<span class="keyword">get</span> <span class="title function_">password</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;*******&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">set</span> <span class="title function_">password</span>(<span class="params"><span class="attr">newPass</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">_password</span> = newPass</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> u = <span class="keyword">new</span> <span class="title class_">User</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(u.<span class="property">password</span>)</span><br><span class="line">u.<span class="property">password</span> = <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>可能不会被实例化，只是作为基类给其它类规范格式的。</p>
<div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="keyword">abstract</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">	<span class="keyword">abstract</span> <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">	haha?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;cat&#x27;</span></span><br><span class="line">	<span class="attr">color</span>: <span class="string">&#x27;orange&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>抽象类中可以有抽象属性，这样被子类继承时子类必须实现抽象属性，而非抽象属性子类可以正常继承使用。</p>
<h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">	<span class="keyword">get</span> <span class="title function_">sound</span>(): <span class="built_in">string</span></span><br><span class="line">	<span class="title function_">makeSound</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span> =<span class="string">&#x27;dog&#x27;</span></span><br><span class="line">	<span class="keyword">get</span> <span class="title function_">sound</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">makeSound</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以继承多个接口，逗号隔开即可，但不能继承多个类。</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><div class="code-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="attr">value</span>: T</span><br><span class="line">	<span class="title function_">constructor</span> (<span class="params"><span class="attr">value</span>: T</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">do</span> (<span class="attr">input</span>: T): T &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">		<span class="keyword">return</span> input</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">My</span> = <span class="keyword">new</span> <span class="title class_">MyClass</span>&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>与泛型函数类似。</p>
]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim Note</title>
    <url>/d32595a8.html</url>
    <content><![CDATA[
  <div class="note p-4 mb-4 rounded-small markdown-body info">
    <p>本文使用 Obsidian 的 Vim 模式写作。</p>

  </div>

<h2 id="什么是-Vim"><a href="#什么是-Vim" class="headerlink" title="什么是 Vim"></a>什么是 Vim</h2><blockquote>
<p>Vim是一个类似于<a class="link"   href="https://baike.baidu.com/item/Vi/5043202?fromModule=lemma_inlink" >Vi<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>的高度可定制的<a class="link"   href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/8853160?fromModule=lemma_inlink" >文本编辑器<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，在Vi的基础上改进和增加了很多特性。Vim是<a class="link"   href="https://baike.baidu.com/item/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6/405190?fromModule=lemma_inlink" >自由软件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。Vim普遍被推崇为类Vi编辑器中最好的一个，事实上真正的劲敌来自Emacs的不同变体。1999 年<a class="link"   href="https://baike.baidu.com/item/Emacs/0?fromModule=lemma_inlink" >Emacs<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>被选为Linuxworld文本编辑分类的优胜者，Vim屈居第二。但在2000年2月Vim赢得了<a class="link"   href="https://baike.baidu.com/item/Slashdot/1329225?fromModule=lemma_inlink" >Slashdot<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> Beanie的最佳<a class="link"   href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81/114160?fromModule=lemma_inlink" >开放源代码<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>文本编辑器大奖，又将Emacs推至二线。</p>
</blockquote>
<p>最近在学 Linux，不可避免地需要使用 Vim 进行一些代码编辑（Linux 系统自带的文本编辑器）。</p>
<p>感叹一下创造 Vim 的人的智慧。</p>
<p>鼠标是什么东西，我不知道。</p>
<p>码字效率++</p>
<p><a class="link"   href="https://vim.nauxscript.com/" >一个比较不错的教程文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="界面-移动"><a href="#界面-移动" class="headerlink" title="界面&#x2F;移动"></a>界面&#x2F;移动</h2><table>
<thead>
<tr>
<th align="center">Key</th>
<th align="center">Function</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>h</code></td>
<td align="center">Left</td>
</tr>
<tr>
<td align="center"><code>j</code></td>
<td align="center">Down</td>
</tr>
<tr>
<td align="center"><code>k</code></td>
<td align="center">UP</td>
</tr>
<tr>
<td align="center"><code>l</code></td>
<td align="center">Right</td>
</tr>
<tr>
<td align="center"><code>ctrl + y</code></td>
<td align="center">上一行</td>
</tr>
<tr>
<td align="center"><code>ctrl + e</code></td>
<td align="center">下一行</td>
</tr>
<tr>
<td align="center"><code>ctrl + u</code></td>
<td align="center">上半页（up）</td>
</tr>
<tr>
<td align="center"><code>ctrl + d</code></td>
<td align="center">下半页（down）</td>
</tr>
<tr>
<td align="center"><code>ctrl + b</code></td>
<td align="center">上一页（back）</td>
</tr>
<tr>
<td align="center"><code>ctrl + f</code></td>
<td align="center">下一页（forward）</td>
</tr>
<tr>
<td align="center"><code>H</code></td>
<td align="center">视口开头（Head）</td>
</tr>
<tr>
<td align="center"><code>M</code></td>
<td align="center">视口中央（Middle）</td>
</tr>
<tr>
<td align="center"><code>L</code></td>
<td align="center">视口结尾（Last）</td>
</tr>
<tr>
<td align="center"><code>G（]]）</code></td>
<td align="center">文件结尾</td>
</tr>
<tr>
<td align="center"><code>gg（[[）</code></td>
<td align="center">文件开头</td>
</tr>
<tr>
<td align="center"><code>x + G</code></td>
<td align="center">第 x 行</td>
</tr>
</tbody></table>
<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><table>
<thead>
<tr>
<th align="center">Key</th>
<th align="center">Function</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>$</code></td>
<td align="center">行尾</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">行首</td>
</tr>
<tr>
<td align="center"><code>0</code></td>
<td align="center">行最开头</td>
</tr>
<tr>
<td align="center"><code>w</code></td>
<td align="center">下一个单词的头部（word）</td>
</tr>
<tr>
<td align="center"><code>e</code></td>
<td align="center">下一个单词的尾部（end）</td>
</tr>
<tr>
<td align="center"><code>b</code></td>
<td align="center">上一个单词头部</td>
</tr>
<tr>
<td align="center"><code>ge</code></td>
<td align="center">上一个单词尾部</td>
</tr>
<tr>
<td align="center"><code>f + x</code></td>
<td align="center">当前行向后查找字符 x（选择 x）</td>
</tr>
<tr>
<td align="center"><code>3 + f + x</code></td>
<td align="center">当前行向后查找第三个字符 x</td>
</tr>
<tr>
<td align="center"><code>F + x</code></td>
<td align="center">当前行向前查找字符 x</td>
</tr>
<tr>
<td align="center"><code>t + x</code></td>
<td align="center">当前行向后查找字符 x（选择 x 前一个字符）</td>
</tr>
<tr>
<td align="center"><code>T + x</code></td>
<td align="center">当前行向前查找字符 x（选择 x 后一个字符）</td>
</tr>
<tr>
<td align="center"><code>（/）</code></td>
<td align="center">当前句子的首&#x2F;尾</td>
</tr>
<tr>
<td align="center"><code>&#123;/&#125;</code></td>
<td align="center">上&#x2F;下一个空行</td>
</tr>
<tr>
<td align="center"><code>%</code></td>
<td align="center">配对的括号</td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td align="center">跳转到与当前光标下单词匹配的下一个单词</td>
</tr>
<tr>
<td align="center"><code>#</code></td>
<td align="center">跳转到与当前光标下单词匹配的上一个单词</td>
</tr>
<tr>
<td align="center"><code>g + t</code></td>
<td align="center">下一个标签页</td>
</tr>
<tr>
<td align="center"><code>g + T</code></td>
<td align="center">上一个标签页</td>
</tr>
<tr>
<td align="center"><code>x + g + t</code></td>
<td align="center">第 x 个标签页</td>
</tr>
</tbody></table>
<h2 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h2><blockquote>
<p>一般而言数字加对应操作即将该操作重复多少次。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">Key</th>
<th align="center">Function</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>v</code></td>
<td align="center">选择</td>
</tr>
<tr>
<td align="center"><code>ctrl + v</code></td>
<td align="center">块状选择</td>
</tr>
<tr>
<td align="center"><code>shift + v</code></td>
<td align="center">行块选择</td>
</tr>
<tr>
<td align="center"><code>y</code></td>
<td align="center">复制</td>
</tr>
<tr>
<td align="center"><code>yy（Y）</code></td>
<td align="center">复制当前行</td>
</tr>
<tr>
<td align="center"><code>p</code></td>
<td align="center">粘贴（paste）到前面</td>
</tr>
<tr>
<td align="center"><code>P</code></td>
<td align="center">粘贴到后面</td>
</tr>
<tr>
<td align="center"><code>x</code></td>
<td align="center">删除（Backspace）</td>
</tr>
<tr>
<td align="center"><code>X</code></td>
<td align="center">删除（Delete）</td>
</tr>
<tr>
<td align="center"><code>&quot;_x</code></td>
<td align="center">删除，切不放入缓冲区</td>
</tr>
<tr>
<td align="center"><code>d + w</code></td>
<td align="center">删除当前词</td>
</tr>
<tr>
<td align="center"><code>d + 3 + w</code></td>
<td align="center">删除当前三个词</td>
</tr>
<tr>
<td align="center"><code>d + f + x</code></td>
<td align="center">删到当前行的 x 处（包括 x）</td>
</tr>
<tr>
<td align="center"><code>dd</code></td>
<td align="center">删除当前行</td>
</tr>
<tr>
<td align="center"><code>d + t + x</code></td>
<td align="center">删到当前行的 x 前一个字符处（不包括 x）</td>
</tr>
<tr>
<td align="center"><code>u</code></td>
<td align="center">撤销（undo）</td>
</tr>
<tr>
<td align="center"><code>ctrl + r</code></td>
<td align="center">重做</td>
</tr>
<tr>
<td align="center"><code>J</code></td>
<td align="center">合并当前行及下一行</td>
</tr>
</tbody></table>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>按下后进入输入模式。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">Key</th>
<th align="center">Function</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>i</code></td>
<td align="center">选择字符的前一位（insert）</td>
</tr>
<tr>
<td align="center"><code>I</code></td>
<td align="center">行首</td>
</tr>
<tr>
<td align="center"><code>a</code></td>
<td align="center">选择字符的后一位（append）</td>
</tr>
<tr>
<td align="center"><code>A</code></td>
<td align="center">行尾</td>
</tr>
<tr>
<td align="center"><code>o</code></td>
<td align="center">向下新建一行</td>
</tr>
<tr>
<td align="center"><code>O</code></td>
<td align="center">向上新建一行</td>
</tr>
<tr>
<td align="center"><code>s</code></td>
<td align="center">删除所选</td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center">删除当前行</td>
</tr>
<tr>
<td align="center"><code>c + 2 + l</code></td>
<td align="center">删除右边的两个字符</td>
</tr>
<tr>
<td align="center"><code>c + w</code></td>
<td align="center">删除当前词的光标及其右部分</td>
</tr>
</tbody></table>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table>
<thead>
<tr>
<th align="center">Key</th>
<th align="center">Function</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>:q</code></td>
<td align="center">退出</td>
</tr>
<tr>
<td align="center"><code>:w</code></td>
<td align="center">保存</td>
</tr>
<tr>
<td align="center"><code>:wq</code></td>
<td align="center">保存并退出</td>
</tr>
<tr>
<td align="center"><code>/ + str</code></td>
<td align="center">从当前位置向后搜索字符串 str</td>
</tr>
<tr>
<td align="center"><code>? + str</code></td>
<td align="center">从当前位置向前搜索字符串 str</td>
</tr>
<tr>
<td align="center"><code>n</code></td>
<td align="center">下一个</td>
</tr>
<tr>
<td align="center"><code>N</code></td>
<td align="center">上一个</td>
</tr>
<tr>
<td align="center"><code>:s/str1/str2/g</code>（<code>/</code> 分割或者 <code>#</code> 分割）</td>
<td align="center">当前行的所有 str1 替换为 str2</td>
</tr>
<tr>
<td align="center"><code>:%s/str1/str2/g</code></td>
<td align="center">文件中所有的 str1 替换为 str2</td>
</tr>
<tr>
<td align="center"><code>:10,20s/str1/str2/g</code></td>
<td align="center">10 到 20 行所有的 str1 替换为 str2</td>
</tr>
<tr>
<td align="center"><code>:.,+10s/str1/str2/g</code></td>
<td align="center">当前行与接下来 10 行 所有的 str1 替换为 str2</td>
</tr>
<tr>
<td align="center"><code>.</code></td>
<td align="center">重复上一个操作</td>
</tr>
<tr>
<td align="center"><code>~</code></td>
<td align="center">切换所选字母的大小写</td>
</tr>
</tbody></table>
<p>替换的 <code>/g</code> 为<strong>替换标志</strong>，代表所有（global），可以为空，那么就是从光标开始的第一次出现。<code>/i</code> 表示不区分大小写，<code>/I</code> 表示区分大小写。<code>/c</code> 表示需要确认。这些可以自由组合，比如 <code>/gci</code>。</p>
<h2 id="一图总结"><a href="#一图总结" class="headerlink" title="一图总结"></a>一图总结</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202405181708942.webp"
                      alt="|600"
                ></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>用 Vim 写 Markdown 并且还是中文其实真的很鸡肋。</p>
<p>中英输入法不断切换才能正常使用命令。</p>
<p>总结了一些我初学 Vim 常用的命令。</p>
<p>纸上得来终觉浅，绝知此事要躬行。</p>
<p>看不懂的地方就试试，很好理解。</p>
<p>希望对你有帮助。</p>
<p>🔚</p>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>DP</title>
    <url>/48659.html</url>
    <content><![CDATA[<blockquote>
<p>状态本质是图论中一个个点，转移对应一条条边</p>
<p>复杂度分析：状态数量 $\times$ 状态计算</p>
</blockquote>
<h1 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h1><ul>
<li>路径类</li>
<li>序列类</li>
<li>组合类</li>
</ul>
<h2 id="1-状态"><a href="#1-状态" class="headerlink" title="1.状态"></a>1.状态</h2><ul>
<li>题目中有很多状态，而这些状态间存在某些关系的题目。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303122107009.webp"
                      alt="image.webp"
                ></p>
<p>所谓状态，就是你当前处于哪个场景的概念。</p>
<p>比如我现在手里有六个骰子，</p>
<p>那么就有 ${6}\times{6}\times{6}$ 也就是 $216$ 种场景，</p>
<p>变量的组合便是状态。</p>
<h2 id="2-转移方程"><a href="#2-转移方程" class="headerlink" title="2.转移方程"></a>2.转移方程</h2><p>状态与状态之间的关系（点与点之间的边）。</p>
<p>要根据具体题目进行设计。</p>
<h3 id="典例"><a href="#典例" class="headerlink" title="典例"></a>典例</h3><ul>
<li>斐波那契数列</li>
</ul>
<p>这是最常见的一个递推。</p>
<p>那么怎么进行<code>DP</code>呢？</p>
<p>想想状态和什么有关系——当前这一项和前两项有关系，后两项与当前状态有关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303122117603.webp"
                      alt="image.webp"
                ></p>
<p>那么就有了<code>DP</code>的两种写法：</p>
<p>1.自己求别人</p>
<p>2.别人求自己</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303122120900.webp"
                      alt="image.webp"
                ></p>
<p>根据题目选择不同的  $\text{DP}$ 方式</p>
<h2 id="3-记忆化搜索"><a href="#3-记忆化搜索" class="headerlink" title="3.记忆化搜索"></a>3.记忆化搜索</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303161201695.webp"
                      alt="image.webp"
                ></p>
<p>复杂度 $O(N)$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303161204384.webp"
                      alt="image.webp"
                ></p>
<p>特征方程法解通项公式。</p>
<h2 id="闫式思考法"><a href="#闫式思考法" class="headerlink" title="闫式思考法"></a>闫式思考法</h2><h3 id="矩阵路线问题"><a href="#矩阵路线问题" class="headerlink" title="矩阵路线问题"></a>矩阵路线问题</h3><ul>
<li>状态表示<ul>
<li>$f_{i,j}$</li>
<li>表示一类<strong>集合</strong>：所有从 $(1,1)$ 到 $(i,j)$ 的路线。</li>
<li><strong>属性</strong>：最大值&#x2F;最小值&#x2F;方案数。</li>
</ul>
</li>
<li>状态计算<ul>
<li>集合的划分<ul>
<li>划分依据：<strong>最后</strong>，本例中为最后一步从上面下来还是从左边过来。<ul>
<li>从上边过来：$(1,1)\to(i-1,j)\to(i,j)$</li>
<li>从左面过来：$(1,1)\to(i,j-1)\to(i,j)$</li>
<li>两部分取一个 $\max$，分而治之，将集合进行一个划分。</li>
</ul>
</li>
<li>划分原则：<ul>
<li>不重（求最值等无所谓）</li>
<li><strong>不漏</strong></li>
</ul>
</li>
</ul>
</li>
<li>计算顺序<ul>
<li>按照拓扑序计算，保证每个状态计算时它的依赖状态已经被计算过了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>截图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310251414839.webp"
                      alt="image.png"
                ></p>
<p><a class="link"   href="https://www.acwing.com/problem/content/1029/" >方格取数<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310251442381.webp"
                      alt="image.png"
                ></p>
<h3 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h3><ul>
<li>状态表示<ul>
<li>集合：所有以 $a_i$ 结尾的严格单调上升子序列</li>
<li>属性：Max&#x2F;Min&#x2F;数量</li>
</ul>
</li>
<li>状态计算<ul>
<li>集合——分而治之。</li>
<li>通过<strong>最后一步</strong>划分：最后一步是 $a_i$</li>
</ul>
</li>
</ul>
<p><a class="link"   href="https://www.acwing.com/problem/content/1019/" >A1017<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>正序倒叙分别求两遍最长上升子序列取最大值即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[<span class="number">110</span>], f[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">                <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                    f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt; i; j--)</span><br><span class="line">                <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                    f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>状态划分<ul>
<li>先增后减，根据中间点分类。</li>
</ul>
</li>
</ul>
<p><a class="link"   href="https://www.acwing.com/problem/content/1016/" >A1014<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">1100</span>];</span><br><span class="line"><span class="type">int</span> g[<span class="number">1100</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt; i; j--)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                g[i] = <span class="built_in">max</span>(g[i], g[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i] + g[i] - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/1014/" >A1012 友好城市<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>两岸，一边看作自变量，一边看作因变量，在自变量不断递增的过程中，因变量也要是单调递增的，对自变量排下序，对因变量求最长上升子序列，这样就转化成了一个最长上升子序列问题。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line">PII q[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;q[i].first, &amp;q[i].second);</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(q[i].second &gt; q[j].second)</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/1018/" >A1016 最大上升子序列和<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ul>
<li>状态表示<ul>
<li>$f_i$</li>
<li>集合：所有以 $a_i$ 结尾的上升子序列</li>
<li>属性：和的最大值</li>
</ul>
</li>
<li>状态计算：倒数第二个数</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i ; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + a[i]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="导弹拦截"><a href="#导弹拦截" class="headerlink" title="导弹拦截"></a>导弹拦截</h3><ul>
<li>贪心流程：<ul>
<li>情况1：如果现有的子序列结尾都小于当前数，那么就创建新的子序列</li>
<li>情况2：把当前数放到结尾大于等于它的最小的子序列后面。因为要把结尾尽可能大的保持住，这样后面才会有更多的机会。</li>
</ul>
</li>
<li>证明贪心正确性<ul>
<li>如何证明两个数相等？<ul>
<li>A表示贪心算法得到的序列个数，B表示最优解 $A\le B,B\le A$</li>
<li>由于 B 是最优解，因此 $B\le A$</li>
<li>使用调整法，假设最优解对应的方案和当前方案不同，那么必然会存在第一个不同的位置。贪心法一定会把这个数分配到一个大于等于它的最小的子序列的后面，最优解也会放到某个序列后面，它们之后的序列就可以是一样的，就可以把它们交换，使得贪心法成为最优解，同时没有增加子序列的个数，所以 $A\le B$。</li>
<li>此题得证。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a class="link"   href="https://www.acwing.com/problem/content/1012/" >A1010<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; q[n]) n++;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(q[j] &gt;= q[i])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>; <span class="comment">// 枚举序列</span></span><br><span class="line">        <span class="keyword">while</span>(k &lt; cnt &amp;&amp; g[k] &lt; q[i]) k++;</span><br><span class="line">        g[k] = q[i]; <span class="comment">// 第一个结尾大于等于该数的序列 | g 是单调的</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt;= cnt) cnt++; <span class="comment">// 新开一个序列</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/189/" >A187<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>每个位置有两种选择，两种决策，要考虑所有情况，没办法归类，只能直接爆搜。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> up[N], down[N]; <span class="comment">// 所有子序列中最后一个数的集合</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 占用空间太大 并且不好剪枝</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> su, <span class="type">int</span> sd)</span> <span class="comment">// 当前枚举到第几个数 上升子序列有多少 下降子序列有多少</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(su + sd &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = su + sd; <span class="comment">// 能到就可以更新</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放到上升子序列里</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &lt; su &amp;&amp; up[k] &gt;= q[u]) k++; <span class="comment">// q[u] &gt; up[k] 且 up[k] 最大 | up数组单调递减</span></span><br><span class="line">    <span class="type">int</span> t = up[k]; <span class="comment">// 备份 方便恢复现场</span></span><br><span class="line">    up[k] = q[u];</span><br><span class="line">    <span class="keyword">if</span>(k &lt; su) <span class="built_in">dfs</span>(u + <span class="number">1</span>, su, sd);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">dfs</span>(u + <span class="number">1</span>, su + <span class="number">1</span>, sd);</span><br><span class="line">    up[k] = t;</span><br><span class="line">    <span class="comment">// 放到下降子序列里</span></span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &lt; sd &amp;&amp; down[k] &lt;= q[u]) k++; <span class="comment">// q[u] &lt; down[k] 且 down[k] 最小 | down数组单调递增</span></span><br><span class="line">    t = down[k];</span><br><span class="line">    down[k] = q[u];</span><br><span class="line">    <span class="keyword">if</span>(k &lt; sd) <span class="built_in">dfs</span>(u + <span class="number">1</span>, su, sd);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">dfs</span>(u + <span class="number">1</span>, su, sd + <span class="number">1</span>);</span><br><span class="line">    down[k] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; q[i];</span><br><span class="line">        ans = n;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><ul>
<li>状态表示<ul>
<li>$f_{i,j}$</li>
<li>集合：所有由第一个序列的前 $i$ 个字母，第二个序列的前 $j$ 个字母且以 $b_j$ 结尾的公共上升子序列</li>
<li>属性：最大长度</li>
</ul>
</li>
<li>状态计算<ul>
<li>分而治之，对每一个部分求最大值。</li>
<li>所有包含 $a_i$ 的公共上升子序列<ul>
<li>根据倒数第二个元素划分。</li>
<li>$f_{i,k}$</li>
</ul>
</li>
<li>所有不包含 $a_i$ 的公共上升子序列：$f_{i-1,j}$</li>
</ul>
</li>
<li>优化<ul>
<li>DP 的优化一般思路不变，只是对代码进行等价变形。</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310261903620.webp"
                      alt="image.png"
                ></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> maxv = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">// f[i][j] = max(f[i][j], 1); // 更新空集</span></span><br><span class="line">                <span class="comment">// for(int k = 1; k &lt; j; k++) // 实际上就是在求 f[i][j] + 1 的前缀最大值不含第 j 位</span></span><br><span class="line">                <span class="comment">//     if(b[k] &lt; a[i])</span></span><br><span class="line">                <span class="comment">//     &#123;</span></span><br><span class="line">                <span class="comment">//         f[i][j] = max(f[i][j], f[i][k] + 1);</span></span><br><span class="line">                <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">/* 等效代码 */</span></span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j], maxv);</span><br><span class="line">            <span class="keyword">if</span>(b[j] &lt; a[i]) maxv = <span class="built_in">max</span>(maxv, f[i - <span class="number">1</span>][j] + <span class="number">1</span>); <span class="comment">// 维护 f[i][j] + 1 这个变量的前缀最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="组合数问题（杨辉三角）"><a href="#组合数问题（杨辉三角）" class="headerlink" title="组合数问题（杨辉三角）"></a>组合数问题（杨辉三角）</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303161208890.webp"
                      alt="image.webp"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303161208268.webp"
                      alt="image.webp"
                ></p>
<h2 id="过河卒但是没有🐎"><a href="#过河卒但是没有🐎" class="headerlink" title="过河卒但是没有🐎"></a>过河卒但是没有🐎</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303262027794.webp"
                      alt="image.webp"
                ></p>
<p>每个点的方案数等于左边数和上边数相加（记得初始化边界）。</p>
<p>那么这个东西斜起来看的话其实就是杨辉三角。</p>
<h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><h3 id="正常版"><a href="#正常版" class="headerlink" title="正常版"></a>正常版</h3><p>洛谷上有道<a class="link"   href="https://www.luogu.com.cn/problem/P1434" >滑雪<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，</p>
<p>第$i$行有$i$个数，</p>
<p>每次可以朝下或者朝右下走，</p>
<p>那么从第一行走到最后一行怎么走会使路径上的数和最大，</p>
<p>$f[i][j]&#x3D;max(f[i-1][j-1],f[i-1][j])$。</p>
<p>还是要<strong>记得初始化</strong>。</p>
<hr>
<h3 id="EX版"><a href="#EX版" class="headerlink" title="EX版"></a>EX版</h3><p>附加条件：$%100$后最大</p>
<p>可以加一个条件，使得每个状态都$%100$？</p>
<p><code>NO</code></p>
<p>会破坏它的<strong>最优子结构</strong></p>
<p>判断<strong>最优子结构</strong>就是判断 DP 正确性的关键</p>
<p>也就是最优解不一定是用你所谓的最优解求出的</p>
<p><strong>重点来了</strong>：<code>DP</code>题中题目每多一个条件，状态都可以再加一个维度</p>
<p>$f[i][j][k]$：走到$i$，$j$，和$%100$为$k$这件事是否可能<code>(true/false)</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303262052130.webp"
                      alt="image.webp"
                ></p>
<h3 id="数字三角形3"><a href="#数字三角形3" class="headerlink" title="数字三角形3"></a>数字三角形3</h3><p>必须经过 ($\dfrac{n}{2}$, $\dfrac{n}{2}$) 这个点。</p>
<h3 id="数字三角形4"><a href="#数字三角形4" class="headerlink" title="数字三角形4"></a>数字三角形4</h3><p>必须先走到某个点再走到最底层</p>
<p>个人想法：</p>
<p>把这看作两个过程，相当于先以这个点为终点跑一遍数字三角形，然后再以这个点为起点再跑一遍数字三角形，两段相加即可。</p>
<h2 id="最长上升子序列（Longest-Increasing-Subsequence）"><a href="#最长上升子序列（Longest-Increasing-Subsequence）" class="headerlink" title="最长上升子序列（Longest Increasing Subsequence）"></a>最长上升子序列（Longest Increasing Subsequence）</h2><h3 id="1-求最长长度"><a href="#1-求最长长度" class="headerlink" title="1.求最长长度"></a>1.求最长长度</h3><p>$f[i]$ 代表 $i$ 必选且 $i$ 为最后一个数得到的最长上升子序列。</p>
<p>$f[i]$ 至少等于 $1$，因为至少选 $i$。</p>
<p>那么就可以求最长：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304011904860.webp"
                      alt="image.webp"
                ></p>
<h3 id="2-求方案数"><a href="#2-求方案数" class="headerlink" title="2.求方案数"></a>2.求方案数</h3><p>再开一个 $g[i]$，</p>
<p>$g[i]$代表以 $i$ 结尾最长的长度的方案数，</p>
<p>这是通解。</p>
<p>如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304011909916.webp"
                      alt="image.webp"
                ></p>
<p>遇到求方案数的问题都可以新开一个数组来记录方案数。</p>
<p>假如长度变长了，那么就 $g_i&#x3D;g_j$。</p>
<p>改一下写法的话就是像上图所示，如果是更新那就先置为0并且令它们相同，然后顺其自然的加上，相当于赋值了，而等于的情况正好也是加上，也就是稍微合并了一下操作。</p>
<h3 id="3-输出一种方案数"><a href="#3-输出一种方案数" class="headerlink" title="3.输出一种方案数"></a>3.输出一种方案数</h3><ul>
<li>再开一个数组$pre$记录每一个状态是从哪里走过来的。</li>
</ul>
<p>$pre[i]$&#x3D;0就是前面没东西了</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> f[<span class="number">10000</span>];<span class="comment">//f[i]代表i必选且i为最后一个数得到的最长</span></span><br><span class="line"><span class="type">int</span> g[<span class="number">10000</span>];<span class="comment">//g[i]代表最长的长度的方案数</span></span><br><span class="line"><span class="type">int</span> pre[<span class="number">10000</span>];<span class="comment">//上一个状态是从哪里走过来的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;<span class="comment">//至少为1</span></span><br><span class="line">        g[i]=<span class="number">1</span>;<span class="comment">//自己是一个方案</span></span><br><span class="line">        pre[i]=<span class="number">0</span>;<span class="comment">//前面没东西</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> l=f[j]<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l&gt;f[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i]=l;<span class="comment">//更新最长长度,一定会进入下一分支</span></span><br><span class="line">                    g[i]=<span class="number">0</span>;<span class="comment">//每周j的方案后面加上一个i长度不变</span></span><br><span class="line">                    pre[i]=j;<span class="comment">//更新i这个位置的状态是从j更新的</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(l==f[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    g[i]+=g[j];<span class="comment">//新的方案数就等于原来的方案数加上新的方案数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p,cnt=<span class="number">0</span>;<span class="comment">//从p开始走</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        z[++cnt]=p;</span><br><span class="line">        p=pre[p];</span><br><span class="line">    &#125;<span class="keyword">while</span>(p!=<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(z<span class="number">+1</span>,z+cnt<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>复杂度显然是$n^2$的。</p>
<h3 id="4-P2501"><a href="#4-P2501" class="headerlink" title="4.P2501"></a>4.P2501</h3><p><a class="link"   href="https://white.fallingsakura.top/adfe3b0c/" >题解<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="5-优化"><a href="#5-优化" class="headerlink" title="5.优化"></a>5.优化</h3><blockquote>
<p>要做到$nlogn$ ？</p>
</blockquote>
<h4 id="1-线段树"><a href="#1-线段树" class="headerlink" title="1.线段树"></a>1.线段树</h4><p>我们无非就是要<strong>在 $1\sim{i-1}$ 中找到一个 $j$ 使得 $a_j&lt;a_i$ 并且 $f[j]$ 最大</strong></p>
<p>那我们就建一颗线段树，范围 $1{\sim}m$</p>
<p>$m$ 是 $max({a_1}\sim{a_n})$，即所有数的最大值</p>
<p>假如 $a[j],f[j]$ 都知道了</p>
<p>进行一个单点修改</p>
<p>每次找到一个 $f[j]$ 就把它赋值给 $a_j$，</p>
<p>这样当前询问 $a_i$ 只需要询问 $1\sim a_i-1$ 区间中的最大值，</p>
<p>因为这样保证了之前的数都是小于 $a_i$ 的并且它们的 LIS 都已经求出。</p>
<p>询问的是什么？</p>
<p>从左向右扫的</p>
<p>询问的是所有小于 $a_i$ 的数</p>
<p>这样找到最大的 $f_j$</p>
<p>满足 $a_j&lt;a_j$</p>
<p>还取到 $a_j$ 的最大值</p>
<p>那么 $a[i]$ 就是 $f[j]+1$</p>
<h4 id="2-二分"><a href="#2-二分" class="headerlink" title="2.二分"></a>2.二分</h4><h5 id="插播一条二分"><a href="#插播一条二分" class="headerlink" title="插播一条二分"></a>插播一条二分</h5><blockquote>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/376467025" >关于c++的lower_bound与upper_bound函数的理解 )<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<p>当容器中的元素按照递增的顺序存储时，lower_bound函数返回容器中第一个<strong>大于等于</strong>目标值的位置，upper_bound函数返回容器中第一个<strong>大于</strong>目标值的位置。若容器中的元素都比目标值小则返回最后一个元素的下一个位置。($\ge$)</p>
<p>如果容器中的元素是递减的应该怎么查找呢？这是可以借助c++内置的仿函数greater<data_type>()，相当于重新定义了比较规则。此时lower_bound_()查找的是容器中第一个<strong>小于等于</strong>目标值的元素的位置，而upper_bound()查找的是容器中第一个<strong>小于</strong>目标值的元素的位置就。如果容器中的元素都比目标值大则返回最后一个元素的下一个位置。($&gt;$)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304020831502.webp"
                      alt="image.webp"
                ></p>
<p>详情见<a class="link"   href="https://white.fallingsakura.top/34778/#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97" >优先队列<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><p>现在存在两个位置$p1$和$p2$且$p_1&lt;p_2$、$a_{p_1}$&gt;$a_{p_2}$</p>
<p>$f[p_1]$$\le$$f[p_2]$</p>
<p>这意味着什么</p>
<p>这个$p_1$肯定是没有用的</p>
<p>$p_2$一定比$p_1$更优</p>
<p>这样就可以把$p_1$删掉了</p>
<p>栗子: <code>7 2 1 5 6 4 3 8 9</code></p>
<p>假如</p>
<p>$$f[7]&#x3D;f[2]&#x3D;1$$</p>
<p>那么<code>7</code>就没有用了</p>
<p>没用的就给去了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304012031358.webp"
                      alt="image.webp"
                ></p>
<p>在这里<code>4</code>可以把<code>5</code>给替换掉</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304012032524.webp"
                      alt="image.webp"
                ></p>
<p>在这里<code>4</code>又被替换成<code>3</code></p>
<p>我们发现什么问题？</p>
<p>这个创造出来的序列的第$i$个位置就是$f[i]$</p>
<p>比如$a_3$就是最长上升子序列为$3$的最小的那个（最优的）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202306102054543.webp"
                     
                ></p>
<p><code>cnt</code>代表新建出来的序列的大小</p>
<p>$a$代表建出来的序列</p>
<p>$a[3]&#x3D;f[a[3]]&#x3D;3$</p>
<p>但是这样做还是$n^2$的</p>
<p>$z[i]$存的是$f[i]$的下标</p>
<p>也就是$z[f[i]]&#x3D;i$</p>
<p>算出了$f[i]$那肯定就把$f[i]$放在新数组的第$f[i]$个位置</p>
<p>比如算出了$f[8]&#x3D;4$,那么新数组的第$4$个位置就是$4$</p>
<p>新数组就是$z[]$，它存的不是新的序列，而是新序列中每个数对应原序列的下标</p>
<p>答案就是$z_{1-cnt}$</p>
<p>$f[z[j]]&#x3D;j$</p>
<p>代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> z[<span class="number">233</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">233</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">233</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;<span class="comment">//f[i]中为序列下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)<span class="comment">//把循环变成二分就可以优化为 nlogn</span></span><br><span class="line">        <span class="comment">//枚举新序列中的数，更新f[i]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[z[j]]&lt;a[i])<span class="comment">//z[j]为f[]=j的数在a中的下标</span></span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],j<span class="number">+1</span>);<span class="comment">//枚举构造出的序列来更新这个f[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;cnt)<span class="comment">//新序列可以加，因为保证了构造出来的序列中第i位的f[]值为i，第cnt位置的f[]的值为cnt，那么加一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            z[cnt]=i;<span class="comment">//放入第cnt位数在a中的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;a[z[f[i]]])<span class="comment">//长度为f[i]的数在a中的下标，因为长度为f[i]和在z中下标为f[i]是等价的</span></span><br><span class="line">                z[f[i]]=i;<span class="comment">//存下标，拿比你小还比你强的来更新你</span></span><br><span class="line">            <span class="comment">//如果需要方案，就记录一下从哪转移过来的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202306102105149.webp"
                      alt="image.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304020802128.webp"
                      alt="image.webp"
                ></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;a[z[f[i]]]) z[f[i]]=i;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202306102106250.webp"
                      alt="image.png"
                ></p>
<p>这句就是把<code>5</code>给更新成<code>4</code></p>
<p>注意：这个新构造的序列并不是最长上升子序列，而是用来更新f[i]的</p>
<p>如果要方案的话就开个数组记录一下</p>
<p>但是这样解的个数不是很好算</p>
<h5 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h5><p>可以用二分查找找出小于<code>a[i]</code>的最大的那个位置</p>
<p>加入一个二分替代枚举就可以达到$nlog_n$</p>
<p>因为新构造的序列是按照<code>f[]</code>值单调递增的</p>
<p>所以我们只需要每次二分查找一个小于当前<code>a[i]</code>的最大的数就可以了</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+50</span>;</span><br><span class="line"><span class="type">int</span> z[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ef</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span><span class="comment">//l,r为z下标，k为a中下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r<span class="number">+1</span>)&gt;&gt;<span class="number">1</span>;<span class="comment">//右中位数</span></span><br><span class="line">        <span class="keyword">if</span>(a[z[mid]]&lt;a[k])</span><br><span class="line">            l=mid;<span class="comment">//l=mid,保证l永远小于，满足条件</span></span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;<span class="comment">//缩小右区间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;<span class="comment">//f[i]中为序列下标</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;ef(1,cnt,i)&lt;&lt;endl;</span></span><br><span class="line">        f[i]=<span class="built_in">max</span>(f[i],<span class="built_in">ef</span>(<span class="number">0</span>,cnt,i)<span class="number">+1</span>);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for(int j=1;j&lt;=cnt;j++)//把循环变成二分就可以优化为 nlogn</span></span><br><span class="line"><span class="comment">        //枚举新序列中的数，更新f[i]</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if(a[z[j]]&lt;a[i])//z[j]为f[]=j的数在a中的下标</span></span><br><span class="line"><span class="comment">                f[i]=max(f[i],j+1);//枚举构造出的序列来更新这个f[i]</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;cnt)<span class="comment">//新序列可以加，因为保证了构造出来的序列中第i位的f[]值为i，第cnt位置的f[]的值为cnt，那么加一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            z[cnt]=i;<span class="comment">//放入第cnt位数在a中的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;a[z[f[i]]])<span class="comment">//长度为f[i]的数在a中的下标，因为长度为f[i]和在z中下标为f[i]是等价的</span></span><br><span class="line">                z[f[i]]=i;<span class="comment">//存下标，拿比你小还比你强的来更新你</span></span><br><span class="line">            <span class="comment">//如果需要方案，就记录一下从哪转移过来的,在发生转移的时候记录一下pre</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cnt即为最长上升子序列的长度</span></span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=cnt;i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d &quot;,a[z[i]]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d &quot;,a[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,n-cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><del>二分真的很难调</del></p>
<p>简单解释一下吧，</p>
<p>现在保证左端点满足条件，</p>
<p>不断微调右端点，</p>
<p>二分到最后让右端点与左端点合并，</p>
<p>而最后遇到相邻的情况，</p>
<p>mid要取右中位数（也就是如果是两个相邻的数，在取整的过程中取右端点）。</p>
<p><del>具体是不是这样我也说不清。</del></p>
<p>以上做法可以A掉<a class="link"   href="https://www.luogu.com.cn/problem/P3902" >P3902<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="滑雪："><a href="#滑雪：" class="headerlink" title="滑雪："></a>滑雪：</h3><blockquote>
<p>一个 $n$ 行 $m$ 列的网格图，每个格子有一个高度，只能滑向四周比自己矮的格子，任选起点，问最多能滑多远。</p>
</blockquote>
<p>从高往低滑和从低向高滑的答案是一样的。</p>
<p>用 $f_{i,j}$ 表示从 $i,j$ 出发的最长长度。</p>
<p>即 $f_{i,j}&#x3D;max(f_{x,y})+1$，其中 $x,y$ 为能滑到 $i,j$ 的格子。</p>
<p>就这样记忆化搜索。</p>
<p>可以将所有点的高度从小到大排序。</p>
<p>这一定是从排序后的数组的左边滑到右边。</p>
<p>那就可以从左向右进行 dp。</p>
<p>$f_i$ 代表滑到 $x_i,y_i$ 这个位置时的最长长度，然后枚举 $i$ 左边的数并且满足相邻（$|x_i-x_j|+|y_i-y_j|&#x3D;1$）的数中，$f$ 值最大的那个，把它加一就可以更新 $f_i$。</p>
<p>这样就可以保证转移是从左向右的，枚举 $i,j$ 就可以了。</p>
<p>最低点初始化为 0。</p>
<p>这个方法本质上就是拓扑排序+DP。</p>
<h3 id="乌龟棋"><a href="#乌龟棋" class="headerlink" title="乌龟棋"></a>乌龟棋</h3><p>在走的过程中，有六个变量在发生变化，其中五个可以用来表示状态，一个用来表示状态的值，即 $f_{i,a_1,a_2,a_3,a_4}$，其中第一维表示当前的位置，后面四维表示分别用了多少牌。</p>
<p>然后我们发现第一维其实没有必要，因为当前所在的位置可以通过后四维求解，于是就可以减少枚举，此谓之<strong>去除冗余状态</strong>。</p>
<p>至此的一些技巧：</p>
<ol>
<li>状态设计（每有一个变量对应一个维度）</li>
<li>增加维度</li>
<li>求方案数</li>
<li>改变枚举顺序</li>
<li>消除冗余状态</li>
</ol>
<h1 id="背包DP"><a href="#背包DP" class="headerlink" title="背包DP"></a>背包DP</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><ul>
<li>状态表示<ul>
<li>$f_{i,j}$</li>
<li>集合：所有只从前 $i$ 个物品中选，且总体积不超过 $j$ 的选法的集合。</li>
<li>属性：最大值&#x2F;最小值</li>
</ul>
</li>
<li>划分依据：用最后一步来划分。</li>
<li>状态计算：<ul>
<li>不选第 $i$ 个物品的所有方案</li>
<li>选第 $i$ 个物品的所有方案</li>
</ul>
</li>
</ul>
<p>有$n$件物品，一个背包，每个物品有重量和价值，在背包不超重的情况下，问得到价值的最大值。</p>
<ol>
<li>设计DP状态</li>
</ol>
<p>我们令$dp_{i,j}$代在前$i$个物品中进行选择，用了$j$的体积所得到的最大价值之和。</p>
<ol start="2">
<li>转移方程</li>
</ol>
<p>第$i$个物体重量为$w_i$，价值为$v_i$。</p>
<p>考虑完了前$i-1$件物品后，我们开始考虑第$i$件物品，这件物品可以选也可以不选，那么就可以在这两种情况中取较大值。</p>
<p><code>dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])</code></p>
<ol start="3">
<li>滚动优化</li>
</ol>
<p>我们发现更新第$i$个物品的时候只会用到第$i-1$行，之前的都相当于没有用了，所以就可以把第一维去掉，用旧状态代表$i-1$行，用新状态代表第$i$行，更新新状态的时候就是拿旧时的自己来更新现在的自己，根据转移方程，我们发现其实是拿体积较小的状态递推为体积较大的状态，所以我们更新的时候需要保留旧状态，所以从后向前遍历，这样就可以保证用来更新新状态的状态全部都是旧状态；若正向遍历，体积小的旧状态已经被更新为新状态，后面更新体积大的新状态会用被覆盖的新状态来更新，导致考虑了第$i$个物品后接着又考虑了第$i$个物品，这样就会导致每个物品会被拿多次（无穷背包）。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=w[i];j--)</span><br><span class="line">		f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure></div>

<p>第二层循环的终止条件为<code>j&gt;=a[i]</code>，因为之后无法转移，也就是无法装下第$i$件物品。</p>
<p><font color=#ec37a1><b>习题：</b></font></p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P1060" >P1060<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> x[N],f[N],v[N],p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;p[i]);</span><br><span class="line">        x[i]=v[i]*p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=v[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P1048" >P1048<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//背包：N个物品，背包体积为M，第i个物品价值为Wi，体积为Vi;</span></span><br><span class="line"><span class="comment">//Vi之和&lt;=M,使得价值最大，问：最大的价值之和; </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2005</span>];<span class="comment">//f[105][2005];</span></span><br><span class="line"><span class="type">int</span> w[<span class="number">100000</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">100000</span>];</span><br><span class="line"><span class="comment">//f[i][j]变化量：前i个物品已经选好了，此时用了j的体积 ，所能获得的最大价值；</span></span><br><span class="line"><span class="comment">//第i+1个物品放不放进背包？</span></span><br><span class="line"><span class="comment">//f[i][j]------&gt;f[i+1][j]</span></span><br><span class="line"><span class="comment">//转移f[i][j]-----&gt;f[i+1][j+Vi+1];+Wi+1;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n;<span class="comment">//背包大小 </span></span><br><span class="line">	cin&gt;&gt;m;<span class="comment">//药物数目 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;=m;i++)//前i个物品已经决定好放不放进背包 ///O(nm)</span></span><br><span class="line"><span class="comment">//		for(int j=0;j&lt;=n;j++)//当前用了j的体积 </span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//		//考虑i+1放不放</span></span><br><span class="line"><span class="comment">//		//Yes </span></span><br><span class="line"><span class="comment">//			f[i+1][j+v[i+1]]=max(f[i+1][j+v[i+1]],f[i][j]+w[i+1]); </span></span><br><span class="line"><span class="comment">//		//if(j&gt;=v[i])////判断数组越不越界,如果不越界，那么可以选第i个 </span></span><br><span class="line"><span class="comment">//		//	f[i][j]=max(f[i-1][j]//不选第i个,f[i-1][j-v[i]]+w[i]//选第i个);</span></span><br><span class="line"><span class="comment">//		//No</span></span><br><span class="line"><span class="comment">//			f[i+1][j]=max(f[i+1][j],f[i][j]);//待写</span></span><br><span class="line"><span class="comment">//		//else //不能选第i个 </span></span><br><span class="line"><span class="comment">//		//	f[i][j]=max(f[i][j],f[i-1][j]);////别人求自己 </span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	for(int j=1;j&lt;=n;j++)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		ans=max(f[m][j],ans);</span></span><br><span class="line"><span class="comment">////		cout&lt;&lt;f[m][j]&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//滚动数组优化，用新的覆盖旧的 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=v[i];j--)</span><br><span class="line">			f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">	cout&lt;&lt;f[n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="求方案数"><a href="#求方案数" class="headerlink" title="求方案数"></a>求方案数</h3><p>再开一个 $g_{i,j}$ 代表当前状态的方案数</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/11/" >A11<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0xc0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 容量恰好为 i 的最大价值</span></span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 的方案数</span></span><br><span class="line">    <span class="comment">// 注意题目要求的是不超过 i 体积 因此要找一个最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> maxv = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(maxv == f[j]) cnt += g[j];</span><br><span class="line">            <span class="keyword">if</span>(maxv == f[j - v] + w) cnt += g[j - v];</span><br><span class="line">            g[j] = cnt % MOD;</span><br><span class="line">            f[j] = maxv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span>(res == f[i])</span><br><span class="line">            cnt = (cnt + g[i]) % MOD;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="求方案"><a href="#求方案" class="headerlink" title="求方案"></a>求方案</h3><p>开一个 $pre_{i,j}$ 表示 $i,j$ 这个状态是由 $i-1$ 的哪个状态转移而来就好。</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/12/" >A12<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i + <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> j = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= v[i] &amp;&amp; f[i][j] == f[i + <span class="number">1</span>][j - v[i]] + w[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            j -= v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/1015/" >A1013<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">11</span>, M = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"><span class="type">int</span> w[N][M];</span><br><span class="line"><span class="type">int</span> way[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= j; k++)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k] + w[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> k = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++)</span><br><span class="line">            <span class="keyword">if</span>(f[i][k] == f[i - <span class="number">1</span>][k - j] + w[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                way[i] = j;</span><br><span class="line">                k -= j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; way[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h2><ul>
<li>状态表示<ul>
<li>$f_{i,j,k}$</li>
<li>集合：所有只从前 $i$ 个物品中选，并且总体积不超过 $j$ ，总重量不超过 $k$ 的所有选法。</li>
<li>属性：最大值</li>
</ul>
</li>
<li>状态计算<ul>
<li>最后一步：最后一个物品，要么包含要么不包含。</li>
<li>不包含：$f_{i-1,j,k}$</li>
<li>包含：$f_{i-1,j-v_i,k-m_i}+w_i$</li>
</ul>
</li>
</ul>
<h2 id="初始化分类"><a href="#初始化分类" class="headerlink" title="初始化分类"></a>初始化分类</h2><ul>
<li>初始化分类<ul>
<li>体积最多是 $j$<ul>
<li>方案数：$f_{0,i}&#x3D;1,i\in{[0,m]}\quad|\quad f_{1}&#x3D;1$</li>
<li>最大价值：$f_{i,k}&#x3D;0,i\in[0,n],k\in[0,m]\quad|\quad f_i&#x3D;0,i\in[0,m]$</li>
</ul>
</li>
<li>体积恰好是 $j$<ul>
<li>方案数：$f_{0,0}&#x3D;1\quad|\quad f_0&#x3D;1$</li>
<li>最大价值：$f_{0,0}&#x3D;0,f_{0,i}&#x3D;-\infty,i\in[1,\infty]\quad|\quad f_0&#x3D;0,f_i&#x3D;-\infty$</li>
<li>最小价值：$f_{0,0}&#x3D;0,f_{0,i}&#x3D;\infty,i\in[1,\infty]\quad|\quad f_0&#x3D;0,f_i&#x3D;\infty$</li>
</ul>
</li>
<li>体积至少是 $j$<ul>
<li>方案数：$f_{0,0}&#x3D;1\quad|\quad f_0&#x3D;1$</li>
<li>最小价值：$f_{0,0}&#x3D;0,f_{0,i}&#x3D;\infty,i\in[1,\infty]\quad|\quad f_0&#x3D;0,f_i&#x3D;\infty$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>从集合的角度考虑，考虑前 0 个物品且花费体积为 0 这一个元素，或者说是状态，在不同集合的定义中可以被划分到哪个集合，剩下的集合的状态是如何。</p>
<hr>
<p><a class="link"   href="https://www.acwing.com/problem/content/1022/" >AcWing1020 潜水员<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ul>
<li>状态表示<ul>
<li>集合：所有从前 $i$ 个物品中选，且氧气至少是 $j$，但其至少是 $k$ 的所有选法。</li>
<li>属性：最小值</li>
</ul>
</li>
<li>状态计算<ul>
<li>划分依据：最后一个物品的选择情况。</li>
<li>所有不含第 $i$ 个物品的所有选法：$f_{i-1,j,k}$</li>
<li>所有包含第 $i$ 个物品的所有选法：$f_{i-1,j-v_1,k-v_2}+w+i$</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">22</span>, M = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v1, v2, w;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = m; k &gt;= <span class="number">0</span>; k--) <span class="comment">// 至少是 j / k</span></span><br><span class="line">                f[j][k] = <span class="built_in">min</span>(f[j][k], f[<span class="built_in">max</span>(<span class="number">0</span>, j - v1)][<span class="built_in">max</span>(<span class="number">0</span>, k - v2)] + w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="无穷背包"><a href="#无穷背包" class="headerlink" title="无穷背包"></a>无穷背包</h2><p>按照直观的想法，那就再枚举一个 $k$  表示这个物品选多少个。</p>
<p>但这样复杂度是 $O(n^3)$ 的，所以考虑优化。</p>
<p>对比01背包，最大的不同就是它可以通过自己来更新自己，所以我们只需要在原来的基础上加上这样一句话：</p>
<p>它可以自己更新自己。</p>
<p>自己最初没选第 $i$ 个，然后可以选一个、两个、三个、四个……</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">-		<span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">+		<span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i][j-w[i]]+v[i]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<p>很简单，将滚动优化的第二维改为正向枚举即可，解释见上；</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=a[i];j&lt;=m;j++)</span><br><span class="line">		f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure></div>

<p>等效替换：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310270855546.webp"
                      alt="image.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310270855575.webp"
                      alt="image.png"
                ></p>
<h3 id="求方案数-1"><a href="#求方案数-1" class="headerlink" title="求方案数"></a>求方案数</h3><ul>
<li>状态表示<ul>
<li>集合：所有只从前 $i$ 个物品中选，且总体积恰好是 $j$ 的方案的集合。</li>
<li>属性：数量</li>
</ul>
</li>
<li>状态计算<ul>
<li>根据第 $i$ 个物品选几个来划分集合。</li>
<li>0 个：$f_{i-1,j}$</li>
<li>k 个：$f_{i-1,j-k\times v_i}$</li>
</ul>
</li>
</ul>
<p>$$<br>f_{i,j}&#x3D;f_{i-1,j}+f_{i-1,j-v_i\times{k}}<br>$$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310291102771.webp"
                      alt="image.png"
                ></p>
<p>这里可以直接替换。</p>
<p>$$<br>f_{i,j} &#x3D; f_{i-1,j}+f_{i,j-v}<br>$$</p>
<p>这是通过它们的层层递推关系得出的。</p>
<p><font color=#ec37a1><b>习题：</b></font></p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P1616" >P1616<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//w[i]价值</span></span><br><span class="line"><span class="comment">//v[i]花费</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000</span><span class="number">+5</span>,M=<span class="number">100000</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,m,w[N],v[N],f[N][M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;w[i],&amp;v[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=v[i])</span><br><span class="line">				f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i][j-v[i]]+w[i]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">		&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="有限背包"><a href="#有限背包" class="headerlink" title="有限背包"></a>有限背包</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P1776" >P1776 宝物筛选<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310270931176.webp"
                      alt="image.png"
                ></p>
<p>每次相当于求一个长度为 $s$ 的窗口的最大值，并且有 $w$ 的偏移量，这个可以通过一个单调队列来维护。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N], g[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        cin &gt;&gt; w &gt;&gt; v &gt;&gt; s;</span><br><span class="line">        <span class="built_in">memcpy</span>(g, f, <span class="built_in">sizeof</span>(f)); <span class="comment">// i - 1 的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; v; j++) <span class="comment">// 余数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>; <span class="comment">// 单调递减的单调队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j; k &lt;= m; k += v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh++; <span class="comment">// 队头超出了范围 出队</span></span><br><span class="line">                <span class="keyword">if</span>(hh &lt;= tt) f[k] = <span class="built_in">max</span>(f[k], g[q[hh]] + (k - q[hh]) / v * w); <span class="comment">// 滑动窗口每移动一点就有 w 的偏移量</span></span><br><span class="line">                <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt--; <span class="comment">// 弹出比它小的队尾</span></span><br><span class="line">                q[++tt] = k; <span class="comment">// 下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>与无穷背包相比，每个物品选取次数有一个上限。</p>
<p>老样子我们可以通过枚举第三维来解决，或者加维来做无穷背包怎么优化呢？</p>
<p>那就可以把这些不同种物品全部摊开，变成一个一个的物品，这样就变成01背包了。</p>
<p>但这样还是 $O(n^3)$ 的，我希望物品总数变少，可以把物品少拆一点，使得这个拆分满足选取若干数加起来可以等于 $0\sim{k}$ 中的任何一个数。</p>
<p>这样不管选多少个物品都可以通过拆分的这些数组合得到。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202308171640408.webp"
                      alt="image.png"
                ></p>
<p>比如这样，这样就可以把任何一个数拆分成 $logn$ 个数，这样就把复杂度优化为 $O(n^2logn)$。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, c;</span><br><span class="line"><span class="type">int</span> w[N], v[N], m[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> nw[N], nv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v[i], &amp;w[i], &amp;m[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m[i]; j &lt;&lt;= <span class="number">1</span>) <span class="comment">// 二进制拆分 将物品数降为 log 级别 即可自由组合出全部放方案</span></span><br><span class="line">        &#123;</span><br><span class="line">            m[i] -= j;</span><br><span class="line">            nw[++cnt] = w[i] * j;</span><br><span class="line">            nv[cnt] = v[i] * j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m[i])</span><br><span class="line">        &#123;</span><br><span class="line">            nw[++cnt] = w[i] * m[i];</span><br><span class="line">            nv[cnt] = v[i] * m[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = c; j &gt;= nw[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - nw[i]] + nv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[c] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="限制背包"><a href="#限制背包" class="headerlink" title="限制背包"></a>限制背包</h2><blockquote>
<p>$n$ 个物品，$m$ 体积的背包， $k$ 次询问，每次强制有一个物品不能选，问最大价值。<br>$n\le{10^5},m\le{100},k\le{1000}$</p>
</blockquote>
<p>我们注意 $m$ 很小，这是一个切入点。</p>
<p>先正常 DP 一遍，$f_{i,j}$ 表示前 $i$ 个物品用了 $j$ 的体积的最大价值。</p>
<p>再进行一次 DP，$g_{i,j}$ 代表 $i\sim{n}$ 已经考虑完了用了 $j$ 的体积的最大价值。</p>
<p>所以查询  $p_1$ 时，枚举体积 $a,b$ ，答案就是 $f_{p_1-1,a}+g_{p_1+1,b}$。</p>
<p>当前也可以分别维护一个前缀最大值，这查询的时候只需要枚举一个变量即可，如 $a,m-a$。</p>
<p>背包 DP 的本质是不断往里加物品，在加物品的 DP 里考虑删物品很不好做，那不如分为<strong>两段累加</strong>。</p>
<h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><p>分组背包，通俗的讲就是，给你$N$组物品，然后每一组你至多选择一个物品(<strong>也可以不选</strong>),每个物品都有自己的体积和价值，现在给你一个容里为M的背包，让你用这个背包装物品，使得物品价值总和最大。</p>
<p>那么就可以给它们编号了，然后定义一个数组来存储第$i$组第$j$个的编号，然后正常存储价值、重量等。</p>
<p>枚举时，第一维是组数，第二维是背包容量（从大到小），第三维是第$i$组的物品数，然后判断下是否能转移。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">f[j]=<span class="built_in">max</span>(f[j],f[j-w[p[i][k]]]+v[p[i][k]]);</span><br></pre></td></tr></table></figure></div>

<p><font color=#ec37a1><b>习题：</b></font></p>
<p><a class="link"   href="http://acm.hdu.edu.cn/showproblem.php?pid=1712" >HDU1712<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">13505</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1007</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> x,w[N],v[N],f[N],p[M][M],c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;       <span class="comment">/*编号做法仿照P1757*/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    while(cin&gt;&gt;n&gt;&gt;m)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(!n&amp;&amp;!m) break;</span></span><br><span class="line"><span class="comment">        int cnt=0;</span></span><br><span class="line"><span class="comment">        memset(w,0,sizeof(w));</span></span><br><span class="line"><span class="comment">        memset(v,0,sizeof(v));</span></span><br><span class="line"><span class="comment">        memset(f,0,sizeof(f));</span></span><br><span class="line"><span class="comment">        memset(c,0,sizeof(c));</span></span><br><span class="line"><span class="comment">        memset(p,0,sizeof(p));</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)//背包种数</span></span><br><span class="line"><span class="comment">            for(int j=1;j&lt;=m;j++)//物品编号</span></span><br><span class="line"><span class="comment">                scanf(&quot;%d&quot;,&amp;v[++cnt]),w[cnt]=j,p[i][++c[i]]=cnt;//记录第几组第几个的编号为i</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">            for(int j=m;j&gt;=0;j--)</span></span><br><span class="line"><span class="comment">                for(int k=1;k&lt;=c[i];k++)</span></span><br><span class="line"><span class="comment">                    if(j&gt;=w[p[i][k]])</span></span><br><span class="line"><span class="comment">                        f[j]=max(f[j],f[j-w[p[i][k]]]+v[p[i][k]]);</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;f[m]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//可以改成while(cin&gt;&gt;n&gt;&gt;m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">if</span>(!n&amp;&amp;!m) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i][j]);<span class="comment">//这里的p代表在i课程花j天学习所获得的价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举组数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)<span class="comment">//枚举背包体积</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)<span class="comment">//枚举每组的物体</span></span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=k)<span class="comment">//第k号物体的体积为k</span></span><br><span class="line">                        f[j]=<span class="built_in">max</span>(f[j],f[j-k]+p[i][k]);</span><br><span class="line">        cout&lt;&lt;f[m]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><p><a class="link"   href="https://www.acwing.com/problem/content/7/" >A7<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="number">0</span>) <span class="comment">// 完全</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = v; j &lt;= m; j++)</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s == <span class="number">-1</span>) s = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s; k &lt;&lt;= <span class="number">1</span>) <span class="comment">// 二进制优化</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= k * v; j--)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - k * v] + k * w);</span><br><span class="line">                s -= k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s) <span class="comment">// 剩余</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= s * v; j--)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - s * v] + s * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="依赖背包"><a href="#依赖背包" class="headerlink" title="依赖背包"></a>依赖背包</h2><p><a class="link"   href="https://www.acwing.com/problem/content/10/" >A10<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt, to;</span><br><span class="line">&#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].nxt = fir[u];</span><br><span class="line">    fir[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = fir[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> vv = e[i].to;</span><br><span class="line">        <span class="built_in">dfs</span>(vv);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m - v[u]; j &gt;= <span class="number">0</span>; j--) <span class="comment">// 根节点必选</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= j; k++)</span><br><span class="line">                f[u][j] = <span class="built_in">max</span>(f[u][j], f[u][j - k] + f[vv][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= v[u]; i--) f[u][i] = f[u][i - v[u]] + w[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v[u]; i++) f[u][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; p;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">-1</span>) root = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(p, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    cout &lt;&lt; f[root][m] &lt;&lt; endl; <span class="comment">// 跟节点的子树体积不超过 m 的最大价值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="能量石问题"><a href="#能量石问题" class="headerlink" title="能量石问题"></a>能量石问题</h2><p>分析方法类似国王游戏。</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/736/" >A734<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>吃第 $i$ 块花费的时间是 $s_i$ 秒，当时它的价值是 $E’_i$，每秒它将失去 $L_i$ 的价值。</p>
<p>那么我们在吃 $i$ 和 $i+1$ 的时候，考虑顺序。</p>
<p>假如先吃 $i$，那么得到的价值就是 $E’<em>i+E’</em>{i+1}-s_i\times{L_{i+1}}$</p>
<p>假如先吃 $i + 1$，那么得到的价值就是 $E’<em>i+E’</em>{i+1}-s_{i+1}\times{L_i}$</p>
<p>我们发现只有最后一项不同。</p>
<p>假如先吃 $i$ 更优，那么就说明 $s_i\times{L_{i+1}}&lt;s_{i+1}\times{L_i}$</p>
<p>所以我们可以按照 $\frac{s_i}{L_i}$ 从小到大排序，依次选即可。</p>
<ul>
<li>状态表示<ul>
<li>$f_{i,j}$</li>
<li>集合：所有只从前 $i$ 块能量石中选，且总体积（花费的时间）恰好是 $j$ 的方案</li>
<li>属性：最大值</li>
</ul>
</li>
<li>状态计算<ul>
<li>$f_{i,j}&#x3D;max(f_{i-1,j},f_{i-1,j-s_i}+E_i-(j-s_i)\times{L_i})$</li>
</ul>
</li>
</ul>
<p>注意这里由于要通过当前时间来计算能量石损耗了多少能量，所以我们的 $j$ 记录的是恰好为当前时间的状态。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s, e, l;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Stone &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> s * t.l &lt; t.s * l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;stone[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> C = <span class="number">1</span>; C &lt;= t; C++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s, e, l;</span><br><span class="line">            cin &gt;&gt; s &gt;&gt; e &gt;&gt; l;</span><br><span class="line">            m += s;</span><br><span class="line">            stone[i] = &#123;s, e, l&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(stone, stone + n);</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0xc0</span>, <span class="built_in">sizeof</span>(f)); <span class="comment">// 负无穷</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = stone[i].s, e = stone[i].e, l = stone[i].l;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= s; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - s] + e - (j - s) * l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, C, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="状态机模型"><a href="#状态机模型" class="headerlink" title="状态机模型"></a>状态机模型</h1><p>描述的是一个过程而非结果。</p>
<p>把点扩展成了一个过程。</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/1051/" >A1049<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>$f_i$ 表示抢劫前 $i$ 家店铺的最大收益。</p>
<p>正常转移：$f_i&#x3D;\max(f_{i-1},f_{i-2}+w_i)$</p>
<p>状态机分析：</p>
<p>先拆解状态为：$f_{i,0},f_{i,1}$ 表示未选最后一个店铺和选择最后一个店铺。</p>
<p>那么这个状态机最后的转移状态如图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310301553352.webp"
                      alt="image.png|300"
                ></p>
<p>每一步对应一个状态，会清晰很多。</p>
<p>状态机还对应着一个入口的概念，也就是初始化。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">8</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N], f[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, f[<span class="number">0</span>][<span class="number">1</span>] = -INF; <span class="comment">// 入口 不可能选第 0 家店铺 所以设为不合法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">max</span>(f[n][<span class="number">0</span>], f[n][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.acwing.com/problem/content/1059/" >A1057<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>对于股票对应两个过程：手中有货，手中无货。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310301611731.webp"
                      alt="image.png|300"
                ></p>
<ul>
<li>状态表示：<ul>
<li>$f_{i, j, 0}, f_{i, j, 1}$</li>
<li>集合：过完了前 $i$ 天，进行了 $j$ 次交易，并且手中没有&#x2F;有股票的状态。</li>
<li>假如手中有股票，那么就是处于第 $j$ 次交易。</li>
</ul>
</li>
<li>状态计算：<ul>
<li>$f_{i,j,0}&#x3D;\max(f_{i-1,j,0},f_{i-1,j,1}+w_i)$</li>
<li>$f_{i,j,1}&#x3D;\max(f_{i-1,j,1},f_{i-1,j-1,0}-w_i)$</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> f[N][M][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0xc0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j][<span class="number">1</span>] + w[i]);</span><br><span class="line">            f[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j][<span class="number">1</span>], f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[n][i][<span class="number">0</span>]); <span class="comment">// 完整的交易结束 此时手里无货</span></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.acwing.com/problem/content/1060/" >A1058<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ul>
<li>状态表示<ul>
<li>手中有货&#x2F;手中无货的第一天&#x2F;手中无货的非第一天。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310301935361.webp"
                      alt="image.png|500"
                ></li>
<li>入口：手中无货的非第一天。</li>
<li>出口：手中无货即可，那么算一个即可，但假如股票价格是单调下降的，那么最优解就是一次也不买，出口就是入口。</li>
<li>注意本题无交易次数。</li>
</ul>
</li>
<li>状态计算：<ul>
<li>$f_{i,0&#x2F;1&#x2F;2}$</li>
<li>$f_{i,0}&#x3D;\max(f_{i-1,0},f_{i-1,2}-w_i)$</li>
<li>$f_{i,1}&#x3D;f_{i-1,0}+w_i$</li>
<li>$f_{i,2}&#x3D;\max(f_{i-1,2},f_{i-1,1})$</li>
</ul>
</li>
<li>初始化：$f_{0,2}&#x3D;0,f_{0,1}&#x3D;f_{0,0}&#x3D;-\infty$<ul>
<li>负无穷代表不合法。</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">-0x3f3f3f3f</span>; <span class="comment">// 手中有货和 无货的第一天</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// 手中无货非第一天</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>] - w[i]);</span><br><span class="line">        f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + w[i];</span><br><span class="line">        f[i][<span class="number">2</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[n][<span class="number">1</span>], f[n][<span class="number">2</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.acwing.com/problem/content/1054/" >A1052<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>KMP 的过程中不能让它跳到最后一个状态。</p>
<p>每个位置有 26 条边，$m + 1$ 个状态。</p>
<ul>
<li>1:40:00 没听懂，复习 KMP 去了，等回来补听。</li>
</ul>
<h1 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h1><blockquote>
<p>在背包问题里，考虑的顺序是对答案没有影响的。<br>但是会存在某些题，物品的选择顺序对答案产生影响。<br>比如这次获得的实际价值是这次选择的物品价值与上一个物品价值异或和，那么<strong>选择顺序就会导致答案变化</strong>，就需要一种新的DP方式——状压DP。</p>
</blockquote>
<blockquote>
<p>状压DP的暴力做法一般是 $n!$ 复杂度的，比如枚举选择顺序的全排列。</p>
</blockquote>
<p>设 $f_{i,j}$ 代表上一个选的物品是 $j$，第一维用一个 $n$ 位的二进制数（$0\sim{n-1}$），这个二进制数第 $x$ 位代表第 $x$ 个物品选没选。</p>
<p>转移的时候看一下第 $i-1$ 位有没有选，没选我才能选上。</p>
<p>用二进制数代表物品选没选过，这个技巧叫做状态压缩。</p>
<p>还要考虑体积：当前用了 $k$ 的体积。</p>
<p>$f_{i,j,k}$ 代表选了哪些，上一个选的是 $j$，当前用了 $k$ 的体积所得到的最大价值，转移时考虑下一个选什么，编号 $0\le{r}\le{n}$。</p>
<p>选这个物品的条件是$((i&gt;&gt;r)&amp;1)&#x3D;0$</p>
<p>$f_{i|(1&lt;&lt;r),r,k+v_r}&#x3D;f_{i,j,k}+w_j\oplus{w_r}$</p>
<p>$i|(1&lt;&lt;r)$ 相当于把 $i$ 的第 $r$ 位赋为 1。</p>
<p>复杂度：</p>
<p>$O(2^n\times{n^2}\times{m})$</p>
<p>这个范围一般是 $n\in{18\sim{22}}$</p>
<h2 id="棋盘式（基于连通性）"><a href="#棋盘式（基于连通性）" class="headerlink" title="棋盘式（基于连通性）"></a>棋盘式（基于连通性）</h2><p><a class="link"   href="https://www.acwing.com/problem/content/1066/" >A1064<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ul>
<li>状态表示<ul>
<li>$f_{i,j,s}$</li>
<li>集合：所有只摆在前 $i$ 行，已经摆了 $j$ 个国王，且第 $i$ 行摆放的状态是 $s$ 的集合。</li>
<li>属性：方案数。</li>
</ul>
</li>
<li>状态计算<ul>
<li>已经摆完前 $i$ 排，且第 $i$ 排的状态是 $a$，第 $i - 1$ 排的状态是 $b$，已经摆了 $j$ 个国王的所有方案。</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">10</span>, K = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state;</span><br><span class="line"><span class="type">int</span> id[M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; head[M];</span><br><span class="line"><span class="type">int</span> cnt[M];</span><br><span class="line">LL f[N][K][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (((state &gt;&gt; i) &amp; <span class="number">1</span>) &amp;&amp; (state &gt;&gt; (i + <span class="number">1</span>)) &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += (state &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            state.<span class="built_in">push_back</span>(i);</span><br><span class="line">            id[i] = state.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// cnt[i] = count(i);</span></span><br><span class="line">            cnt[i] = __builtin_popcount(i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; state.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = state[i], b = state[j];</span><br><span class="line">            <span class="keyword">if</span>((a &amp; b) == <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(a | b))</span><br><span class="line">                head[i].<span class="built_in">push_back</span>(j); <span class="comment">// 可以转移的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; state.<span class="built_in">size</span>(); a++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> b : head[a])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> c = cnt[state[a]];</span><br><span class="line">                    <span class="keyword">if</span>(j &gt;= c)</span><br><span class="line">                    &#123;</span><br><span class="line">                        f[i][j][a] += f[i - <span class="number">1</span>][j - c][b];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    cout &lt;&lt; f[n + <span class="number">1</span>][m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/329/" >A327<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> can[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">15</span>][<span class="number">1</span> &lt;&lt; <span class="number">12</span>];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &amp; (s &lt;&lt; <span class="number">1</span>) || s &amp; (s &gt;&gt; <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span> (((s &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>) &amp;&amp; can[x][i] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; can[i][j];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; m); j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(i - <span class="number">1</span>, j))</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; m); k++)</span><br><span class="line">                    <span class="keyword">if</span> ((j &amp; k) == <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(i, k))</span><br><span class="line">                        f[i][k] = (f[i][k] + f[i - <span class="number">1</span>][j]) % MOD;</span><br><span class="line">    cout &lt;&lt; f[n + <span class="number">1</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"><span class="comment">// const int MOD = 1e8;</span></span><br><span class="line"><span class="comment">// const int N = 14, M = 1 &lt;&lt; 12;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int n, m;</span></span><br><span class="line"><span class="comment">// int g[N];</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; state;</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; head[M];</span></span><br><span class="line"><span class="comment">// int f[N][M];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bool check(int state)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     if(state &amp; (state &lt;&lt; 1) || state &amp; (state &gt;&gt; 1)) return false;</span></span><br><span class="line"><span class="comment">//     return true;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int main()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line"><span class="comment">//     for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">//         for (int j = 0; j &lt; m; j++)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             int t;</span></span><br><span class="line"><span class="comment">//             cin &gt;&gt; t;</span></span><br><span class="line"><span class="comment">//             g[i] += !t &lt;&lt; j;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     for (int i = 0; i &lt; (1 &lt;&lt; m); i++)</span></span><br><span class="line"><span class="comment">//         if(check(i))</span></span><br><span class="line"><span class="comment">//             state.push_back(i);</span></span><br><span class="line"><span class="comment">//     for (int i = 0; i &lt; state.size(); i++)</span></span><br><span class="line"><span class="comment">//         for (int j = 0; j &lt; state.size(); j++)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             int a = state[i], b = state[j];</span></span><br><span class="line"><span class="comment">//             if ((a &amp; b) == 0)</span></span><br><span class="line"><span class="comment">//             &#123;</span></span><br><span class="line"><span class="comment">//                 head[i].push_back(j);</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     f[0][0] = 1;</span></span><br><span class="line"><span class="comment">//     for (int i = 1; i &lt;= n + 1; i++)</span></span><br><span class="line"><span class="comment">//         for (int a = 0; a &lt; state.size(); a++)</span></span><br><span class="line"><span class="comment">//             for (int b : head[a])</span></span><br><span class="line"><span class="comment">//             &#123;</span></span><br><span class="line"><span class="comment">//                 if (g[i] &amp; state[a]) continue;</span></span><br><span class="line"><span class="comment">//                 f[i][a] = (f[i][a] + f[i - 1][b]) % MOD;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//     cout &lt;&lt; f[n + 1][0] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="旅行商问题（TSP）"><a href="#旅行商问题（TSP）" class="headerlink" title="旅行商问题（TSP）"></a>旅行商问题（TSP）</h2><blockquote>
<p>平面内有 $n$ 个点，问从 $1$ 号点出发把所有点都走一遍回到自己的最短路径。</p>
</blockquote>
<p>除了一号点，其它的点没有必要走两次。</p>
<p>设 $f_{i,j}$ 代表哪些点走过了，最后停留在 $j$ 号点的最短路径。</p>
<p>初始化为 $f_{1,0}&#x3D;0$，把编号改为 $0\sim{n-1}$。</p>
<p>然后枚举一个 $k$，表示最后停在 $j$，这一步是从 $j$ 走到 $k$。</p>
<p>所以 $f_{i|(1&lt;&lt;k),k}&#x3D;\min(f_{i,j}+dis_{j,k})$</p>
<h2 id="愤怒的小鸟（基于集合）"><a href="#愤怒的小鸟（基于集合）" class="headerlink" title="愤怒的小鸟（基于集合）"></a><a class="link"   href="https://www.luogu.com.cn/problem/P2831" >愤怒的小鸟<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>（基于集合）</h2><p>一共有 $n$ 个点，预处理出 $n^2$ 条抛物线和它们覆盖的点。</p>
<p>问题就转化为了给定若干条抛物线，用最少的抛物线覆盖所有的点。</p>
<p>这是一个<strong>重复覆盖问题</strong>，与之相对的还有<strong>精确覆盖问题</strong>，最优解法是 Dancing Links。</p>
<p>所以这题用状压实现一下。</p>
<p>用集合类型的状压 DP 优化爆搜。</p>
<p>爆搜：</p>
<ul>
<li>如果包含了所有列，更新全局最优解。</li>
<li>$state$ 存储哪一列已经被覆盖</li>
<li>任选没有被覆盖的一列 $x$</li>
<li>枚举所有能覆盖 $x$ 的抛物线。</li>
<li>更新 $state$</li>
</ul>
<h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>它是由小区间递推得到大区间的一种 DP 方式，可以先枚举长度，再枚举左端点得到右端点，也可以直接枚举左右端点。</p>
<p>但之间枚举左右端点要注意顺序问题，即大的左端点要先被枚举到：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j++)</span><br></pre></td></tr></table></figure></div>

<p>这样可以保证枚举到的区间的子区间之前一定更新过。</p>
<p>不过个人还是比较习惯：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="合并石子"><a href="#合并石子" class="headerlink" title="合并石子"></a>合并石子</h2><blockquote>
<p>有 $n$ 堆石子，每次选择相邻两堆合并，合并代价为两堆石子之和，要合并为一堆，求最小代价。</p>
</blockquote>
<p>它始终是连续的一段进行合并，不能进行跳跃。</p>
<p>所以可以设计 $f_{l,r}$ 代表把 $[l,r]$ 的石子合并为一堆的最小代价，答案就是 $f_{1,n}$。</p>
<p>初始化为 $f_{i,i}&#x3D;0$ ，那么怎么进行转移？</p>
<p>最后一次合并一定是把两堆石子合并为一堆石子，所以两堆石子之间一定有一个分界点，所以就枚举一个分界点 $k$ ，$f_{l,r}&#x3D;\min_{l\le{k}\le{r}}(f_{l,k}+f{k+1,r})+sum_{l,r}$。</p>
<p>区间DP的共性之一：状态有 $l$ 和 $r$。</p>
<p>大区间一定是由小区间转移而来的，所以我们要先求长度较小的区间，因此不能直接枚举 $l,r$ ，要<strong>枚举区间长度</strong>。</p>
<p>先枚举区间长度，再枚举 $l,r$，再枚举断点。</p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P1775" >石子合并（弱化版）<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+a[i];<span class="comment">//前缀和</span></span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f3f3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		f[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)<span class="comment">//当前处理长度为len的区间 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=n;r++,l++)<span class="comment">//长度为r-l+1 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">				f[l][r]=<span class="built_in">min</span>(sum[r]-sum[l<span class="number">-1</span>]+f[l][k]+f[k<span class="number">+1</span>][r],f[l][r]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>那么石子是环呢？</p>
<p>我们合并为一堆时，总会有一个地方是分界点，可以断环为链，枚举每一个分界点的答案即可。</p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P1880" >石子合并<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">+1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">		a[i]=a[i-n]; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">		f[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++) </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=<span class="number">2</span>*n;r++,l++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">				f[l][r]=<span class="built_in">min</span>(sum[r]-sum[l<span class="number">-1</span>]+f[l][k]+f[k<span class="number">+1</span>][r],f[l][r]);</span><br><span class="line">	<span class="type">int</span> ans=f[<span class="number">1</span>][n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=n;r&lt;=<span class="number">2</span>*n;l++,r++)</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,f[l][r]);</span><br><span class="line">	<span class="type">int</span> maxn,minn;</span><br><span class="line">	minn=ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=<span class="number">2</span>*n;r++,l++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">				f[l][r]=<span class="built_in">max</span>(sum[r]-sum[l<span class="number">-1</span>]+f[l][k]+f[k<span class="number">+1</span>][r],f[l][r]);</span><br><span class="line">	ans=f[<span class="number">1</span>][n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=n;r&lt;=<span class="number">2</span>*n;l++,r++)</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,f[l][r]);</span><br><span class="line">	maxn=ans;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>,minn,maxn);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><blockquote>
<p>分别有一堆矩阵 $M_1&#x3D;{a_1}\times{a_2},M_2&#x3D;{a_2}\times{a_3},M_3&#x3D;{a_3}\times{a_4},\cdots,M_n&#x3D;{a_n}\times{a_{n+1}}$。现在要把它们乘起来，两个矩阵相乘的代价，例如$M_1\cdot{M_2}&#x3D;a_1\times{a_2}\times{a_3}$，根据矩阵的结合律，求最小代价。</p>
</blockquote>
<p>类似于<a class="link"   href="https://www.luogu.com.cn/problem/P1063" >能量项链<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">220</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">+1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">        a[i]=a[i-n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n*<span class="number">2</span>;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=n*<span class="number">2</span>;l++,r++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                f[l][r]=<span class="built_in">max</span>(f[l][r],f[l][k]+f[k<span class="number">+1</span>][r]+a[l]*a[k<span class="number">+1</span>]*a[r<span class="number">+1</span>]);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="POJ2955-最长括号匹配"><a href="#POJ2955-最长括号匹配" class="headerlink" title="POJ2955 最长括号匹配"></a>POJ2955 最长括号匹配</h2><blockquote>
<p>从一个括号串中选出一个最长的子序列，使其满足括号匹配。</p>
</blockquote>
<p>$f_{l,r}$ 代表 $[l,r]$ 中最多能选出多少括号满足匹配。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">        s=a;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;end&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=len<span class="number">-1</span>;r&lt;n;l++,r++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                    f[l][r]=<span class="built_in">max</span>(f[l][r],f[l][k]+f[k<span class="number">+1</span>][r]);</span><br><span class="line">                <span class="keyword">if</span>(s[l]==<span class="string">&#x27;(&#x27;</span>&amp;&amp;s[r]==<span class="string">&#x27;)&#x27;</span>) f[l][r]=<span class="built_in">max</span>(f[l][r],f[l<span class="number">+1</span>][r<span class="number">-1</span>]<span class="number">+2</span>);</span><br><span class="line">                <span class="keyword">if</span>(s[l]==<span class="string">&#x27;[&#x27;</span>&amp;&amp;s[r]==<span class="string">&#x27;]&#x27;</span>) f[l][r]=<span class="built_in">max</span>(f[l][r],f[l<span class="number">+1</span>][r<span class="number">-1</span>]<span class="number">+2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[<span class="number">0</span>][n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="POJ1651-删数"><a href="#POJ1651-删数" class="headerlink" title="POJ1651 删数"></a>POJ1651 删数</h2><blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202308171108862.webp"
                      alt="image.png"
                ></p>
</blockquote>
<p>还是用 $f_{l,r}$ 表示删除区间 $[l,r]$ （<strong>除左右端点</strong>）的总代价，答案就是 $f_{1,n}$。</p>
<p>转移呢？</p>
<p>删除最后一个数 $k$ ，拿肯定是先把 $l\sim{k}$ 和 $k\sim{r}$ 之间的点都删光，</p>
<p>枚举一个中间点，$f_{l,r}&#x3D;\min_{l&lt;k&lt;r}(f_{l,k}+f_{k,r}+a_l\times{a_k}\times{a_r})$</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> a[N],f[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        f[i][i<span class="number">+1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">3</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=n;l++,r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l<span class="number">+1</span>;k&lt;r;k++)</span><br><span class="line">                f[l][r]=<span class="built_in">min</span>(f[l][r],f[l][k]+f[k][r]+a[l]*a[k]*a[r]);</span><br><span class="line">            <span class="comment">// printf(&quot;f[%d][%d]=%d\n&quot;,l,r,f[l][r]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="HDU4632-回文子序列"><a href="#HDU4632-回文子序列" class="headerlink" title="HDU4632 回文子序列"></a>HDU4632 回文子序列</h2><blockquote>
<p>给定一个字符串，求回文子序列的数量。</p>
</blockquote>
<p>对于一个区间 $[l,r]$ ，我在处理它的时候一定要保证它的子区间已经处理完了。</p>
<p>转移：$f_{l,r}&#x3D;f_{l+1,r}+f_{l,r-1}-f_{l+1,r-1}$</p>
<p>这就完了嘛？如果 $s_l&#x3D;s_r$，那么就是在原来 $[l,r]$ 的基础上又加了这么多，所以要再加上 $f_{l+1,r-1}$，而且两端点也形成了一个回文子序列，所以再加一。</p>
<p>于是总转移方程为：$f_{l,r}&#x3D;f_{l,r-1}+f_{l+1,r}-[s_l\not&#x3D;s_r]\times{f_{l+1,r-1}}$</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">10007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> t,n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=t;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s<span class="number">+1</span>);</span><br><span class="line">        n=<span class="built_in">strlen</span>(s<span class="number">+1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            f[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=n;l++,r++)</span><br><span class="line">                f[l][r]=(f[l][r<span class="number">-1</span>]+f[l<span class="number">+1</span>][r]-((<span class="type">int</span>)(s[l]!=s[r])*(f[l<span class="number">+1</span>][r<span class="number">-1</span>]))+(<span class="type">int</span>)(s[l]==s[r])+mod)%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>,k,f[<span class="number">1</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="凸多边形"><a href="#凸多边形" class="headerlink" title="凸多边形"></a>凸多边形</h2><blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202308171157448.webp"
                      alt="image.png"
                ></p>
<p>一个 $n$ 边形是可以切成 $n-2$ 个三角形，每个三角形的权值是它的三个顶点的点权之积，求最小权值和。</p>
</blockquote>
<p>三角形是通过切割得来的。</p>
<p>断环为链，拷贝几份，假如一个凸八边形，那么$f_{1,9}&#x3D;f_{1,5}+f_{5,9}$，其中 $a_1&#x3D;a_9$。</p>
<p>$f_{i,j}&#x3D;f_{i,k}+f_{k,j}$</p>
<p>当这个区间被划分到三个点的时候单独算一下就好了。</p>
<h1 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h1><p>始终从叶子向根节点做 DP。</p>
<p>在每个节点时聚合所有儿子的信息，可能需要多遍 dfs&#x2F;bfs 。</p>
<h2 id="点数"><a href="#点数" class="headerlink" title="点数"></a>点数</h2><blockquote>
<p>一个 $n$ 个点的树，问这个树有多少个点？</p>
</blockquote>
<p><del>很显然是n。</del></p>
<p>考虑用树形 DP 来解决这个问题。</p>
<p>树形DP的**第一个维度一般是 $f_i$**，代表以 $i$ 为根的子树。</p>
<p>在这里表示以 $i$ 为根的子树有多少个点。</p>
<p>所以我们要求的就是 $f_1$。</p>
<p>初始化？我们需要把所有叶子节点的子树大小初始化为 $1$。</p>
<p><strong>初始化的一般是叶子节点</strong></p>
<p>转移？<strong>由儿子向父亲转移，把所有儿子的信息合在一起</strong>。</p>
<p>$f_u&#x3D;\sum{f_v}+1$</p>
<p>树形 DP 的时候我们一般会进行 DFS，同时记录当前点和它的父亲。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(e[i].to,u);</span><br><span class="line">            f[u]+=f[v];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="直径"><a href="#直径" class="headerlink" title="直径"></a>直径</h2><blockquote>
<p>求树的直径，直径定义为树上两个最远距离的点的路径。 </p>
</blockquote>
<p>树的直径无非是树上的两条链，而树上的一条链我们可以怎样表示？</p>
<p>假设从 $p_1$ 走到 $p_2$ ，那肯定是先走到它们的 $lca$ 再走到另一个点。</p>
<p>而对于一个点我只需要向下找两条尽量长的路径，拼起来就是以这个点为拐点的最长路径，这样对每个点的最长路径取一个 $max$ 就可以了。</p>
<p>那么怎么对每一个点都找到这样一条最长路径呢？</p>
<p>求以 $i$ 点出发向下的最长路和次长路，分别用 $f_i$ 和 $g_i$ 来表示。</p>
<p>对于叶子节点，两个量都是 0。</p>
<p>转移？</p>
<p>$f_i&#x3D;max(f_{p_j})+1$，$g_i$呢？，假如先走了 $p_3$ ，那么次长路就一定不能是 $p_3$ 因为这样就把 $i\leftrightarrow{p_3}$ 走了两遍，所以 $g_i&#x3D;second_max(f_{p_j})+1$</p>
<p>最后的答案为 $max(f_i+g_i)$</p>
<p>复杂度为 $O(n)$</p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><blockquote>
<p>求树上所有路径长度和</p>
</blockquote>
<p>$f_i$ 表示以 $i$ 为根节点的子树的路径和，叶子节点为0，转移？没法转移，因为会有跨越不同子树的路径，还要维护一个 $g_i$ 表示所有点到根节点的距离之和。</p>
<p>$g_{p_1}+siz_{p_1}$ 就是所有点到 $i$ 的路径长度之和，它们到其它子树也要算上，也就是 $(g_{p_1}+siz_{p_1})\times(siz_i-siz_{p_1})$ ，因为这跳路径会被算这么多次。</p>
<p>所以：</p>
<p>$$<br>f_i&#x3D;\sum_{j\in{son_i}}f_{p_j}+(g_{p_j}+siz_{p_j}\times{val_{i\leftrightarrow{j}}})\times(siz_i-siz_{p_j})<br>$$</p>
<p>但是这样太复杂了，怎么优化呢？</p>
<p>其实我们只需要 DP 一个东西： $siz_i$</p>
<p>这个就已经足够了。</p>
<p>答案式：</p>
<p>$$<br>\sum_{i&#x3D;2}^n{siz_i\times{n-siz_i}\times{2}}<br>$$</p>
<p>刚才我们是以点的角度考虑的，不妨换一种角度，考虑每条边。</p>
<p>考虑有多少条路径包含了这条边，这条边的左边有一个子树，在这个子树内任意一个点出发，以这个子树外任意一点为终点，都会经过这条边，而起点和终点又可以交换，所以是这些。<strong>注意不包含根节点，因为我们实际考虑的是边的贡献</strong>。</p>
<h2 id="树的最大独立集"><a href="#树的最大独立集" class="headerlink" title="树的最大独立集"></a>树的最大独立集</h2><blockquote>
<p>问一个树最多能取出多少个点使得这些点都不相邻。</p>
</blockquote>
<p>状态为 $f_{i,0&#x2F;1}$ 代表第 $i$ 个点选&#x2F;不选时子树最大独立集的大小。</p>
<p>初始化的话就是对于每个叶子节点，$f_{i,0}&#x3D;0,f_{i,1}&#x3D;1$</p>
<p>那么转移呢？</p>
<p>如果 $i$ 这个点选了，那么它所有的儿子都不能选，也就是：</p>
<p>$f_{i,1}&#x3D;\sum_{j\in{son_i}}f_{j,0}+1$</p>
<p>不选就无所谓了</p>
<p>$f_{i,0}&#x3D;\sum_{j\in{son_i}}\max(f_{j,0},f_{j,1})$</p>
<h2 id="士兵"><a href="#士兵" class="headerlink" title="士兵"></a>士兵</h2><blockquote>
<p>在一棵树上布置士兵，每个士兵在节点上，每个士兵可以守护与其相连的点，问最少需要多少个士兵。</p>
</blockquote>
<p>第一维还是指以 $i$ 为根的子树，这个根节点有三种情况，一个是自己守护自己，一个是它的儿子守护它，一个是它的父亲守护它。</p>
<p>$0-son,1-self,2-fa$</p>
<p>对于叶子节点，$f_{i,0}&#x3D;inf,f_{i,1}&#x3D;1,f_{i,2}&#x3D;0$</p>
<p>转移？</p>
<p>$$<br>\begin{aligned}<br>f_{i,0}&amp;&#x3D;\sum_{j\in{son_i}}\<br>f_{i,1}&amp;&#x3D;\sum_{j\in{son_i}}\min(f_{j,0},f_{j,1},f_{j,2})+1\<br>f_{i,2}&amp;&#x3D;\sum_{j\in{son_i}}f_{j,0}\<br>\end{aligned}<br>$$</p>
<p>被父亲守护时，不能被儿子守护，因为这样会重复计算，同理在计算被儿子守护时不能计算被父亲守护。</p>
<p>被儿子守护时，至少一个儿子要有士兵，常见技巧：聚合儿子时，需要用另外一个 DP 来维护转移。</p>
<p>设 $g_{k,0&#x2F;1}$ 代表已经考虑完了前 $k$ 个儿子，是否至少有一个儿子放了士兵的所得到的最小士兵数量。</p>
<p>转移：</p>
<p>$$<br>g_{k,0}&#x3D;g_{k-1,0}+f_{p_k,0}<br>$$</p>
<p>$$<br>g_{k,1}&#x3D;\min(g_{k-1,0}+f_{p_k,1},g_{k-1,1}+f_{p_k,0},g_{k-1,1}+f_{p_k,1})<br>$$</p>
<p>这个 DP 就是为了聚合转移 $f_{i,0}$ 的。</p>
<p>假如 $i$ 有 $r$ 个儿子，那么 $f_{i,0}&#x3D;g_{r,1}$</p>
<p>树形DP的时候常用DP来做聚合。</p>
<h2 id="依赖背包-1"><a href="#依赖背包-1" class="headerlink" title="依赖背包"></a>依赖背包</h2><blockquote>
<p><strong>树形背包</strong><br>$n$ 个物品彼此组成一个树，如果想选第 $i$ 种物品，必须先选它的父亲，问获得的最大价值。</p>
</blockquote>
<p>状态：$f_{i,j}$ 前 $i$ 种物品用了 $j$ 的体积所得到的最大价值 $\to$ 在 $i$ 的子树中选一些物品用了 $j$ 的体积所能获得的最大价值。</p>
<p>初始化： 叶子节点 $f_{i,0}&#x3D;0,f_{i,w_i}&#x3D;v_i,f_{i,j}&#x3D;-inf$</p>
<p>转移： 聚合的时候就要再做一个背包：</p>
<p>$g_{i,j}$ 代表前 $i$ 个儿子的子树已经用掉了 $j$ 的体积得到的最大价值，$g_{0,0}&#x3D;0,g_{0,j}&#x3D;-inf$，转移就枚举一下第 $i$ 个儿子用掉了多少个体积：</p>
<p>$$<br>g_{i,j}&#x3D;\max_{0\le{k}\le{j}}(g_{i-1,j-k}+f_{i,k})<br>$$</p>
<p>$$<br>f_{i,0}&#x3D;0,f_{i,j}&#x3D;g_{r,j-v_i}+w_i<br>$$</p>
<p>所以这是一个不断用 $f$ 求 $g$ ，再用 $g$ 求 $f$ 的做法。</p>
<p>复杂度为 $O(n\times{m^2})$</p>
<hr>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P2014" >选课<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">305</span>;</span><br><span class="line"><span class="type">int</span> n,m,edcnt;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m<span class="number">+1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)</span><br><span class="line">                f[u][j]=<span class="built_in">max</span>(f[u][j],f[v][k]+f[u][j-k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;k,&amp;s[i]);</span><br><span class="line">        f[i][<span class="number">1</span>]=s[i];</span><br><span class="line">        <span class="built_in">add</span>(k,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">0</span>][m<span class="number">+1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h1><h2 id="DP-方式"><a href="#DP-方式" class="headerlink" title="DP 方式"></a>DP 方式</h2><blockquote>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/613107701" >参考文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>迭代 or 记搜？</p>
</blockquote>
<p>记搜！</p>
<p>不要写迭代，又难想又难调。</p>
<p>常用形参：</p>
<ul>
<li><p>$pos$ 代表当前枚举到的位置，</p>
</li>
<li><p>$limit$ 代表当前这位所受限制（true 有限制，false 无限制）</p>
</li>
<li><p>$ans$ 记录前 $i$ 位的答案。</p>
</li>
</ul>
<p>设状态 $f_{pos,sum}$ 代表位置 $[pos+1,len]$ 已经填完了，这些数位之和在 $sum$ 的情况下，数位 $[1,pos]$ 无 $limit$ 的情况下，所有数的数位之和。</p>
<ul>
<li>$last$ 记录上一位选的数，通常是为了限制当前位。</li>
<li>$lead$ 是否有前导零。</li>
<li>$r$ 余数</li>
<li>$st$ 状态压缩</li>
</ul>
<p>一般递归树中只有叶子节点存储的是该节点状态的答案，其它节点都是累加了它以及它子树的状态的答案。</p>
<p>而且初始状态已经以形参的形式传入到函数当中，无需费心初始化。</p>
<p>$\text{dp}$ 数组的下标表示的是一种状态，独一无二的状态，一个状态是否要记录取决于它是否足够特殊，是否对答案有影响。</p>
<p>而有限制和无限制对应的状态又不同，因此当限制对答案数会产生影响时，要先判断没有限制，再记忆答案。</p>
<p>如何判断记忆化的值能否复用？</p>
<p>看下每次递归，影响答案的参数是否有改变？</p>
<p>是否是在非限制条件下记录的答案？</p>
<p>是否是在没有前导零的条件下记录的答案？</p>
<p>是否模数不同？</p>
<p>都要考虑。</p>
<h2 id="数的个数"><a href="#数的个数" class="headerlink" title="数的个数"></a>数的个数</h2><p>举个例子：给你两个整数 $l,r$，问 $[l,r]$ 有多少个数，显然答案是 $r-l+1$ ，那么怎么用数位DP来解决，数位DP的特征一般为 $[l,r]$ 中满足某种条件的数有多少个。</p>
<p>那就可以转化为 $[0,r]$ 中满足条件的数的个数减去 $[0,l-1]$ 之间满足条件的数。</p>
<p>所以我们就是询问 $[0,x]$ 这段区间内有多少个数了。</p>
<p>把 $x$ 的每一位 $x_i$ 都写下来，最高位为 $k$。</p>
<p>我现在要找 $y$ 满足 $0\le{y}\le{x}$，把 $y$ 的每一位 $y_i$ 也写下来，</p>
<p>也就是 $y_i$ 有多少种方案使得每一位的 $y\le x$ ，所以就从高位往低位依次去填，</p>
<p><strong>状态</strong> $f_{i,0&#x2F;1}$ 代表<strong>从高到低</strong>填到第 $i$ 位了当前已经填的这些位是<strong>等于</strong> $x$ 的这些位<strong>还是小于</strong> $x$ 的这些位，这种情况下的方案数。</p>
<p>其中，$0\to&lt;,1\to&#x3D;$</p>
<p>初始化 $f_{k+1,1}&#x3D;1$，第$k+1$ 位两个数都是零，所以两数相等。</p>
<p>转移：</p>
<p>$$<br>f_{i-1,0}+&#x3D;f_{i,0}\times{10}<br>$$</p>
<p>因为高位已经小于了，所以再往低一位填 $0\sim{9}$ 都可以，所以就是乘十。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=x[i<span class="number">-1</span>];j++)</span><br><span class="line">	f[i<span class="number">-1</span>][x[i<span class="number">-1</span>]==j]+=f[i][<span class="number">1</span>]; <span class="comment">// 如果这一位还相等，那么就转移后还想等，否则填完后就是小于。</span></span><br></pre></td></tr></table></figure></div>

<p>最后的答案就是 $f_{1,0}+f_{1,1}$ 代表 $0\sim{x}$ 小于等于 $x$ 的数的个数。</p>
<p>数位DP很常用一个前缀和优化。</p>
<p>状态设计常用 $f_{i,j}$，$i$ 表示填到第 $i$ 位了，$j$ 通常表示条件是否满足，以此决定下一位能填的数是多少，初始化就要保证两个数都没开始填的方案为 $1$，转移就枚举下一位填什么数。</p>
<h2 id="数位之和"><a href="#数位之和" class="headerlink" title="数位之和"></a>数位之和</h2><blockquote>
<p>求一个 $[l,r]$ 每个数每一位加起来的结果。</p>
</blockquote>
<p>先转为前缀和：$[0,x]$</p>
<p>还是老状态 $g_{i,0&#x2F;1}$ 值便为此时的数位之和，在你填下一位的时候，要考虑当前有多少个数，而数位之和就会多出这么多倍，所以我还要维护这样的数有多少个，把上一个题的 $f_{i,j}$ 代表这样的数有多少个。</p>
<p>转移和上面是同样的，只不过要加上当前填的数能填多少个 $+&#x3D;x\times{f_{i,j}}$，$x$为当前位置填的数。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">g[i<span class="number">-1</span>][j&amp;&amp;(r==y[i<span class="number">-1</span>])]+=g[i][j]+f[i][j]*r;</span><br></pre></td></tr></table></figure></div>

<p>$g$ 代表数位之和。</p>
<p>合并一下：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">+1</span>;i&gt;=<span class="number">2</span>;i--)<span class="comment">//第i位已经填好了，要填的是第i-1位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1</span>;j++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;=<span class="number">9</span>;r++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==<span class="number">1</span>&amp;&amp;r&gt;y[i<span class="number">-1</span>]) <span class="keyword">continue</span>;<span class="comment">//break;// 不用转移，因为假如相等后再有一个大于 x 的数，那么这整个数就更大了</span></span><br><span class="line">			f[i<span class="number">-1</span>][j&amp;&amp;(r==y[i<span class="number">-1</span>])]+=f[i][j]; <span class="comment">// 都满足才相等</span></span><br><span class="line">			g[i<span class="number">-1</span>][j&amp;&amp;(r==y[i<span class="number">-1</span>])]+=g[i][j]+f[i][j]*r;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></div>

<p>答案就是 $g_{1,0}+g_{1,1}$。</p>
<h2 id="差二"><a href="#差二" class="headerlink" title="差二"></a>差二</h2><blockquote>
<p>求 $[l,r]$ 之间满足相邻两个数之间差<strong>至少为</strong> $2$ 的数有多少个</p>
</blockquote>
<p>题目加了一个条件，很自然的想法就是再加一个维度，并且这个维度必然会影响我的转移，不然有啥价值。</p>
<p>设 $f_{i,j,k}$ 前两维都一样，第三维记录了 $i$ 这一位填什么。</p>
<p>填第 $i-1$ 位的时候，使得 $r-k\ge{2}$ 就可以了。</p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P2657" >P2657<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>注：而这个题还需要处理前导零的情况。</p>
<h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><blockquote>
<p>求 $[l,r]$ 之间有多少个回文数，不允许前导零存在。</p>
</blockquote>
<p>设 $f_{i,j,k}$ 前两维依旧相同，而找回文数的时候，我们不仅要比较高位与 $x$ 的大小关系，还要比较低位与 $x$ 的大小关系。</p>
<p>所以 $k$ 取 $0,1,2$ ，分别代表小于，等于，大于。</p>
<p>$j$ 代表正着填时与 $x$ 的大小关系，而 $k$ 代表对称那边与 $x$ 的大小关系。</p>
<p>因为只要前面比 $x$ 小，后面是可以比 $x$ 大的，所以可以填 $2$。</p>
<p>然后枚举一遍就可以了。</p>
<h2 id="积K"><a href="#积K" class="headerlink" title="积K"></a>积K</h2><blockquote>
<p>求 $[l,r]$ 之间满足各位数字之积为 $K$ 的数的个数，$l,r,k\le{10^{18}}$。</p>
</blockquote>
<p>设 $f_{i,j,r}$ 代表各位数之积为 $r$ 的方案数，虽然开不下，但是先这么想再考虑优化。</p>
<p>假如使 $K&#x3D;111$，那么一定在某个位置有 $3\times{37}$，而由于是一位一位的乘，所以最后它一定只有 $4$ 个质因子：$2,3,5,7$，因为一旦有其它质因子就直接输出无解就可以了。</p>
<p>所以 $f_{i,j,a,b,c,d}$ 把乘积为 $r$ 换成了 乘积用 $2^a+3^b+5^c+7^d$ 表示。</p>
<p>这个时候就可以正常进行 DP 了。</p>
<p>这样还没完，要考虑 $K$ 是否为 $0$，如果为 $0$，那么一定存在某位是 $0$，需要再开一维记录前 $i$ 位是否有 $0$；如果不是那么必然不存在某位为 $0$。</p>
<p>还要处理一下前导零的情况。</p>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定一个区间 $[l,r]$，定义函数 $f(x)$ 代表 $x$ 每相邻两位差的绝对值之和，现在要在 $[l,r]$ 之间找这样一个最大的 $f(x)$。</p>
</blockquote>
<p>这道题还能拆成前缀和来做吗？</p>
<p>$\max$ 不可以通过前缀和来做的，所以 $l,r$ 拆不开了。</p>
<p>定义 $f_{i,j,k}$ 代表从高向低填到第 $i$ 位，$j$ 代表当前填的数与 $r$ 的这些位数相比是小于还是等于，$k$ 代表当前填的这些数与 $l$ 的这些位数是大于还是等于。</p>
<p>既然有两个限度，那就再开一维记录。</p>
<p>同时还要记录一下当前这位填的是什么： $f_{i,j,k,p}$</p>
<p>这样进行转移就可以了。</p>
<h2 id="棋盘"><a href="#棋盘" class="headerlink" title="棋盘"></a>棋盘</h2><blockquote>
<p>在 $n\times{m}$ 的棋盘上放若干个炮使得其互相不攻击的方案数。$n,m\le{100}$</p>
</blockquote>
<p>如果两个炮之间可以互相攻击，那么这一行或者这一列一定至少存在三个炮，所以每一行每一列放炮的数量就要 $\le{2}$。</p>
<p>用 $f_{i,j,k,l}$ 代表前 $i$ 行已经放好炮了，有 $j$ 列有一个炮，有 $k$ 列有一个炮，有 $l$ 列有两个炮。</p>
<p>但是 $j+k+l&#x3D;m$，所以可以去除冗余变量，那就把 $l$ 删掉，</p>
<p>那么最后就是 $f_{i,j,k}$ 代表这种情况下的方案数。</p>
<p>转移：</p>
<p>已经放好了前 $i$ 行的炮，现在要放第 $i+1$ 行的炮，</p>
<ul>
<li>放 $0$ 个炮：$f_{i+1,j,k}+&#x3D;f_{i,j,k}$</li>
<li>放 $1$ 个炮：<ul>
<li>放在有 $0$ 个炮的列：$f_{i+1,j-1,k+1}+&#x3D;f_{i,j,k}\times{j}$</li>
<li>放在有 $1$ 个炮的列：$f_{i+1,j,k-1}+&#x3D;f_{i,j,k}\times{k}$</li>
</ul>
</li>
<li>放 $2$ 个炮 ：<ul>
<li>一个放在 $0$ 个炮的列，一个放在 $1$ 个炮的列：$f_{i,j-1,k}+&#x3D;f_{i,j,k}\times{j}\times{k}$</li>
<li>两个都放在 $0$ 个炮的列：$f_{i+1,j-2,k+2}+&#x3D;f_{i,j,k}\times{C(j,2)}$</li>
<li>两个都放在 $1$ 个炮的列：$f_{i+1,j,k-2}+&#x3D;f_{i,j,k}\times{C(k,2)}$</li>
</ul>
</li>
</ul>
<p>其实可以发现一个性质，在求方案数时，其实我们是不关心到底是怎么放的，只关心这样放会有多少种方案，所以要记录与方案有关的信息。</p>
<h1 id="排列DP"><a href="#排列DP" class="headerlink" title="排列DP"></a>排列DP</h1><blockquote>
<p>这种题会告诉你有一个 $1\sim{n}$ 的排列，求其中满足某个条件的排列有多少个。<br>一共有 $n!$ 个排列。</p>
</blockquote>
<h2 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h2><blockquote>
<p>求 $1\sim{n}$ 的排列种，逆序对数量位偶数的排列数。</p>
</blockquote>
<p>答案是 $\frac{n!}{2}$，但是怎么用DP来解？</p>
<p>假设这里有一个 $1\sim{i}$ 的排列，在这里插入一个 $i+1$，就会变成一个 $1\sim{i+1}$ 的排列，所以我就可以不断插入数来得到最终的排列。</p>
<p>设 $f_{i,j}$ 已经处理完了所有 $1\sim{i}$ 的排列（填到了 $i$）此时逆序对数量为 $j$ 的方案数。</p>
<p>这就是排列DP常用的状态：$1\sim{i}$ 的排列已经处理完了且满足条件数量为 $j$ 的方案数。</p>
<p>初始化： $f_{1,0}&#x3D;1$</p>
<p>转移：枚举第 $i+1$ 个数插到哪里。有 $i$ 个数，$i+1$ 个位置，分别编号 $0\sim{i}$，那么插入到第 $k$ 个位置，由于我插入的是第 $i+1$ 个数，因此它比之前所有数都大，也就是说第 $k$ 个位置之后的数都比它小，这就是新产生的逆序对的个数 $i-k$。</p>
<p>优化：只关心奇偶性，并不关心到底是多少，所以第二维模二即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=i;k++)</span><br><span class="line">                f[i<span class="number">+1</span>][(j+i-k)%<span class="number">2</span>]+=f[i][j];</span><br></pre></td></tr></table></figure></div>

<p>排列DP不一定是从小到大或者从大到小插入，所以要根据不同情况定不同的状态，每次考虑下一个数怎么插入。</p>
<h2 id="激动"><a href="#激动" class="headerlink" title="激动"></a>激动</h2><blockquote>
<p>对于一个排列，它的激动值维序列中严格大于前面所有数的元素的个数。<br>给定 $n$ 个数，求它们每个数的所有排列中，激动值不超过 $k$ 的个数。</p>
</blockquote>
<p>这道题就要从大到小插入。</p>
<p>设 $f_{i,j}$ 代表从大到小已经把 $i\sim{n}$ 的数插入进来了，这个时候的激动值是 $j$ 的方案数。</p>
<p>这样每次插入的都是最小的数，无论把它插到哪里都不会影响原来的数的激动值，所以我们就只需要枚举它在哪里，只有它在最前面的时候激动值会加一，其它的时候激动值不变。</p>
<h2 id="LIS-1"><a href="#LIS-1" class="headerlink" title="LIS"></a>LIS</h2><blockquote>
<p>$1\sim{n}$ 的所有排列中，LIS 不超过 2 的排列数</p>
</blockquote>
<p>设 $f_{i,j}$ 代表已经插入了 $1\sim{i}$ 最长上升子序列的个数</p>
<p>假设从小到大插，插入了 $1\sim{i}$，下一个插入的是 $i+1$，前面所有的最长上升子序列要么是1要么是2。</p>
<p>最长上升子序列长度为1，当且仅当这个序列是降序排列，特殊处理一下即可。</p>
<p>最长上升子序列长度为2，$i+1$ 一定不能插入到任何一个最长上升子序列的右边，所以我要插到所有长度为2的上升子序列中最左边的右端点的左边。</p>
<p>$f_{i,j}$ 代表已经插完了 $1\sim{i}$，此时最长上升子序列最左端的右端点是 $j$。</p>
<p>这样就可以枚举 $0\sim{j-1}$ 就可以了，把 $i+1$ 插进去。</p>
<ul>
<li>$k!&#x3D;0:f_{i+1,j+1}+&#x3D;f_{i,j}$</li>
<li>$k&#x3D;0:f_{i+1,k}+&#x3D;f_{i,j}$</li>
</ul>
<h1 id="博弈DP"><a href="#博弈DP" class="headerlink" title="博弈DP"></a>博弈DP</h1><h1 id="DP-的单调队列优化"><a href="#DP-的单调队列优化" class="headerlink" title="DP 的单调队列优化"></a>DP 的单调队列优化</h1><p>对朴素 DP 进行等价变形。</p>
<h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a><a class="link"   href="https://www.acwing.com/problem/content/137/" >最大子段和<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>对于一个对应右端点，要找到一个左端点使得左端点前缀和最小。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> s[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = INT_MIN;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>; <span class="comment">// 0 号元素 sum0 = 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[hh] &lt; i - m) hh++; <span class="comment">// i 为窗口右端点的下一个位置</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, s[i] - s[q[hh]]);</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; s[q[tt]] &gt;= s[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="旅行问题"><a href="#旅行问题" class="headerlink" title="旅行问题"></a><a class="link"   href="https://www.acwing.com/problem/content/1090/" >旅行问题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>破环成链。</p>
<p>所有前缀和都大于等于零，才能安全到达。</p>
<p>也就是区间和最小大于等于零，区间长度为 $n$。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL s[N];</span><br><span class="line"><span class="type">int</span> o[N], d[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;o[i], &amp;d[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        s[i] = s[i + n] = o[i] - d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++)</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + n; i; i--) <span class="comment">// 顺时针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &gt;= i + n) hh++;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; s[q[tt]] &gt;= s[i]) tt--;</span><br><span class="line">        q[++tt] = i; <span class="comment">// 包含 s_i 要先更新</span></span><br><span class="line">        <span class="comment">// 这里 i 为滑动窗口左端点</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= n) <span class="comment">// 小于等于 n 才能更新答案</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[q[hh]] &gt;= s[i - <span class="number">1</span>]) st[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">0</span>] = d[n]; <span class="comment">// 预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        s[i] = s[i + n] = o[i] - d[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++) s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++) <span class="comment">// 逆时针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - n) hh++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n) <span class="comment">// 这里 i 为滑动窗口右端点下一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[q[hh]] &lt;= s[i]) st[i - n] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; s[q[tt]] &lt;= s[i]) tt--;</span><br><span class="line">        q[++tt] = i; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="built_in">puts</span>(<span class="string">&quot;TAK&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="烽火传递"><a href="#烽火传递" class="headerlink" title="烽火传递"></a><a class="link"   href="https://www.acwing.com/problem/content/1091/" >烽火传递<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// 点前 i 个且第 i 个必点的最小代价</span></span><br><span class="line"><span class="comment">// f[i] = min(f[j]) (i - m &lt;= j &lt; i) + w[i]</span></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>; <span class="comment">// 窗口内一开始有 0 这个元素</span></span><br><span class="line">    <span class="comment">// f[0] = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[hh] &lt; i - m) hh++;</span><br><span class="line">        f[i] = f[q[hh]] + a[i];</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; f[q[tt]] &gt;= f[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - m + <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 最后一段放一个烽火台</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, f[i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="绿色通道"><a href="#绿色通道" class="headerlink" title="绿色通道"></a><a class="link"   href="https://www.acwing.com/problem/content/1092/" >绿色通道<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>上一道题加一个二分答案即可。</p>
<p>注意边界问题。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// 前 i 道题且第 i 道必写的最小时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[hh] &lt; i - mid - <span class="number">1</span>) hh++; <span class="comment">// 空了 mid 道</span></span><br><span class="line">        f[i] = f[q[hh]] + w[i];</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; f[q[tt]] &gt;= f[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - mid; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (f[i] &lt;= m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="修剪草坪"><a href="#修剪草坪" class="headerlink" title="修剪草坪"></a><a class="link"   href="https://www.acwing.com/problem/content/1089/" >修剪草坪<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>$f_i$ 表示从前 $i$ 头奶牛中选且合法的所有方案中的最大价值。</p>
<p>不同点：第 $i$ 头牛选或者不选。</p>
<p>不选的话就是 $f_{i-1}$</p>
<p>选的话，最后一段的长度可能是 $[1,m-1]$</p>
<p>于是我们维护一段长度为 $m$ 的滑动窗口，里面元素的值为 $f_{j-1}-s_j$。</p>
<p>这样当 $j&#x3D;i-m$ 时刚好是 $s_i-s_{i-m}$ 为 $[i-m+1,i]$，这个时候 $i-j$ 是不能选的，因此只能保留 $f_{j-1}$</p>
<p>即 $f_i&#x3D;f_{i-j-1}+s_i-s_j$</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL s[N];</span><br><span class="line">LL f[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">g</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[i - <span class="number">1</span>] - s[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;s[i]);</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[hh] &lt; i - m) hh++;</span><br><span class="line">        f[i] = <span class="built_in">max</span>(f[i - <span class="number">1</span>], <span class="built_in">g</span>(q[hh]) + s[i]);</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">g</span>(q[tt]) &lt;= <span class="built_in">g</span>(i)) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="理想的正方形"><a href="#理想的正方形" class="headerlink" title="理想的正方形"></a><a class="link"   href="https://www.acwing.com/problem/content/1093/" >理想的正方形<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>先看一维，每一个点存的是以它为右端点长度为 $n$ 的区间的极值。</p>
<p>我们把所有行处理完了以后，再处理一遍列即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> row_max[N][N], row_min[N][N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_min</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[hh] &lt;= i - k) hh++; <span class="comment">// 包含右端点</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        b[i] = a[q[hh]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_max</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[hh] &lt;= i - k) hh++;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        b[i] = a[q[hh]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">get_min</span>(w[i], row_min[i], m);</span><br><span class="line">        <span class="built_in">get_max</span>(w[i], row_max[i], m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> a[N], b[N], c[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) a[j] = row_min[j][i];</span><br><span class="line">        <span class="built_in">get_min</span>(a, b, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) a[j] = row_max[j][i];</span><br><span class="line">        <span class="built_in">get_max</span>(a, c, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = k; j &lt;= n; j++)</span><br><span class="line">            res = <span class="built_in">min</span>(res, c[j] - b[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP-数学</title>
    <url>/915ab73.html</url>
    <content><![CDATA[<h1 id="基础数学"><a href="#基础数学" class="headerlink" title="基础数学"></a>基础数学</h1><h2 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h2><p>一张图搞懂取模：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309301506245.webp"
                      alt="image.png|400"
                ></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">cout&lt;&lt;(a+b)%c&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;((a-b)%c+c)%c&lt;&lt;endl;<span class="comment">//负数取模</span></span><br><span class="line">cout&lt;&lt;(<span class="number">1ll</span>*a*b)%c&lt;&lt;endl;<span class="comment">//防止爆int的两种方法</span></span><br><span class="line">cout&lt;&lt;((<span class="type">long</span> <span class="type">long</span>)a*b)%c&lt;&lt;endl;</span><br></pre></td></tr></table></figure></div>

<p>数学和计算机中的取模实现方式不同，对于正数，两种方式得到的答案一样，但是对于负数却不同。</p>
<p>对于下面例子：</p>
<p>$-3 \bmod 2$</p>
<p>数学得到的答案是：$-3 - \lfloor{-3 &#x2F; 2}\rfloor \times 2 &#x3D; 1$</p>
<p>计算机得到的答案是：$-3 - (-3 &#x2F; 2) \times 2 &#x3D; -1$</p>
<p>故计算机对负数取模的时候，需要 $((-3 \bmod 2) + 2)\bmod 2$</p>
<p>通过规律我们发现，当被模数为正数时，答案是非负数；模数为负数时，答案是非正数。</p>
<h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><p><em>n的阶乘：</em></p>
<p>$n! &#x3D;n\times{(n-1)}\times{(n-2)}\times\ldots\times1$</p>
<p><strong>n!%p</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,p;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans*=i;</span><br><span class="line">        ans%=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em>典型的错误写法：</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290904698.webp"
                      alt="image.png|600"
                ></p>
<h2 id="GCD-LCM"><a href="#GCD-LCM" class="headerlink" title="GCD&amp;LCM"></a>GCD&amp;LCM</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290908493.webp"
                      alt="image.png|600"
                ></p>
<p><del>太熟悉了</del></p>
<p>求一下gcd</p>
<p>设$gcd(a,b)&#x3D;g$</p>
<p><strong>整除</strong>：$g|a$ $g$ 能整除 $a$ $a\pmod g&#x3D;0$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290913704.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290917006.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290918595.webp"
                      alt="image.png|600"
                ></p>
<p>$$gcd(a,b)&#x3D;gcd(b,a%b)$$</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;<span class="comment">//任何数和0的最大公因数为自身</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290925998.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290928411.webp"
                      alt="image.png|600"
                ></p>
<p>1.$b \le \frac a 2$时，$a% b \le \frac a 2$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290929042.webp"
                      alt="image.png|600"
                ><br>wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww<br>2.$b \ge \frac a 2$时，$a% b &#x3D;a-b \le \frac a 2$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290929060.webp"
                      alt="image.png|600"
                ></p>
<p>所以$a%b&lt;\frac1 2 a$</p>
<p>复杂度？</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="type">int</span> ans=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">gcd</span>(ans,a[i]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br></pre></td></tr></table></figure></div>

<p>$O(n+log_{a_{max}})$</p>
<p>$ans$只会不断变小</p>
<p>除$2$的次数只有$log$次</p>
<hr>
<p>若$gcd(a,b)&#x3D;g,lcm(a,b)&#x3D;l$</p>
<p>$l&#x3D;a*b&#x2F;g$</p>
<p><em>小寄巧</em>：$a * b &#x2F; gcd(a,b) \to a &#x2F; gcd(a,b) *b$</p>
<p>先除后乘防止爆</p>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>$x^{y} % p$</p>
<p><em>朴素的代码：</em></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y;i++)</span><br><span class="line">        ans=<span class="number">1ll</span>*ans*x%p;</span><br></pre></td></tr></table></figure></div>

<p>比如现在要算$x^{37}$</p>
<p>需要乘$36$次</p>
<p>$x^{37}$$&#x3D;x^{18^2}\cdot x$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291007280.webp"
                      alt="image.png|600"
                ></p>
<p>时间复杂度就是$O(log_n)$</p>
<p>可以递归求解</p>
<p><em>朴素的代码：</em></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> z=<span class="built_in">ksm</span>(x,y/<span class="number">2</span>,p);</span><br><span class="line">    z=<span class="number">1ll</span>*z*z%p;</span><br><span class="line">    <span class="keyword">if</span>(y%<span class="number">2</span>==<span class="number">1</span>) z=<span class="number">1ll</span>*z*x%p;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>优化</strong></p>
<p>位运算： <code>if(y&amp;1) z=1ll*z*x%p;</code></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) res = res * x % p;</span><br><span class="line">        x = x * x % p;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>小题目:$x,y,p$,算$x*y%p$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291021157.webp"
                      alt="image.png|600"
                ></p>
<h2 id="快速乘法"><a href="#快速乘法" class="headerlink" title="快速乘法"></a>快速乘法</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kscf</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> z=<span class="built_in">kscf</span>(x,y/<span class="number">2</span>,p);</span><br><span class="line">    z=(z+z)%p;</span><br><span class="line">    <span class="keyword">if</span>(y&amp;<span class="number">1</span>) z=(z+x)%p;<span class="comment">//判奇</span></span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><blockquote>
<p>n行m列的一个东西</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291041588.webp"
                      alt="image.png|600"
                ></p>
<p>两个矩阵做<strong>加法</strong>的条件是两个矩阵的大小一样</p>
<p>做法:</p>
<p>对应位置的数字加起来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291042209.webp"
                      alt="image.png|600"
                ></p>
<p><strong>减法</strong>同理:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291043292.webp"
                      alt="image.png|600"
                ></p>
<p><strong>数乘</strong>:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291044900.webp"
                      alt="image.png|600"
                ></p>
<p><strong>矩阵乘法</strong>:</p>
<p>$$<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6 \<br>7 &amp; 8 &amp; 9 \<br>\end{bmatrix}<br>$$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291048242.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291048036.webp"
                      alt="image.png|600"
                ></p>
<p>$$\begin{bmatrix}1 &amp; 2  \3 &amp; 4  \ \end{bmatrix}\times \begin{bmatrix}1&amp;2&amp;3 \  2 &amp; 3 &amp; 3\ \end{bmatrix}&#x3D;\begin{bmatrix}5&amp;8&amp;9\11&amp;18&amp;21\ \end{bmatrix}$$</p>
<p>第一个的列数 &#x3D; 第二个的行数</p>
<p>第一行第一列，取出第一个的第一行，第二个的第一列</p>
<p>一一相乘再相加</p>
<p><strong>代码实现</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">int</span> z[<span class="number">23</span>][<span class="number">23</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291059199.webp"
                      alt="image.png|600"
                ></p>
<p>$z$数组不一定为$0$(受很多因素影响)</p>
<p><strong>构造函数</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">int</span> z[<span class="number">23</span>][<span class="number">23</span>];</span><br><span class="line">    <span class="built_in">matrix</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(z,<span class="number">0</span>,<span class="built_in">sizeof</span>(z));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>重载运算符</strong></p>
<p>不会影响正常的$*$</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">matrix <span class="keyword">operator</span>*(matrix m1,matrix m2)</span><br></pre></td></tr></table></figure></div>

<p><em>这样写有没有什么问题？</em></p>
<p>涉及到一个传参的问题：</p>
<p>为了<strong>避免占空间</strong>，可以这样写:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">matrix <span class="keyword">operator</span>*(matrix &amp;m1,matrix &amp;m2)</span><br></pre></td></tr></table></figure></div>

<p>为了<strong>避免算出结果以后原值被修改</strong>，可以这样写：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">matrix <span class="keyword">operator</span>*(<span class="type">const</span> matrix &amp;m1,<span class="type">const</span> matrix &amp;m2)</span><br></pre></td></tr></table></figure></div>

<p>接下来是<strong>矩阵乘法</strong>的函数内容了</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">matrix <span class="keyword">operator</span>*(<span class="type">const</span> matrix &amp;m1,<span class="type">const</span> matrix &amp;m2)</span><br><span class="line">&#123;</span><br><span class="line">    matrix m3;</span><br><span class="line">    m<span class="number">3.</span>n=m<span class="number">1.</span>n;</span><br><span class="line">    m<span class="number">3.</span>m=m<span class="number">2.</span>m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m<span class="number">3.</span>n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m<span class="number">3.</span>m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m<span class="number">1.</span>m;k++)</span><br><span class="line">                m<span class="number">3.</span>z[i][j]+=m<span class="number">1.</span>z[i][k]*m<span class="number">2.</span>z[k][j];</span><br><span class="line">    <span class="keyword">return</span> m3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em>糟糕的复杂度:</em>$O(n^3)$ 可处理百位(100~200)级别的矩阵乘法</p>
<p>小题题：<a class="link"   href="https://www.luogu.com.cn/problem/P3390" >P3390矩阵快速幂<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><strong>memset</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291122556.webp"
                      alt="image.png|600"
                ></p>
<p><strong>ijk</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291127728.webp"
                      alt="image.png|600"
                ></p>
<p><strong>jki</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291128426.webp"
                      alt="image.png|600"
                ></p>
<p><strong>kji</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291128497.webp"
                      alt="image.png|600"
                ></p>
<p><strong>ikj</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291130768.webp"
                      alt="image.png|600"
                ></p>
<p>枚举顺序会影响时间复杂度？</p>
<p>把$j$放在最后是最快的</p>
<p>原因是<strong>缓存机制</strong></p>
<p>缓存很小，但是很快</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291407593.webp"
                      alt="image.png|600"
                ></p>
<p>连续性越高，也就越快</p>
<p>尽可能让最后一维作为循环变量，以最大化利用缓存</p>
<p>$j$全部在第二维，最优</p>
<p>$k$只有一个在第二维，次优</p>
<p>$i$没有在第二维，最不优</p>
<p>相当于先处理答案矩阵的第一行，对第一行扫 k 遍便是结果，</p>
<ul>
<li>处理答案矩阵的第一行<ul>
<li>第一个矩阵的第一行的任何一个数都要被加一遍，第二个矩阵的第一列</li>
</ul>
</li>
</ul>
<p>来个<strong>小练习题</strong>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291412157.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291413134.webp"
                      alt="image.png|600"
                ></p>
<p>求$f_n%p$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291417988.webp"
                      alt="image.png|600"
                ></p>
<p><del>暴力的写法</del></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c=a+b;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=p) c-=p;</span><br><span class="line">        a=b;</span><br><span class="line">        b=c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>$$\begin{bmatrix}f_{i-1}&amp;f_{i-2} \end{bmatrix}\times\begin{bmatrix}1&amp;1\1&amp;0\end{bmatrix}&#x3D;\begin{bmatrix}f_i&amp;f_{i-1}\end{bmatrix}$$</p>
<p>这样推$n$次就可以得到第$n$项</p>
<p>但是还不如直接算</p>
<p>怎么优化？</p>
<p>矩阵乘法也有结合律</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291426869.webp"
                      alt="image.png|600"
                ></p>
<p>这个东西是不是很眼熟</p>
<p>对于$B^n$可以进行一个[[NOIP-数学#快速幂|快速幂]]</p>
<p>小题题<a class="link"   href="https://www.luogu.com.cn/problem/P1962" >P1962斐波那契数列<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">matrix A,B;</span><br><span class="line">    A.n=<span class="number">1</span>;A.m=<span class="number">2</span>;</span><br><span class="line">    A.z[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    A.z[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    B.n=<span class="number">2</span>;B.m=<span class="number">2</span>;</span><br><span class="line">    B.z[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    B.z[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    B.z[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    B.z[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    matrix C=A*<span class="built_in">jzksm</span>(B,n);</span><br><span class="line">    <span class="type">int</span> ans=C.z[<span class="number">1</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure></div>

<p>复杂度:$log_n$</p>
<p>虽然矩阵乘法是$O(n^3)$,但是$B$矩阵是个$2 \times 2$的，$2^3$也就是$8$，可忽略</p>
<p>矩阵$B$是怎么来的呢？</p>
<p><strong>小栗子</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291437263.webp"
                      alt="image.png|600"
                ></p>
<p>找到能够向后推一项的矩阵</p>
<p>$$\begin{bmatrix}f_{i-1}&amp;f_{i-2} \end{bmatrix}\times\begin{bmatrix}3&amp;1\-2&amp;0\end{bmatrix}&#x3D;\begin{bmatrix}f_i&amp;f_{i-1}\end{bmatrix}$$</p>
<p><strong>目的</strong>:向后推一项</p>
<p><strong>再来一个栗子</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291440792.webp"
                      alt="image.png|600"
                ></p>
<p>刚才矩阵大小为$2$因为这一项的信息只与<strong>前两项</strong>有关</p>
<p>而这个却与前三项有关</p>
<p>$$\begin{bmatrix}f_{i-1}&amp;f_{i-2}&amp;f_{i-3}\end{bmatrix}\times\begin{bmatrix}1&amp;0&amp;1\1&amp;0&amp;0 \0&amp;1&amp;0 \end{bmatrix}&#x3D;\begin{bmatrix}f_{i}&amp;f_{i-1}&amp;f_{i-2}\end{bmatrix}$$</p>
<p>和前面几项有关，那么矩阵大小就是几</p>
<p>矩阵乘法有交换律吗？</p>
<p><strong>no</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291501408.webp"
                      alt="image.png|600"
                ><br>补充：</p>
<p>矩阵快速幂加速递推的底层原理想了一会，觉得它跟正常的快速幂是一个原理，都是通过减少运算（递推）次数来减少运行时间。</p>
<p><strong>又是一个<del>小</del>大栗子</strong></p>
<blockquote>
<p>以下仅为简要写法，具体题解请见<a class="link"   href="https://white.fallingsakura.top/59e59239/" >P4159 迷路<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291505595.webp"
                      alt="image.png|600"
                ></p>
<p>$n \le 100$</p>
<p>$k\le$ $10^9$</p>
<p>邻接矩阵存图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291509604.webp"
                      alt="image.png|600"
                ></p>
<p>$f[i][j]$代表走了$i$步到达$j$的方案数</p>
<p>初始化：</p>
<p>$f[0][1]&#x3D;1$</p>
<p>$f[0][{2\sim n}]&#x3D;0$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291513293.webp"
                      alt="image.png|600"
                ></p>
<p>代码中可以出现相同变量名，前提是它们的作用域不同。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291518261.webp"
                      alt="image.png|600"
                ></p>
<p>如何精确访问？</p>
<p><code>::a</code>代表访问全局变量</p>
<p>正常的DP写法：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">           cin&gt;&gt;z[i][j];</span><br><span class="line">   <span class="comment">//z[i][j]=0/1;i-&gt;j</span></span><br><span class="line">   f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=k;a++)<span class="comment">//走了a步</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)<span class="comment">//走到了b</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">1</span>;c&lt;=n;c++)<span class="comment">//第a-1步在c</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(z[c][b]==<span class="number">1</span>) f[a][b]+=f[a<span class="number">-1</span>][c];<span class="comment">//如果有边</span></span><br><span class="line">           &#125;</span><br><span class="line">   ans=f[k][n];<span class="comment">//走k步到n</span></span><br></pre></td></tr></table></figure></div>

<p>$O(n^3)$复杂度肯定过不了</p>
<p>优化一下：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if(z[c][b]=1) f[a][b]+=f[a-1][c];</span></span><br><span class="line">        f[a][b]+=f[a<span class="number">-1</span>][c]*z[c][b];</span><br></pre></td></tr></table></figure></div>

<p><strong>解释：</strong>$c \to b$有边的时候，$z[c][b]&#x3D;1$ 就相当于转移</p>
<p>$c \to b$没有边的时候，$z[c][b]&#x3D;0$，就相当于加上$0$</p>
<p>那这样做有什么用呢？    <em>——别急，往下看</em></p>
<p>升一下维度，中间始终为$1$</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">           cin&gt;&gt;z[i][j];</span><br><span class="line">   <span class="comment">//z[i][j]=0/1;//i-&gt;j</span></span><br><span class="line">   f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=k;a++)<span class="comment">//走了a步</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">1</span>;d&lt;=<span class="number">1</span>;d++)<span class="comment">//无意义</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)<span class="comment">//走到了b</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">1</span>;c&lt;=n;c++)<span class="comment">//第a-1步在c</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// if(z[c][b]=1) f[a][b]+=f[a-1][c];</span></span><br><span class="line">                   f[a][d][b]+=f[a<span class="number">-1</span>][d][c]*z[c][b];</span><br><span class="line">               &#125;</span><br><span class="line">   ans=f[k][<span class="number">1</span>][n];</span><br></pre></td></tr></table></figure></div>

<p>加维度、把判断变为相乘的目的就是为了<strong>把形式凑成矩阵乘法</strong></p>
<p>$f[i][j][k]$$DP$意义实际上就是以$j$为起点，走了$i$步到达点$k$的方案数,只不过这里的起点是$1$</p>
<p>把$f[a]$当作变量</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291531519.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291532228.webp"
                      alt="image.png|600"
                ></p>
<p>然后用下矩阵快速幂就搞定了</p>
<p>%% #Q： 但是 Z 这个数组时时刻刻在变化啊 %%</p>
<p>$O(n^{3\times}log k)$</p>
<p><strong>小问题</strong><a class="link"   href="https://www.luogu.com.cn/problem/P4159" >P4159<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291542660.webp"
                      alt="image.png|600"
                ></p>
<p>$1 \le$ 边权 $\le 9$</p>
<p>拆！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291543666.webp"
                      alt="image.png|600"
                ></p>
<p>尽量少拆</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291549120.webp"
                      alt="image.png|600"
                ></p>
<p>最多延申九个点，加上原来的点，最多十个点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291552458.webp"
                      alt="image.png|600"
                ></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        z[i][n+(i<span class="number">-1</span>)*<span class="number">9</span><span class="number">+1</span>]=<span class="number">1</span>;<span class="comment">//链</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;<span class="number">9</span>;j++)<span class="comment">//n之外点的相互连边</span></span><br><span class="line">        &#123;</span><br><span class="line">            z[n+(i<span class="number">-1</span>)*<span class="number">9</span>+j][n+(i<span class="number">-1</span>)*<span class="number">9</span>+j<span class="number">+1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291603778.webp"
                      alt="image.png|600"
                ></p>
<p>最终建出的图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291956964.webp"
                      alt="graph.png|700"
                ></p>
<p>（距离为9的最后一个节点其实没有必要）</p>
<p>由图可知，这个矩阵<strong>长度和宽度是十倍的n</strong></p>
<p>第一步是指$1\to n$</p>
<p>第二步是指$n+1 \to n+2 \to n+3 \ldots$</p>
<p>假设$n&#x3D;5$</p>
<p>加入对$1\to 4$有一条长度为$6$的边，那么就是：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291959263.webp"
                      alt="graph (1).png|700"
                ></p>
<p>假如是$3\to 5$长度为$9$</p>
<p>那么就是：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304292001831.webp"
                      alt="graph (2).png|700"
                ></p>
<p>对长度为$1$特判一下,直接连边</p>
<p>对长度为$0$特判一下，直接<code>continue</code></p>
<p>假如$2 \to 4$长度为$1$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304292021848.webp"
                      alt="graph (3).png|700"
                ></p>
<h1 id="初等数论"><a href="#初等数论" class="headerlink" title="初等数论"></a>初等数论</h1><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><blockquote>
<p>研究范围：正整数</p>
<p>素数:只有两个因子</p>
</blockquote>
<p>除了质数就是 <code>和数</code> 和 <code>1</code></p>
<p>如何判断$x$是不是质数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291616963.webp"
                      alt="image.png|600"
                ></p>
<p>有可能$x$是$1$或$0$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291617098.webp"
                      alt="image.png|600"
                ></p>
<hr>
<p>一个数的因子一定都是成对出现的</p>
<p>$x&#x3D;a\cdot b$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291619810.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291619096.webp"
                      alt="image.png|600"
                ></p>
<p>所以只需要枚举前根号个即可，大于 $\sqrt{x}$ 的质因子最后处理一下就可以了。</p>
<p>为什么没有两个大于 $\sqrt{x}$ 的质因子出现？</p>
<p>反证法：假如有，那么它们的乘积已经大于了 x，所以不存在。</p>
<p><strong>典型错误</strong>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291620535.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291622907.webp"
                      alt="image.png|600"
                ></p>
<p><em>这样会很man</em></p>
<p>因为每次都会重新调用一遍函数</p>
<p>修改：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291626807.webp"
                      alt="image.png|600"
                ></p>
<p>x最大只能到$x^{16}$</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">2</span>;a*a&lt;=x;a++)</span><br><span class="line">    <span class="keyword">if</span>(x%a==<span class="number">0</span>)<span class="comment">//第一个质因子,每次进来都一定是一个质因子</span></span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        prime[cnt]=a;</span><br><span class="line">        <span class="keyword">while</span>(x%a==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num[cnt]++;</span><br><span class="line">            x/=a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(x!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    prime[cnt]=x;</span><br><span class="line">    num[cnt]=<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>小练习:<strong>CF45G</strong></p>
<p><strong>哥德巴赫猜想</strong>：</p>
<p><em>始终不会超过三组</em></p>
<p>对于任何一个大于等于4的偶数，一定可以拆成两个质数之和</p>
<p>任何一个大于等于7的奇数，一定可以拆成三个质数之和</p>
<p>加和算出来是$x$</p>
<p>如果$x$是偶数，那么就是$2$组，</p>
<p>如果$x$是奇数，那么肯定小于$3$组</p>
<p>$x$本身是质数时答案为$1$组</p>
<p>剩下情况答案要么为$2$组，要么为$3$组</p>
<p>一个奇数可以看成一个奇数和一个偶数的和</p>
<p>若$x-2$是质数，那么就是$2$组，否则就可以拆成$3$组</p>
<h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><h3 id="逆元的引入"><a href="#逆元的引入" class="headerlink" title="逆元的引入"></a>逆元的引入</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300831974.webp"
                      alt="image.png|600"
                ></p>
<p>算完取模：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300833180.webp"
                      alt="image.png|600"
                ></p>
<p>边算边取模：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300834493.webp"
                      alt="image.png|600"
                ></p>
<p>理论上吧来说它也应该等于$2$</p>
<p>现在想计算$a \div b%p$</p>
<p>现在要把</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300836655.webp"
                      alt="image.png|600"
                ></p>
<p>如果能找到这个 $c$</p>
<p>$c$也就是 $\frac 1 b$</p>
<p>那么$c$就是$b$的逆元</p>
<p>我们想用一个乘法来替代除法</p>
<hr>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>当$p$是<strong>质数</strong>并且$1\le a &lt; p$</p>
<p>那么一定有</p>
<p>$$<br>a^{p-1}\bmod p\equiv1<br>$$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300839102.webp"
                      alt="image.png|600"
                ></p>
<p>$$<br>a^{p-1}\equiv 1 \pmod p<br>$$</p>
<p>这也就是<strong>费马小定理</strong></p>
<p>两边同除$a$</p>
<p>$$<br>a^{p-2}\equiv \frac 1 a \pmod  p<br>$$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300844814.webp"
                      alt="image.png|600"
                ></p>
<p>四分之一模$p$就是$4^{p-2}%p$</p>
<p>$$a\div b %p &#x3D;a\times b^{p-2}% p$$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/20230430092107.webp"
                      alt="image.png|600"
                ></p>
<p>那么$b$的$p-2$次方就可以用[[#快速幂|快速幂]]来求了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300848556.webp"
                      alt="image.png|600"
                ></p>
<p>第一个条件是$p$<strong>是质数</strong></p>
<p><del>第二个是a大于等于1小于p</del>（$a$也可以比$p$大，因为一模$p$就肯定比$p$小了，只要它们<strong>互质</strong>就可以）</p>
<p>假如a&gt;p，a与p互质，那么a%p还与p互质吗</p>
<p>依然互质，这不就是辗转相除法么</p>
<p>$gcd(a,p)&#x3D;1 \to gcd(p,a%p)&#x3D;1$</p>
<p>所以第二个条件是$gcd(a,p)&#x3D;1$,也就是$a$和$p$互质</p>
<p><strong>互质的概念</strong>：两个数的公因数只有1</p>
<p>那假如$p$不是质数怎么办</p>
<p>新定理：<strong>欧拉定理</strong></p>
<h3 id="欧拉定理-欧拉函数"><a href="#欧拉定理-欧拉函数" class="headerlink" title="欧拉定理&amp;欧拉函数"></a>欧拉定理&amp;欧拉函数</h3><p>使用条件：$gcd(a,p)&#x3D;1$</p>
<p>$$<br>a^{\varphi(p)}\equiv1\pmod p<br>$$</p>
<p>$\varphi(p)$为欧拉函数</p>
<p><strong>定义</strong>：一到$p$中有多少个数与$p$互质</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300854015.webp"
                      alt="image.png|600"
                ></p>
<p>$\varphi (4)\to$ 1 3<br>$\varphi (6)\to$ 1 5</p>
<p>和上面同理，两边同时除以$a$</p>
<p>$$<br>a^{\varphi (p)-1}\equiv \frac 1 a \pmod p<br>$$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300857708.webp"
                      alt="image.png|600"
                ></p>
<p>当$p$是质数的时候，$\varphi (p)&#x3D;p-1$</p>
<p>$$<br>a \div b \bmod p&#x3D;a \times \frac 1 b \bmod p&#x3D;a \times b^{\varphi(p)-1} \bmod p &#x3D; a \times b^{p-2} \bmod p<br>$$</p>
<p>$a$和$p$不互质的时候，<strong>以上两种定理是不成立的，此时逆元不存在</strong></p>
<p>这个时候我们认为这个用逆元是算不出来的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300900691.webp"
                      alt="image.png|600"
                ></p>
<p>接下来问题来了，$\varphi (n)$怎么算呢</p>
<p>假设$n&#x3D;p_1$</p>
<p>假设$p_1$是个质数，这时候$\varphi (n)&#x3D;p-1$</p>
<p>假设$n&#x3D;p_1^2$?</p>
<p>$p_1$的倍数都和$p_1$都不互质</p>
<p>一共有$p_1$个数和$n$不互质</p>
<p>那么$\varphi(n)$就是 ${p_{1}^2}-p_1&#x3D;p_1 \times (p1-1)$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300905869.webp"
                      alt="image.png|600"
                ></p>
<p>那么假设为$p^k$时，每$p_1$个数就刚好有一个是$p_1$的倍数</p>
<p>那么每$p_1$个数就有$p_1-1$个与$n$互质的</p>
<p>一共有$n$个数</p>
<p>所以$\varphi(n)&#x3D;\frac n p_{1} \cdot (p_1-1)$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300908200.webp"
                      alt="image.png|600"
                ></p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300911470.webp"
                      alt="image.png|600"
                ></p>
<p>假设$n&#x3D;p_{1}\times p_2$</p>
<p>$\varphi(n)&#x3D;n- \frac n {p_{1}} - \frac n {p_{2}} + \frac n {p_{1}\times p_2}$</p>
<p>解释一下，这个式子就是总共有$n$个数，每$p_1$个数就会出现一个不与$n$互质的数（$p_1$的倍数），每$p_2$个数就会出现一个不与$n$互质的数（$p_2$的倍数），减去不互质的数剩下的就是互质的数，我们发现每$p_{1}\times p_2$个数就会出现一个不与n互质的数且为$p_{1}\times p_2$的倍数（其实就是$n$），这个数被删了两次，所以要加回来一次</p>
<p>提取一个$n$出来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300913285.webp"
                      alt="image.png|600"
                ></p>
<p>因式分解：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300912307.webp"
                      alt="image.png|600"
                ></p>
<p>我们发现：</p>
<p>当$n&#x3D;p_1^{k_1}\cdot p_2^{k_2}\cdot p_3^{k_3}\dots\cdot p_t^{k_t}$时($p$都是质数)(无论$n$为何值，一定能凑成几个质因数幂的乘积的形式——质因数分解)</p>
<p>📜 $\varphi(n)&#x3D;n\cdot (1-\frac 1 {p_1})(1-\frac 1 {p_2})(1-\frac 1 {p_3})\dots(1-\frac 1 {p_t})$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300913014.webp"
                      alt="image.png|600"
                ></p>
<p><strong>根据容斥原理</strong></p>
<p><strong>现在要找的就是$n$的每个质因子,几次不用管</strong></p>
<p>正确性的话，举几个例子就行了，毕竟，<del>OI不需要证明</del></p>
<p><strong>先除再乘防止范围炸掉</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> phi = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)<span class="comment">//质因子,证明见[质因数分解]</span></span><br><span class="line">        &#123;</span><br><span class="line">            phi=phi/i*(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n=n/i;<span class="comment">//把i的几次方全部去掉</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>)<span class="comment">//最后一个质数是n，如果是n的很多次方，循环不会停止</span></span><br><span class="line">        phi=phi/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> phi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="小问题：求n个数的逆元"><a href="#小问题：求n个数的逆元" class="headerlink" title="小问题：求n个数的逆元"></a>小问题：求n个数的逆元</h3><h4 id="阶乘的做法"><a href="#阶乘的做法" class="headerlink" title="阶乘的做法"></a>阶乘的做法</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300921125.webp"
                      alt="image.png|600"
                ></p>
<p>最简单的做法：<em>枚举一下</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300922921.webp"
                      alt="image.png|600"
                ></p>
<p>这么做的复杂度是$O(nlogn)$的，但是$n$比较大</p>
<p>先算出$1$到$n$每个数的阶乘算下来</p>
<p>只需要算$n！$的逆元</p>
<p>$n$的逆元也就是$\frac 1 n$(模意义下)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300930964.webp"
                      alt="image.png|600"
                ></p>
<p>每个数的阶乘分之$1$，从右往左推</p>
<p>再相乘，就求得逆元</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300935335.webp"
                      alt="image.png|600"
                ></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-------------------*/</span></span><br><span class="line">   fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//1</span></span><br><span class="line">   &#123;</span><br><span class="line">       fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">   &#125;</span><br><span class="line">   ifac[n]=<span class="built_in">ksm</span>(fac[n],p<span class="number">-2</span>,p);<span class="comment">//算n的阶乘的逆元</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//2</span></span><br><span class="line">   &#123;</span><br><span class="line">       ifac[i]=<span class="number">1ll</span>*ifac[i<span class="number">+1</span>]*(i<span class="number">+1</span>)%p;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//3</span></span><br><span class="line">   &#123;</span><br><span class="line">       inv[i]=fac[i<span class="number">-1</span>]*ifac[i]%p;<span class="comment">//除以i的阶乘也就是乘以i的阶乘的逆元</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*-------------------*/</span></span><br></pre></td></tr></table></figure></div>

<p>复杂度为$O(n)$</p>
<p>这是第一种方法</p>
<h4 id="正推"><a href="#正推" class="headerlink" title="正推"></a>正推</h4><p>首先$1$的逆元就是$1$</p>
<p>假设从左向右一个一个求</p>
<p>当我要求$i$这个数的时候</p>
<p>那么$i-1$个逆元都已经求好了</p>
<p>可以把它们都存下来</p>
<p><strong>条件:质数p大于i</strong></p>
<p>$p%i$一定小于$i$</p>
<p>设$p&#x3D;ki+r$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300956374.webp"
                      alt="image.png|600"
                ></p>
<p>因为$i$一定不是$p$的因子</p>
<p>$1\le r \le i-1$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300958120.webp"
                      alt="image.png|600"
                ></p>
<p>现在想算$i$分之一</p>
<p>两边同除$i$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300958020.webp"
                      alt="image.png|600"
                ></p>
<p>两边同除$r$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300959364.webp"
                      alt="image.png|600"
                ></p>
<p>$r$是个小于$i$的数，因此它的逆元一定在之前求出来的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301000198.webp"
                      alt="image.png|600"
                ></p>
<p>复杂度$O(n)$</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> k = p / i;</span><br><span class="line">	<span class="type">int</span> r = p % i;</span><br><span class="line">	inv[i] = <span class="number">1ll</span> * k * (-inv[r] + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于是在模 p 意义下的运算，所以所有逆元都小于 p，所以加上 p 就可以防止负数。</p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P3811" >模板题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Miller-Rabin"><a href="#Miller-Rabin" class="headerlink" title="Miller-Rabin"></a>Miller-Rabin</h3><p>判断$x$是不是质数</p>
<p>复杂度为$O(\sqrt x)$</p>
<p>假如$x \le 10^{18}$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301008894.webp"
                      alt="image.png|600"
                ></p>
<p>假设$n&#x3D;37$</p>
<p>$n-1&#x3D;36$</p>
<p>$36&#x3D;9 \times 2^2$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301010370.webp"
                      alt="image.png|600"
                ></p>
<p>当$n$为质数的时候</p>
<p>至少有一条成立</p>
<p>$n$不是质数的时候也可能满足。</p>
<p>假如一个都不满足，那么一定不是质数。</p>
<hr>
<p>补充证明：</p>
<ol>
<li>Fermat 素性检验</li>
</ol>
<p>由费马小定理可知，若 $p$ 是素数：$a^{p - 1} \equiv 1 \pmod p$</p>
<p>那么当这个等式成立的时候，$p$ 就一定是素数？</p>
<p>不一定。</p>
<p>有部分合数无法被筛掉。</p>
<p>这个时候更换底数，可以增大它是素数的概率，但不管怎么换，仍然有合数无法被筛掉，所以我们需要引入另一个定理。</p>
<ol start="2">
<li>二次探测定理</li>
</ol>
<p>对于素数 $p$ 若 $x^{2}\equiv 1 \pmod p$ 那么小于 $p$ 的解只有两个，$x_{1}&#x3D; 1, x_{2} &#x3D; p - 1$。</p>
<p>证明：$x^{2} - 1 \equiv 0 \pmod p\to(x + 1)(x - 1) \equiv 0\pmod p$ ，</p>
<p>那么要么是零，要么是 p 的倍数。</p>
<p>所以小于 $p$ 的解就是这两个。</p>
<p>两者结合一下：</p>
<p>先用 Fermat 检测得到 $a^{p - 1} \equiv 1 \pmod p$，这时候保证 $p - 1$ 是偶数，不然 p 是偶数就直接筛掉，那么就可以拆分为 $(a^{\frac{p-1}2})^2\equiv1\pmod{p}$ ，就可以用二次探测定理来判断了。</p>
<p>如果还符合，那就可以再进行同样的操作，直到里面的指数变为奇数。</p>
<p>也就是说，我们把 $p - 1 &#x3D; u \times 2^t$（u 是奇数），对 $a^u,a^{u\times2},a^{u\times2^2}$ 等数进行检验，它们的解要么全是一，要么出现 p - 1，注意，一开始没提取的时候是不能等于 p - 1 的，因为要满足费马小定理。</p>
<p>注意特判 a 是 p 的倍数的情况。</p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/349360074" >参考文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>#Q 为什么从出现解为 p - 1 后解就必须全是 1？</p>
<p>假如一个$a$只成立性质一，<del>什么也说明不了</del>，说明$n$有可能是质数。</p>
<p>换了一个$a$，两个性质仍然有一个成立，那么这个概率就会提高。</p>
<p>不断地往里带，假如一直成立的话，那么概率就会不断提高。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301018351.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301022385.webp"
                      alt="image.png|600"
                ></p>
<p>在$i$不断加一的过程中 $a^d$在不断地在平方</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mb</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> a)</span><span class="comment">//检查是否符合定理中的一个，现在要求d和r</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d=n<span class="number">-1</span>,r=<span class="number">0</span>;<span class="comment">//不断拿d除以2</span></span><br><span class="line">    <span class="keyword">while</span>(d%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        d=d/<span class="number">2</span>,r++;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">ksm</span>(a,d,n);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//a的d次方已经算过了，每加一次</span></span><br><span class="line">        <span class="keyword">if</span>(x==n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%n;<span class="comment">//不然就平方一下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>假如 $a^d$ 满足解为 $1$，那么不断把它平方，得到的解也必然为 1，因此对于第一个条件我们只需要检测 $a^d$ 是否满足即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301024349.webp"
                      alt="image.png|600"
                ></p>
<p>枚举$d$和$r$以及快速幂复杂度都是$log_n$的</p>
<p>一半概率对，一半概率错</p>
<p>$20$次检查后，仍然错误的概率就是$\frac 1 {2^{20}}$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301029032.webp"
                      alt="image.png|600"
                ></p>
<p>$a\in1\sim n-1$</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">23</span>;i++)<span class="comment">//正常20次是足够的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="built_in">rand</span>()%(n<span class="number">-1</span>)<span class="number">+1</span>;<span class="comment">//随机检查 1~n-1</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">mb</span>(n,a)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>第二种方法：定义一个<strong>质数表</strong></p>
<p>在$10^{18}$以内质数的概率更高(<em>前人的智慧</em>)</p>
<p>质数表可以自己去搜。</p>
<ul>
<li><p>对于 $2^{32}$ 以内的判素数，选 2, 7, 61 即可</p>
</li>
<li><p>对于 $2^{64}$ 以内的判素数，选 2, 325, 9375, 28178, 450775, 9780504, 1795265022 即可。</p>
</li>
<li><p>对于考场上，选前 12 个质数作为底数即可，<br>2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37，适用于 $2^{78}$ 以内的判断素数。</p>
</li>
</ul>
<p><a class="link"   href="https://www.luogu.com.cn/blog/wangrx/miller-rabin" >参考文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="EXGCD"><a href="#EXGCD" class="headerlink" title="EXGCD"></a>EXGCD</h2><p>$gcd(a,b)&#x3D;g$</p>
<p><strong>解决的问题</strong> 是为了解出$ax+by&#x3D;g$</p>
<p>未知数个数比方程数多的时候，这个方程通常有无数解</p>
<p>我们只需要找到一组解</p>
<p>用辗转相除求x,y?</p>
<p>$gcd(a,b)\to gcd(b,a%b)$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301058888.webp"
                      alt="image.png|600"
                ></p>
<p>倒推</p>
<p>先讲讲<strong>最后一层</strong></p>
<p>最终一定会得到：</p>
<p>$gcd(a,0)&#x3D;a$</p>
<p>因为每次得到的一定是它们<strong>最大公因数</strong>的倍数</p>
<p>$x \cdot a+y \cdot 0&#x3D;a$</p>
<p>$x&#x3D;1,y&#x3D;0(random)$</p>
<p>假设已经找到了$x’ y’$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301100694.webp"
                      alt="image.png|600"
                ></p>
<p>怎么变成左边的式子？</p>
<p>只能推出$y&#x3D;x’$，而不知道$x$，所以要往下化简</p>
<p>余数&#x3D;被除数-除数乘商</p>
<p>$a% b&#x3D; a - \lfloor \frac a b \rfloor \times b$</p>
<p>替换一下并整理：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301102376.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301103081.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301104954.webp"
                      alt="image.png|600"
                ></p>
<p>和原来的比对一下：</p>
<p>$ax+by&#x3D;g$</p>
<p>$\therefore$</p>
<p>$x&#x3D;y’$</p>
<p>$y&#x3D;x’-y’ \lfloor \frac a b \rfloor$</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span><span class="comment">//g=gcd(a,b),xy通过取地址传参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;<span class="comment">//gcd</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> xp,yp;</span><br><span class="line">    <span class="type">int</span> g=<span class="built_in">exgcd</span>(b,a%b,xp,yp);<span class="comment">//最大公因数//x&#x27;y&#x27;</span></span><br><span class="line">    <span class="comment">// 返回后一定满足xp*b+yp*a%b=g</span></span><br><span class="line">    <span class="comment">// xp*b+yp*(a-b*(a/b))=g</span></span><br><span class="line">    <span class="comment">// xp*b+yp*a-yp*b*(a/b)=g</span></span><br><span class="line">    <span class="comment">// yp*a+(xp-yp*(a/b))*b=g</span></span><br><span class="line">    x=yp;<span class="comment">//y&#x27;</span></span><br><span class="line">    y=xp-yp*(a/b);<span class="comment">//每层的xy是变的，g一直都是a b的gcd</span></span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样就可以把$x$，$y$求出来</p>
<p>如果想要其它的解，那么只需要改变一下$y$的值就可以解出其它的解</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><blockquote>
<p>$f(x) &#x3D; ax+by$</p>
</blockquote>
<p>$x,y$都是<strong>任意整数</strong></p>
<p>这个式子能表示出的<strong>最小正整数</strong>就是$gcd(a,b)$</p>
<p>证明:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301123858.webp"
                      alt="image.png|600"
                ></p>
<p>$x$ $y$ 不管怎么变，相加都是$g$的倍数，</p>
<p>不能表示任意的数，</p>
<p>只能表示$g$的倍数，</p>
<p>所以最小的正整数就是它自己。</p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/155721651" >详细证明过程<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<hr>
<p>比如：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301124607.webp"
                      alt="image.png|600"
                ></p>
<p>这个方程没有整数解，</p>
<p>满足这个条件的前提下，</p>
<p>$gcd(a,b)|z$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301125175.webp"
                      alt="image.png|600"
                ></p>
<p>它才有整数解。</p>
<p>那么怎么解？</p>
<p>$z$是$g$的倍数</p>
<p>那么把<code>exgcd</code>解出后，两边同时乘$k$就是这个方程的解。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301126589.webp"
                      alt="image.png|600"
                ></p>
<h3 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h3><blockquote>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P1082" >P1082<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<p>假如不互质，那么这道题就无解，所以互质</p>
<p>$ax\equiv 1 \pmod b$</p>
<p>$ax$一定等于$yb+1$</p>
<p>$ax-by&#x3D;1$</p>
<p>和$exgcd$的区别？</p>
<p>没有区别</p>
<p>解出来解后给$y$加上负号就可以了</p>
<p>要求的时$x$</p>
<p>那么怎么保证正整数x最小呢？</p>
<p>随便找到一组解</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301411776.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301413608.webp"
                      alt="image.png|600"
                ></p>
<p>把$x$变大$n$</p>
<p>$y$调小$m$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301413753.webp"
                      alt="image.png|600"
                ></p>
<p>我们发现$2n&#x3D;3m$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301415958.webp"
                      alt="image.png|600"
                ></p>
<p>这样就可以把所有的解写出来</p>
<p>设解出一组解$x&#x3D;x_0,y&#x3D;y_0$</p>
<p>即$an&#x3D;bm$</p>
<p>$\frac a b&#x3D;\frac m n$</p>
<p>$$<br>\begin{cases}<br>x&#x3D;x_0+bk \<br>y&#x3D;y_0-ak \<br>\end{cases}<br>$$</p>
<p>这就是所有的解吗？</p>
<p><em>显然不是</em></p>
<p>假如$a&#x3D;4，b&#x3D;6$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301421189.webp"
                      alt="image.png|600"
                ></p>
<p>要保证$abk-abk&#x3D;0$又要保证$ab$的<strong>最大公因数</strong>不变，并且保证要整除，所以除去<strong>最大公因数</strong>最优。</p>
<p>$$<br>\begin{cases}<br>x&#x3D;x_0+{\frac b g}k \<br>y&#x3D;y_0-{\frac a g}k \<br>\end{cases}<br>$$</p>
<p>我们发现$x% \frac b g&#x3D;x_0$</p>
<p>这道题中$g&#x3D;1$</p>
<p>$x% b &#x3D;x_0$</p>
<p>每个$x$都是$b$的倍数$+n$</p>
<p>那么最小的时候就是 $x&#x3D; x \bmod b$ 的时候。</p>
<hr>
<p>假如方程两边同乘一个系数 k</p>
<p>方程变为：</p>
<p>$akx + bky &#x3D; kg$</p>
<p>简写一下就是：</p>
<p>$Ax + By &#x3D; G$</p>
<p>$$A &#x3D; \frac{G}{g}\times{a},a&#x3D;\frac{g}{G}\times A$$</p>
<p>$$B &#x3D; \frac{G}{g}\times{b},b&#x3D;\frac{g}{G}\times B$$</p>
<p>然后用 Exgcd 进行求解，</p>
<p>解得：</p>
<p>$$<br>\begin{cases}<br>x&#x3D;x_0 \<br>y&#x3D;y_0<br>\end{cases}<br>$$</p>
<p>这是随便的一组解，并且不是 $Ax + By &#x3D; G$ 的解，而是 $ax + by &#x3D; g$ 的解，因为在计算 $y’$ 的时候乘的系数是 $\lfloor{\frac a b}\rfloor$ 。而 a、b 等比增加不会导致这个值改变，也不会导致 $gcd(a, b)$ 发生改变，所以最后得到的解要乘上系数 $\frac G g &#x3D; k$ 才是 $Ax + By &#x3D; G$ 的解。</p>
<p>也就是说方程的解为：</p>
<p>$$<br>\begin{cases}<br>x&#x3D;kx_0 \<br>y&#x3D;ky_0<br>\end{cases}<br>$$</p>
<p>先看原来的方程，x 最小为多少？</p>
<p>$$x_0\bmod{\frac b g} &#x3D; x_0\bmod{\frac B G}$$</p>
<p>那么在新方程里，x 最小为：</p>
<p>$$<br>\begin{aligned}<br>x_{min}&amp;&#x3D;x_0\times{\frac G g}\bmod{\frac B G\times\frac G g}\ &amp;&#x3D; x_0\times{\frac G g}\bmod{\frac B g}\<br>\end{aligned}<br>$$</p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P1516" >练习题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>有一堆<strong>同余方程</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301427824.webp"
                      alt="image.png|600"
                ></p>
<p>我们现在要把它们合并为一个方程</p>
<p>这个方程就是我们要求的</p>
<p>首先想解$x$</p>
<p>$x$有几个解呢？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301429779.webp"
                      alt="image.png|600"
                ></p>
<p>一共有$n+1$个未知数</p>
<p>$n$个方程</p>
<p>理论上会有无数组解</p>
<p>假设现在只有两个方程</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301430010.webp"
                      alt="image.png|600"
                ></p>
<p>$x\in{1,16,31\dots}$<br>$x&#x3D;1+15k$</p>
<p>那么最后的解就是$x%15&#x3D;1$</p>
<p>两个同余方程解出一个同余方程</p>
<p>那么$n$个呢？</p>
<p>可以不断拿两个同余方程合并，合并$n-1$次</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301433401.webp"
                      alt="image.png|600"
                ></p>
<p>最后必然也会只剩下一个同余方程</p>
<p>那么怎么把两个方程合并为一个方程呢？</p>
<h4 id="大数翻倍法"><a href="#大数翻倍法" class="headerlink" title="大数翻倍法"></a>大数翻倍法</h4><blockquote>
<p>ZHX:我很推荐你们用大数翻倍法，好写还不容易被卡，不像EXGCD难写还难调</p>
</blockquote>
<p>$$<br>\begin{cases}<br>x_1%p_1&#x3D;a_1 \<br>x_2%p_2&#x3D;a_2 \<br>\end{cases}<br>$$<br>$$\downarrow$$<br>$$x%p&#x3D;a$$</p>
<p>考虑枚举，那么怎么优化呢？</p>
<p>可以强行让它满足第一个方程，再看它满不满足第二个方程</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301437414.webp"
                      alt="image.png|600"
                ></p>
<p>在$a_1$的基础上不断加上$p_1$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301440594.webp"
                      alt="image.png|600"
                ></p>
<p>这样对吗？</p>
<p>假如这个方程无解，那么就会死循环</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301442450.webp"
                      alt="image.png|600"
                ></p>
<p>这时候$%p2$就是$a_1$，相当于一个新的周期</p>
<p>超过<strong>最小公倍数</strong>就可以退出循环了</p>
<p><strong>最小公倍数就是新方程中被模的数</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301448021.webp"
                      alt="image.png|600"
                ></p>
<p>$x%15&#x3D;7$</p>
<p>假如让这个$x$模$3$的话</p>
<p>也就是$kp+7%3$,而$p$又是$3$的倍数，所以满足$x%3&#x3D;1$,t 同理满足$x%5&#x3D;2$</p>
<p>于是就是</p>
<p>$x%l&#x3D;a$</p>
<p>极端情况下会运行$p_2$次</p>
<p>时间复杂度是$O(p_2)$次</p>
<p><em>大数翻倍法？</em></p>
<p>让大的数翻倍</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301452389.webp"
                      alt="image.png|600"
                ></p>
<p>让枚举次数变为更小的p1</p>
<p>时间时间复杂度为$O(min(p1,p2))$</p>
<p>最后解出来的$p$是所有$p$的$lcm$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301456104.webp"
                      alt="image.png|600"
                ></p>
<p>复杂度</p>
<p>当$p$互质时候</p>
<p>要让所有$p$相乘小于$10^{18}$</p>
<p>所以一般不太可能炸掉</p>
<p>想卡也不是很好卡</p>
<h4 id="EXGCD法"><a href="#EXGCD法" class="headerlink" title="EXGCD法"></a>EXGCD法</h4><p>$$<br>\begin{cases}<br>x_1%p_1&#x3D;a_1 \<br>x_2%p_2&#x3D;a_2 \<br>\end{cases}<br>$$</p>
<p>$$<br>\downarrow<br>$$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301515598.webp"
                      alt="image.png|600"
                ></p>
<p>可以只看后半部分</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301516829.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301517447.webp"
                      alt="image.png|600"
                ></p>
<p>$$ \downarrow$$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301517282.webp"
                      alt="image.png|600"
                ></p>
<p>通过扩展欧几里得把$k1、k2$解出来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301957534.webp"
                      alt="image.png|600"
                ></p>
<p>这里相当于$+(-k_2)$</p>
<p>那么求出来以后$k_2&#x3D;-k_2$即可</p>
<p>我按照$k_{1}\times p_{1}+k_{2}\times p_{2}&#x3D;a_2-a_1$求得的$x$</p>
<p>我现在想知道$k_{1}\times p_{1}-k_{2}\times p_{2}&#x3D;a_2-a_1$的解</p>
<p>那么令$k_2&#x3D;-k_2$即可</p>
<h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><h3 id="埃式筛"><a href="#埃式筛" class="headerlink" title="埃式筛"></a>埃式筛</h3><p>给一个数$n$</p>
<p>尽量少的时间内把$1\to n$所有的质数求出来</p>
<p>枚举$a$的所有倍数</p>
<p>$a$的倍数一定不是质数</p>
<p>把所有数的倍数都标记一遍</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">2</span>;a&lt;=n;a++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> b=a+a;b&lt;=n;n+=a)<span class="comment">//枚举a的所有倍数</span></span><br><span class="line">        not_prime[b]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">2</span>;a&lt;=n;a++)</span><br><span class="line">    <span class="keyword">if</span>(not_prime[a]==<span class="literal">false</span>) </span><br><span class="line">        prime[++cnt]=a;</span><br></pre></td></tr></table></figure></div>

<p>复杂度：$O(nlogn)$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301540448.webp"
                      alt="image.png|600"
                ></p>
<p>调和集数，约等于为$logn$</p>
<p>所以埃式筛的复杂度为$nlogn$</p>
<h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>首先,$4$有必要枚举吗？</p>
<p>因为枚举$2$的标记的时候$4$的标记已经被标记了</p>
<p>1.只需要枚举质数的倍数就行</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">2</span>;a&lt;=n;a++)</span><br><span class="line">        <span class="keyword">if</span>(not_prime[a]==flase)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b=a+a;b&lt;=n;n+=a)<span class="comment">//枚举a的所有倍数</span></span><br><span class="line">                not_prime[b]=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure></div>

<p>复杂度:$nloglogn$</p>
<p>证明一下为什么可以求倍数的过程中找质数</p>
<p>假设我枚举到了第$22$倍</p>
<p>那么我$22$之前的所有质数一定找完了</p>
<p>如果第$22$个没被标记，它一定不可能是一个和数</p>
<p>因为它只能被小于等于它的数标记</p>
<p>而不能被$23、24$标记</p>
<h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>现在一个数仍然有可能被筛多次</p>
<p>比如$6$，会被$2$和$3$都筛一次</p>
<p>比如$30$，会被$2$和$3$和$5$都筛一次</p>
<p>每个数都会被它的质因子筛一次</p>
<p>因为每个数质因子个数不是一个，因此大于$n$</p>
<p>我们要保证每个数只被筛一次</p>
<p>我们让它被最小的质因子筛掉</p>
<p>比如$6$只被$2$筛</p>
<p>$55$只被$5$筛</p>
<p><em>看代码</em></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="comment">//先枚举倍数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(not_prime[i]==<span class="literal">false</span>)<span class="comment">//一定是质数吗？有没有可能只是没被标为true</span></span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        prime[cnt]=i;<span class="comment">//存进质数表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=prime[j]*i;<span class="comment">//筛掉第j个质数的i倍</span></span><br><span class="line">        <span class="keyword">if</span>(x&gt;n) <span class="comment">//质数表是从小往大枚举的，这是第一个大于n的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        not_prime[x]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>还是$nloglogn$</p>
<p>加上一句话：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isprime[N];</span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(isprime, <span class="literal">true</span>, <span class="built_in">sizeof</span>(isprime));</span><br><span class="line">	isprime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (isprime[i]) prime[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			isprime[i * prime[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301615037.webp"
                      alt="image.png|600"
                ></p>
<p>首先找出了$i&#x3D;2$</p>
<p>$x&#x3D;4$</p>
<p>$4$就不是质数</p>
<p>第二轮，$3$也是质数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301616621.webp"
                      alt="image.png|600"
                ></p>
<p>会把$6$和$9$也筛掉</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301617580.webp"
                      alt="image.png|600"
                ></p>
<p>筛掉$8$之后，$4$是第一个质数的倍数，会<code>break</code></p>
<p>不会枚举到第三个质数</p>
<p>$12$也就没有筛掉</p>
<p>枚举到$i&#x3D;6$时</p>
<p>此时i最小的质因子就是$prime[j]$</p>
<p><strong>证明：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304302021073.webp"
                      alt="image.png|600"
                ></p>
<p>假如没有<code>break</code></p>
<p>那么就会枚举第$j+1$个质数</p>
<p>$x&#x3D;prime[j+1]*i$</p>
<p>而$i&#x3D;k \times prime[j]$</p>
<p>$x&#x3D;prime[j+1] \times k \times prime[j]$</p>
<p>由于质数表是往后递增的，因此最小质因子就是第一次被整除的$prime[j]$</p>
<p><em>小练习</em>：<a class="link"   href="https://www.luogu.com.cn/problem/P3383" >P3383:线性筛素数<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<hr>
<p><em>常用大小：</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301627305.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301628330.webp"
                      alt="image.png|600"
                ></p>
<hr>
<h3 id="求积性函数"><a href="#求积性函数" class="headerlink" title="求积性函数"></a>求积性函数</h3><p><strong>定义：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301631980.webp"
                      alt="image.png|600"
                ></p>
<p><strong>前提</strong>：$a$和$b$互质</p>
<p><strong>完全积性函数：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301632192.webp"
                      alt="image.png|600"
                ></p>
<p><strong>不需要满足互质</strong>的条件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301633307.webp"
                      alt="image.png|600"
                ></p>
<p>[[#欧拉定理|欧拉函数]]其实就是一个<strong>积性函数</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301636339.webp"
                      alt="image.png|600"
                ></p>
<p>$q$都是质数</p>
<p>$\varphi( )&#x3D;？$</p>
<p><strong>证明过程：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301639198.webp"
                      alt="image.png|600"
                ></p>
<p>我们发现$\varphi(mn)$的结果拆成两部分也就是$n$和$m$</p>
<p>$O(n)$求$1\to n$的值</p>
<p>$prime[j]$ 和 $prime[i]$</p>
<p>有可能不互质</p>
<p>假设它全互质，先按照函数定义求</p>
<p>那么<strong>不互质</strong>的怎么处理(也就是i和)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301646087.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301646101.webp"
                      alt="image.png|600"
                ></p>
<p>现在算$\varphi(i\cdot p_j)$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301646256.webp"
                      alt="image.png|600"
                ></p>
<p>$\because$  $i$是$p_j$的整数倍</p>
<p>$\therefore$  <strong>质因子</strong>没有发生变化,也就是$prime[j]$的质因子和$i$的质因子都是$q$,只是次数不一样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301649030.webp"
                      alt="image.png|600"
                ></p>
<p>后面那个东西就是$\varphi(i)$ </p>
<p>所有数分为1+质数+和数</p>
<p>$\varphi(1)&#x3D;1$</p>
<p>当$n$为质数，$\varphi(n)&#x3D;n-1$</p>
<p>和数分为以上互质和不互质两种情况</p>
<h2 id="BSGS-Baby-Step-Giant-Step"><a href="#BSGS-Baby-Step-Giant-Step" class="headerlink" title="BSGS(Baby Step Giant Step)"></a>BSGS(Baby Step Giant Step)</h2><p>$a,b,p$</p>
<p>$p$是质数</p>
<p>求$a^x%p&#x3D;b$</p>
<p>也就是$a^x\equiv b \pmod  p$</p>
<p>$a,b,p\le 10^9$</p>
<p>写一下暴力</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">1</span>;<span class="comment">//a的零次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;;x++)<span class="comment">//从0次开始枚举</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==b) <span class="keyword">return</span> x;</span><br><span class="line">        v=<span class="number">1ll</span>*v*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>枚举到符合条件为止</p>
<p>假如无解，就会死循环</p>
<p>怎么判断无解？</p>
<p>初始状态就是$1$</p>
<p>再次出现若循环后依旧无解，那么就是无解</p>
<p>$v$的范围是$0$到$p-1$</p>
<p>[[#费马小定理|费马小定理]]：</p>
<p>一定会从1开始循环</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010839896.webp"
                      alt="image.png|600"
                ></p>
<p>$a^{p-1}%p&#x3D;1$</p>
<p>$a^0%p&#x3D;1$</p>
<p>循环长度为$p-1$</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">1</span>;<span class="comment">//a的零次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;p<span class="number">-1</span>;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==b) <span class="keyword">return</span> x;</span><br><span class="line">        v=<span class="number">1ll</span>*v*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>$a^0&#x3D;a^{p-1}&#x3D;1$</p>
<p><em>怎么优化呢？</em></p>
<p>答案一定会在$a^{0\to p-1}$中出现</p>
<p>那我分个组</p>
<p>第零组是到从$a^0$到$a^{s-1}$</p>
<p>$s$为每组的大小</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010845006.webp"
                      alt="image.png|600"
                ></p>
<p>把第零组的每个数都$for$一下</p>
<p>看下这$s$个数里有没有$b$</p>
<p>这样就知道答案的位置在哪里了</p>
<p>如果不在第零组，那么就去看第一组</p>
<p>还是$for$一遍</p>
<p>$\dots\dots$</p>
<p>还是要枚举$p$次</p>
<p>那么第二次有没有更聪明的找法呢？</p>
<p>第零组乘以$a$的$s$次方就是第一组</p>
<p>如果要变回去的话那就是乘以$a$的$-s$次方</p>
<p>假如$b$在第一组出现了，那么第零组会出现下面这个东西</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010850813.webp"
                      alt="image.png|600"
                ></p>
<p>其实就是找第一组$b\cdot a^{-s}$</p>
<p>假如$b$在第$i$组出现了，那就要找第一组的$a^{-is}$</p>
<p>把每一组都映射到第一组</p>
<p>这样就可以很方便地查询了</p>
<p><code>STL</code>有一个东西叫<code>set</code>，可以存一堆数，查找一个数在这堆数中是否出现过</p>
<p><strong>Set</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">begin</span>();<span class="comment">// 返回指向第一个元素的迭代器</span></span><br><span class="line"><span class="built_in">end</span>();<span class="comment">// 返回指向迭代器的最末尾处（即最后一个元素的下一个位置）</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">// 清除所有元素</span></span><br><span class="line"><span class="built_in">count</span>();<span class="comment">// 返回某个值元素的个数</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">// 如果集合为空，返回true</span></span><br><span class="line"><span class="built_in">equal_range</span>();<span class="comment">//返回集合中与给定值相等的上下限的两个迭代器</span></span><br><span class="line"><span class="built_in">erase</span>()<span class="comment">//–删除集合中的元素</span></span><br><span class="line"><span class="built_in">find</span>()<span class="comment">//–返回一个指向被查找到元素的迭代器</span></span><br><span class="line"><span class="built_in">get_allocator</span>()<span class="comment">//–返回集合的分配器</span></span><br><span class="line"><span class="built_in">insert</span>()<span class="comment">//–在集合中插入元素</span></span><br><span class="line"><span class="built_in">lower_bound</span>()<span class="comment">//–返回指向大于（或等于）某值的第一个元素的迭代器</span></span><br><span class="line"><span class="built_in">key_comp</span>()<span class="comment">//–返回一个用于元素间值比较的函数</span></span><br><span class="line"><span class="built_in">max_size</span>()<span class="comment">//–返回集合能容纳的元素的最大限值</span></span><br><span class="line"><span class="built_in">rbegin</span>()<span class="comment">//–返回指向集合中最后一个元素的反向迭代器</span></span><br><span class="line"><span class="built_in">rend</span>()<span class="comment">//–返回指向集合中第一个元素的反向迭代器</span></span><br><span class="line"><span class="built_in">size</span>()<span class="comment">//–集合中元素的数目</span></span><br><span class="line"><span class="built_in">swap</span>()<span class="comment">//–交换两个集合变量</span></span><br><span class="line"><span class="built_in">upper_bound</span>()<span class="comment">//–返回大于某个值元素的迭代器</span></span><br><span class="line"><span class="built_in">value_comp</span>()<span class="comment">//–返回一个用于比较元素间的值的函数</span></span><br></pre></td></tr></table></figure></div>

<p>看答案是否在第$i$行里面,<strong>第一行是第$0$行</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i*s&lt;=p;i++)<span class="comment">//看答案是否在第i行里面,第一行是第0行//超过p次方就会开始循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//看b乘以a的-is次方是否在第零行出现——逆元</span></span><br><span class="line">        <span class="type">int</span> c=<span class="number">1ll</span>*b*<span class="built_in">ksm</span>(<span class="built_in">ksm</span>(a,i*s,p),p<span class="number">-2</span>,p)%p;<span class="comment">//快速幂</span></span><br><span class="line">        <span class="keyword">if</span>(se.<span class="built_in">count</span>(c)!=<span class="number">0</span>)<span class="comment">//出现次数 0/1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//答案在第i行,暴力一遍</span></span><br><span class="line">            <span class="type">int</span> v=<span class="built_in">ksm</span>(a,i*s,p);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i*s;;j++)<span class="comment">//一定会找到答案</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(v==b) <span class="keyword">return</span> j;<span class="comment">//找到答案</span></span><br><span class="line">                v=<span class="number">1ll</span>*v*a%p;<span class="comment">//枚举次数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>由于越往下找答案肯定就越大，那么第一次找到一定就是最小值</strong></p>
<p><strong>注意这里$i*s$可能会爆<code>int</code>，要开<code>long long</code></strong></p>
<p>第一层循环$\frac ps$次</p>
<p>第二层循环枚举这一组中每一个数</p>
<p>最坏的情况就是$O(s)$</p>
<p>第二次循环只会执行一次，所以是加法原理</p>
<p>$O(\frac ps+s)$</p>
<p>$O(n+logn)&#x3D;O(n)$</p>
<p>我们只关心更大的</p>
<p>所以复杂度就是$O(max(\frac ps,s))$</p>
<p>复杂度由较大值决定</p>
<p>所以$\frac ps&#x3D;s$的时候复杂度最优（基本不等式）</p>
<p>$s&#x3D;\sqrt p$</p>
<p><code>insert</code>和<code>count</code>是$log$的</p>
<p>这也就是分块的思想</p>
<p>若要访问出现多少次，用<code>map</code></p>
<h1 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h1><h2 id="引入定义式"><a href="#引入定义式" class="headerlink" title="引入定义式"></a>引入定义式</h2><p><strong>小栗子：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010917302.webp"
                      alt="image.png|600"
                ></p>
<p>假如条件是<strong>互斥</strong>的（不能同时成立），那么就是加法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010918133.webp"
                      alt="image.png|600"
                ></p>
<p>前面的选择和后面的选择是不同阶段的选择，前一阶段的条件对后续条件的选择没有影响</p>
<p>就乘起来</p>
<hr>
<p>从三个人选出来两个人站成一列，有几种选法？ ——<em>排列</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010922121.webp"
                      alt="image.png|600"
                ></p>
<p>有六种选法</p>
<p>那假如从$n$个人中选$m$个人站成一列,考虑这$m$个人<strong>内部的顺序</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010924291.webp"
                      alt="image.png|600"
                ></p>
<p>$$<br>\begin{aligned}<br>P(n,m)&amp;&#x3D;n\cdot (n-1)\cdot(n-2)\cdot(n-3)\cdot(n-4)\cdot(n-5)\ldots \cdot(n-m+1)\<br>&amp;&#x3D;\frac {n!}{(n-m)!}<br>\end{aligned}<br>$$</p>
<hr>
<p>这样是考虑<strong>内部顺序</strong>的情况</p>
<p>假如不考虑<strong>内部的顺序</strong>呢？ ——<em>组合</em></p>
<p>$C(n,m)&#x3D;n\cdot (n-1)\cdot(n-2)\cdot(n-3)\cdot(n-4)\cdot(n-5)\dots (n-m+1)$? ——<em>显然不是</em></p>
<p>$1,2$和$2,1$是同一种方案，也就是$m$个人的内部随便怎么排都可以，都是一种方案</p>
<p>$m$个人内部随便排的方案数其实就是记录顺序地从$m$个人中选$m$个人，也就是：</p>
<p>$$<br>{m}\times{(m-1)}\times{(m-2)}\times{(m-3)}\times{(m-4)}\times{\ldots}\times1<br>$$</p>
<p>想想第一个人选的时候有$m$种可能</p>
<p>那选第二个人的时候就有$m-1$种可能</p>
<p>以此类推</p>
<p>因为每次选择都是独立的，所以概率要相乘</p>
<p>也就是有$m!$种方案</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010929411.webp"
                      alt="image.png|600"
                ></p>
<p>三个人可以引伸为<strong>六种方案</strong></p>
<p>也就是$3！$种方案</p>
<p>$m$个人内部可以有多少种顺序呢，答案是有$m!$种顺序，那就有$m!$种方案为同一种方案</p>
<p>$$<br>\begin{aligned}<br>C(n,m)&amp;&#x3D;\frac {n\cdot (n-1)\cdot(n-2)\cdot(n-3)\cdot(n-4)\cdot(n-5)\dots (n-m+1)}{m!}\<br>&amp;&#x3D;\frac {P(n,m)}{m!}\<br>&amp;&#x3D;\frac {n!}{m!(n-m)!}\<br>\end{aligned}<br>$$</p>
<h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p>$C(n,0)&#x3D;1$</p>
<p>$C(n,n)&#x3D;1$</p>
<p>$P(n,n)&#x3D;n!$</p>
<h3 id="1-C-n-m-C-n-n-m"><a href="#1-C-n-m-C-n-n-m" class="headerlink" title="1.C(n,m)&#x3D;C(n,n-m)"></a>1.C(n,m)&#x3D;C(n,n-m)</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010935737.webp"
                      alt="image.png|600"
                ></p>
<p>保留$m$个和丢掉$n-m$个方案数相同</p>
<p>或者带进式子，会发现式子一样</p>
<h3 id="2-🚩递推式"><a href="#2-🚩递推式" class="headerlink" title="2.🚩递推式"></a>2.🚩递推式</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010937199.webp"
                      alt="image.png|600"
                ></p>
<p>它们分别代表：</p>
<ul>
<li><p>$n$个选$m$个的<strong>方案数</strong></p>
</li>
<li><p>$n-1$个选$m-1$个的<strong>方案数</strong></p>
</li>
<li><p>$n-1$选$m$个的<strong>方案数</strong></p>
</li>
</ul>
<p>可以用背包的思路</p>
<p>可以用第$n$个物品要<em>选&#x2F;不选</em></p>
<ul>
<li><p>如果选的话，方案数就是选在$n-1$个数种选$m-1$个数的方案数，也就是$C(n-1,m-1)$</p>
</li>
<li><p>如果不选的话，方案数就是在在$n-1$个数中选$m$个数的方案数，也就是$C(n-1,m)$</p>
</li>
</ul>
<p>因为选了以后就不能选了</p>
<p>所以是<em>加法原理</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010941373.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010945910.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010946576.webp"
                      alt="image.png|600"
                ></p>
<p>这不就是<em>杨辉三角</em>嘛!</p>
<h3 id="3-n个物品随便选"><a href="#3-n个物品随便选" class="headerlink" title="3.n个物品随便选"></a>3.n个物品随便选</h3><p>$C(n,0)+C(n,1)+C(n,2)+C(n,3)+\dots +C(n,n)&#x3D;2^n$</p>
<ul>
<li><p>$n$个物品选$0$个物品的方案数</p>
</li>
<li><p>*$n$个物品选$1$个物品的方案数</p>
</li>
<li><p>*$n$个物品选$2$个物品的方案数</p>
</li>
<li><p>$n$个物品选$3$个物品的方案数</p>
</li>
<li><p>$n$个物品选$4$个物品的方案数</p>
</li>
</ul>
<p>$\dots$</p>
<ul>
<li>$n$个物品选$n$个物品的方案数</li>
</ul>
<p>也就是从$n$个物品里<strong>任意选多少</strong>个的方案数</p>
<p>第一个物品要么选要么不选</p>
<p>一直到第n个物品，每个物品都是两种选择</p>
<p>那就是$2^n$</p>
<h3 id="4-奇方案-偶方案"><a href="#4-奇方案-偶方案" class="headerlink" title="4.奇方案&#x3D;偶方案"></a>4.奇方案&#x3D;偶方案</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011006475.webp"
                      alt="image.png|600"
                ></p>
<p>加到&#x2F;减到$C(n,n)$为止</p>
<p>移一下项</p>
<p>就是选偶数个东西的方案数等于选奇数个东西的方案数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010937199.webp"
                      alt="image.png|600"
                ></p>
<p>可以画出当前这行的杨辉三角形</p>
<p>每一行的第一个都是$1$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011010633.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011011482.webp"
                      alt="image.png|600"
                ></p>
<p>偶数位置的和恰好把上一行每一个数加了起来</p>
<p>那假如是<strong>奇数</strong>？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011012723.webp"
                      alt="image.png|600"
                ></p>
<p>也恰好把上一行所有位置加起来</p>
<p><strong>选奇数的方案数&#x3D;选偶数的方案数&#x3D;</strong>$2^{n-1}$</p>
<h3 id="5-二项式定理"><a href="#5-二项式定理" class="headerlink" title="5.二项式定理"></a>5.二项式定理</h3><p>$(x+y)^0&#x3D;1$</p>
<p>$(x+y)^1&#x3D;x+y$</p>
<p>$(x+y)^2&#x3D;x^2+2xy+y^2$</p>
<p>$(x+y)^3&#x3D;x^3+3x^2y+3xy^2+y^3$</p>
<p>$(x+y)^4&#x3D;x^4+4x^3y+x^2y^2+4xy^3+y^4$</p>
<p>这不也是一个<em>杨辉三角</em>嘛</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011017334.webp"
                      alt="image.png|600"
                ></p>
<p>每行从左到右$x$次数逐渐减小，$y$的次数逐渐增加，系数就是杨辉三角数</p>
<ul>
<li>$(x+y)^n&#x3D;C(n,0)x^ny^0+C(n,1)x^{n-1}y^1+\dots+C(n,n)x^0y^n$</li>
</ul>
<p>但是这样写很麻烦</p>
<p>$\downarrow$</p>
<p><strong>求和运算符：</strong>$\Sigma$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011022670.webp"
                      alt="image.png|600"
                ></p>
<ul>
<li>$&#x3D;\sum^n \limits_{i&#x3D;0}C(n,i)x^{n-i}y^i$</li>
</ul>
<h3 id="6-📌组合数的卷积（展开式）"><a href="#6-📌组合数的卷积（展开式）" class="headerlink" title="6.📌组合数的卷积（展开式）"></a>6.📌组合数的卷积（展开式）</h3><p>$$<br>\begin{aligned}<br>C(n,m)&amp;&#x3D;C(n-1,m-1)+C(n-1,m)\<br>&amp;&#x3D;C(n-2,m-2)+C(n-2,m-1)+C(n-2,m-1)+C(n-2,m)\<br>&amp;&#x3D;C(n-2,m-2)+2\cdot C(n-2,m-1)+C(n-2,m)\<br>&amp;&#x3D;C(n-3,m-3)+3C(n-3,m-2)+3C(n-3,m-1)+C(n-3,m)\<br>&amp;&#x3D;\dots\dots\<br>&amp;\downarrow \<br>\end{aligned}<br>$$</p>
<p>$$<br>\begin{aligned}<br>C(n,m)&amp;&#x3D;C(k,0)\cdot C(n-k,m-k)+C(k,1)\cdot C(n-k,m-k+1)+C(k,2)\cdot C(n-k,m-k+2)+\dots +C(k,k)\cdot C(n-k,m-k+k)\<br>\downarrow \<br>&amp;&#x3D;\sum^k\limits_{i&#x3D;0}C(k,i)\cdot C(n-k,m-i)<br>\end{aligned}<br>$$</p>
<p>$k$表示展开$k$次,我们发现展开后多项式的系数就是杨辉三角数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011029469.webp"
                      alt="image.png|600"
                ></p>
<p>$C(n,m)&#x3D;\sum^k\limits_{i&#x3D;0}C(k,i)\cdot C(n-k,m-k+i)&#x3D;$</p>
<h2 id="亿些数学题"><a href="#亿些数学题" class="headerlink" title="亿些数学题"></a>亿些数学题</h2><h3 id="1-组合"><a href="#1-组合" class="headerlink" title="1.组合"></a>1.组合</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011033937.webp"
                      alt="image.png|600"
                > </p>
<p>一个数可以被选<strong>任意多</strong>次</p>
<p>$\frac {n^m}{m!}$？</p>
<p>每种方案<strong>重复的次数</strong>不一样</p>
<p>比如123(<em>123,132,213,231,312,321</em>)，我有六种方式为一种方案</p>
<p>但假如是122(<em>122,212,221</em>)，我只有$3$种方式为一种方案</p>
<p>正因为每个数<strong>可以重复并且重复的次数不一样</strong>，因此不可以同除一个数</p>
<p>那就是$m个1，2，3，4，5，6$？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011038831.webp"
                      alt="image.png|600"
                ></p>
<p>也不对，每个$2$都是一个$2$</p>
<hr>
<p>首先选$m$个数</p>
<p>$a_1a_2a_3a_4a_5a_6…a_m$</p>
<p>排个序，那么它就是递增的</p>
<p>大于等于$1$小于等于$n$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011041121.webp"
                      alt="image.png|600"
                ></p>
<p>这个不等式解的个数</p>
<p>答案就是$C(n,m)$</p>
<p>所有的数从小于号变成了小于等于</p>
<p>现在要解的就是这个方程有多少组解</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011042717.webp"
                      alt="image.png|600"
                ></p>
<p>现在会解小于，考虑把小于等于转化为小于</p>
<p>那我再造$m$个变量</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011043630.webp"
                      alt="image.png|600"
                ></p>
<p>所以带进小于等于不等式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011045854.webp"
                      alt="image.png|600"
                ></p>
<p>也就是从$n+m-1$个数中选$m$个</p>
<p>$c$的方案数就是$C(n+m-1,m)$</p>
<p>每一组$b$的解都对应着一组$c$的解</p>
<p>所以b的方案数也就是$C(n+m-1,m)$</p>
<hr>
<p>相邻的不能选的情况呢？</p>
<h2 id="亿点代码题-卢卡斯定理"><a href="#亿点代码题-卢卡斯定理" class="headerlink" title="亿点代码题(卢卡斯定理)"></a>亿点代码题(卢卡斯定理)</h2><p>$n,m,p$</p>
<p>求$C(n,m)%p$</p>
<p>数据范围?</p>
<ol>
<li>$n,m$&lt;&#x3D;$10^{18}$,$P&#x3D;1$</li>
</ol>
<p>输出$0$</p>
<ol start="2">
<li>$n,m\le 1000$ $p$无限制</li>
</ol>
<p>递推式：</p>
<p>$C(n,m)&#x3D;(C(n-1,m-1)+C(n-1,m))%p$</p>
<ol start="3">
<li>$n,m\le 10^6$,$p$是质数</li>
</ol>
<p>因为$p$是质数了，所以可以用<strong>逆元</strong></p>
<p>$C(n,m)&#x3D;\frac {n!}{m!\times (n-m)!}$</p>
<p>除法可以用<strong>逆元</strong>搞定</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011108568.webp"
                      alt="image.png|600"
                ></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">fac[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//0!</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000000</span>;i++)</span><br><span class="line">        fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    <span class="built_in">C</span>(n,m)=<span class="number">1ll</span>*fac[n]*<span class="built_in">ksm</span>(fac[m],p<span class="number">-2</span>,p)%p*<span class="built_in">ksm</span>(fac[n-m],p<span class="number">-2</span>,p)%p;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>$n\le 10^9$ $m&lt;&#x3D;1000$ $p$无限制</li>
</ol>
<p>大概是一个$m^2$级别的才符合出题人的意图</p>
<p><strong>一个题的突破口就是最奇怪的地方</strong></p>
<p>因为$p$无限制，所以<strong>不一定是质数</strong>，可能<strong>逆元不存在</strong></p>
<p><em>不用递推式可不可以？</em></p>
<p>$m\le n$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011126512.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011119941.webp"
                      alt="image.png|600"
                ></p>
<p>把能约的全部约掉</p>
<p>上面有$m$项，下面有$m$项</p>
<p>枚举上下两项</p>
<p>最后分母一定可以被约成$1$</p>
<p>答案就是把分子乘起来</p>
<p>复杂度:$m^2\times logn$</p>
<ol start="5">
<li>$n,m\le 10^9$,$p\le 100$且为质数</li>
</ol>
<p><strong>卢卡斯定理</strong></p>
<p>$p$为质数</p>
<p>把$n$，$m$转换为$p$进制的数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011404855.webp"
                      alt="image.png|600"
                ></p>
<p>按位取$C()$再相乘</p>
<p>比如：</p>
<p>$25&#x3D;221$</p>
<p>$C(25,12)%3&#x3D;C(2,1)\cdot C(2,1)\cdot C(1,0)%3$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011407891.webp"
                      alt="image.png|600"
                ></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 转为p进制</span></span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        x[<span class="number">0</span>]++;<span class="comment">//x[0]代表位数</span></span><br><span class="line">        x[x[<span class="number">0</span>]]=n%p;</span><br><span class="line">        n=n/p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m)</span><br><span class="line">    &#123;</span><br><span class="line">        y[<span class="number">0</span>]++;<span class="comment">//y[0]代表位数</span></span><br><span class="line">        y[y[<span class="number">0</span>]]=m%p;</span><br><span class="line">        m=m/p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>因为$n$大于$m$</p>
<p>所以正常情况下$n$转换为$p$进制的位数比$m$要大</p>
<p>所以按照$n$转化后的位数枚举就可以了</p>
<p>以最低位对齐，高位补零</p>
<p>时间复杂度？</p>
<p>不断除以$p$</p>
<p>那么就是$log_p$的复杂度</p>
<p>那假如模的不是质数（这个数也不能是某个质数的若干次方）</p>
<p>那先对它先进行一个质因数分解</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011422004.webp"
                      alt="image.png|600"
                ></p>
<p>这不就是[[#中国剩余定理|中国剩余定理]]嘛</p>
<p>解同余方程就可以了</p>
<h3 id="1-组合数拆解"><a href="#1-组合数拆解" class="headerlink" title="1.组合数拆解"></a>1.组合数拆解</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011425063.webp"
                      alt="image.png|600"
                ></p>
<p>$n&#x3D;1+1+1+1+1+1…+(n-k+1)$</p>
<p>加上$k-1$个$1$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011431364.webp"
                      alt="image.png|600"
                ></p>
<p><strong>任何一个自然数都是组合数</strong></p>
<h3 id="2-比较组合数大小"><a href="#2-比较组合数大小" class="headerlink" title="2.比较组合数大小"></a>2.比较组合数大小</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011433838.webp"
                      alt="image.png|600"
                ></p>
<p>数据范围:$&lt;&#x3D;1000000$</p>
<p>解法：</p>
<p><strong>log</strong></p>
<p>$log_x(ab)&#x3D;log_a+log_b$</p>
<p>$log_x(\frac ab)&#x3D;log_a-log_b$</p>
<p>$log$可以反映大小关系</p>
<p>$log{C(n1,m1)}$ $log{C(n2,m2)}$</p>
<p>假如$C_1&lt;C_2$那么一定有$logC_1&lt;logC_2$，反之亦然<br>$$<br>\begin{aligned}<br>logC(n,m)&amp;&#x3D;log\frac{n!} {m!\times (n-m)!}\<br>&amp;&#x3D;log{n!}-log{m!}-log{(n-m)!}\<br>&amp;\downarrow\<br>log{n!} &amp;&#x3D;log1+log2+log3+\dots logn\<br>\end{aligned}<br>$$</p>
<p>这样就可以求出$logC(n,m)$的值就可以进行比较大小了</p>
<p><em>精度误差？</em></p>
<p>这个是在小数点后很多位产生的误差</p>
<p>因此可以忽略不计</p>
<h3 id="3-找最大组合数"><a href="#3-找最大组合数" class="headerlink" title="3.找最大组合数"></a>3.找最大组合数</h3><p><a class="link"   href="https://www.luogu.com.cn/problem/P4370" >P4370<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011455419.webp"
                      alt="image.png|600"
                ></p>
<p><strong>对某个数取模,不需要考虑和是什么</strong></p>
<p>最大的数一定在最下面的最中间</p>
<p>最下面那不就是第$n$行嘛，也就是第$n$行的最中间$n&#x2F;2$</p>
<p>要求组合数，要么就是带入公式，但是这里模数不一定为质数，所以只能用递推式</p>
<p>第二大的一定在它的周围</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011500778.webp"
                      alt="image.png|600"
                ></p>
<p>下一个最大的在第二大和第一大的组合数周围</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011501761.webp"
                      alt="image.png|600"
                ></p>
<p>怎么比较大小呢？</p>
<p>上一道题就说了</p>
<p>那就可以用<code>BFS</code>做了</p>
<p>但$k$比较大</p>
<p>可以加堆优化</p>
<h3 id="4-组合数问题"><a href="#4-组合数问题" class="headerlink" title="4.组合数问题"></a>4.组合数问题</h3><p><a class="link"   href="https://www.luogu.com.cn/problemP3746" >P3746<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>一开始的$f(n,r)$,往下化简</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011522366.webp"
                      alt="image.png|600"
                >^1121</p>
<p>展开$k$次</p>
<p>按照[[#6.📌组合数的卷积（展开式）|展开式]]</p>
<p>$C(n,m)&#x3D;\sum^k\limits_{i&#x3D;0}C(k,i)\cdot C(n-k,m-i)$</p>
<p>$C(nk,ik+r)&#x3D;\sum^k\limits_{j&#x3D;0}$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011524057.webp"
                      alt="image.png|600"
                ></p>
<p>出现了很多$\Sigma$</p>
<p>这个叫做<em>求和变形</em></p>
<p><u>常用的技巧</u>：</p>
<ol>
<li><strong>增加枚举量</strong></li>
<li><strong>交换枚举顺序</strong></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011528564.webp"
                      alt="image.png|600"
                ></p>
<ol start="3">
<li><strong>分离无关变量</strong></li>
</ol>
<p>什么叫做分离无关变量呢？</p>
<p>这个式子里变得是$i$和$j$</p>
<p>$i$变了第二个式子就会变，但第一个式子不会变</p>
<p>那就可以把第一个式子提出去</p>
<ol start="4">
<li>[[#7.|换元法]]</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011531771.webp"
                      alt="image.png|600"
                ></p>
<p>求完和再统一去乘</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011532366.webp"
                      alt="image.png|600"
                ></p>
<p>这还是两层循环</p>
<p>想想题目开始时设的$f$，现在已经化简成了这样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011522366.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011533496.webp"
                      alt="image.png|600"
                ></p>
<p>$i,j$控制的是圈起来的部分,这个地方就可以把$\infty$消掉</p>
<p>![[#^1121]]</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011534068.webp"
                      alt="image.png|600"
                ></p>
<p>那就能化为</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011535079.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011537221.webp"
                      alt="image.png|600"
                ></p>
<p>老规矩，加一维，凑成矩阵乘法</p>
<p>第一行第$r$列</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011538082.webp"
                      alt="image.png|600"
                ></p>
<p>令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011539247.webp"
                      alt="image.png|600"
                ></p>
<p>$f_0$就是$n&#x3D;0$时的值，往公式里带就可以了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011539727.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011541533.webp"
                      alt="image.png|600"
                ></p>
<h2 id="抽屉原理"><a href="#抽屉原理" class="headerlink" title="抽屉原理"></a>抽屉原理</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011546192.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011547914.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011549655.webp"
                      alt="image.png|600"
                ></p>
<p>一般来讲小的为抽屉</p>
<p>所以$c$是抽屉，$n$是东西</p>
<p><strong>陷阱：选任意多个数，但不保证连续，但其实连续更好做</strong></p>
<p><strong>前缀和：</strong></p>
<p>$n$个数的前缀和一定有$n+1$个</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011556589.webp"
                      alt="image.png|600"
                ></p>
<p>$n+1&gt;n\ge c$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011600523.webp"
                      alt="image.png|600"
                ></p>
<p>按照模$c$以后的数分组</p>
<p>那就是 $0 \to c-1$</p>
<p>一共有$c$个抽屉</p>
<p>$n+1$个前缀和，按照模数分组</p>
<p>那么一定有一个抽屉有两个前缀和,前缀和肯定是几个数相加</p>
<p>这两个数模$c$是同余的</p>
<p>那它们的差一定就是$c$的倍数</p>
<p>那前缀和之差肯定就是某段区间的和了</p>
<h3 id="1-正方形覆盖"><a href="#1-正方形覆盖" class="headerlink" title="1.正方形覆盖"></a>1.正方形覆盖</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011613679.webp"
                      alt="image.png|600"
                ></p>
<p>假如$L&#x3D;100$能盖住</p>
<p>那$L&#x3D;150$一定也可以盖住</p>
<p>假如$L&#x3D;100$不能盖住</p>
<p>那么$L&#x3D;50$一定也不能盖住</p>
<p>考虑<em>二分答案</em></p>
<p>那么现在问题是已知$L$，能不能覆盖所有点</p>
<p>这题有个很特殊的数字$3$</p>
<p>$3$和抽屉原理有什么关系</p>
<p>可以把平面上所有点分为<strong>四块</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011621702.webp"
                      alt="image.png|600"
                ></p>
<p>最靠<em>上&#x2F;下&#x2F;左&#x2F;右</em>的点为边界</p>
<p>至少有<strong>一个正方形</strong>会盖住<strong>两个点</strong></p>
<p>要么<em>左上角&#x2F;右上角&#x2F;左下角&#x2F;右下角</em></p>
<p>枚举一下就可以了</p>
<p>假如放在左下角</p>
<p>盖住一个区块后</p>
<p>剩下的点还可以构造一个四边形</p>
<p>现在还剩两个正方形</p>
<p>至少有一个正方形至少盖住两个边界点</p>
<p>再枚举一次（枚举的是盖住哪个角，而不是盖住几个点，盖住几个点都不重要，我们想知道的只是最后能不能全都盖住）</p>
<p>再把没有被盖住的点拿出来，看看最后一个正方形能不能盖住剩下的点就可以了</p>
<p>这样就可以判断能不能用长度为$L$的正方形能不能盖住了</p>
<p>每次盖住就要重新求一遍边界点，为$O(n)$级别</p>
<p>然后枚举十六种情况</p>
<p>也就是$O(16n)$</p>
<p>为什么放角上是最优的？</p>
<p>因为再往外移就会浪费面积</p>
<p>没有盖住任何点</p>
<p>我倒不如往里移让它盖住更多的点</p>
<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011647747.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011647211.webp"
                      alt="image.png|600"
                ></p>
<p>加上所有一个式子，减去所有两个式子，加上所有三个式子，减去所有四个式子</p>
<h3 id="n对夫妻问题"><a href="#n对夫妻问题" class="headerlink" title="n对夫妻问题"></a>n对夫妻问题</h3><p>$2n$个人坐成一圈</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011650406.webp"
                      alt="image.png|600"
                ></p>
<p>每对夫妻不能坐在相邻的位置</p>
<p>旋转后相同的算一种</p>
<p>假如不要求不相邻，让他们作为一排</p>
<p><strong>有两种解释：</strong></p>
<p><strong>第一种：</strong></p>
<p>一排的方案数是$n!$</p>
<p>坐成一圈呢？</p>
<p>$n$个人坐成一圈的人可以转出n种方案</p>
<p>所以就是$n!\div n$</p>
<p>$&#x3D;(n-1)!$</p>
<p><strong>第二种：</strong></p>
<p>假如第一个人定死了，剩下$n-1$个人坐$n-1$个位置，还是$(n-1)!$</p>
<p>回到题目本身的要求上：<strong>每对夫妻都不能相邻</strong></p>
<p>原来有$2n$个人</p>
<p>随便坐的方案数：$(2n-1)!$</p>
<p>但这里面包含<em>不合法</em>的方案数</p>
<p>那就把它<strong>减去</strong>就可以了</p>
<p>我可以让一对夫妻强制坐在一起，那么这种一定不合法</p>
<p>$n$对中选出一对夫妻强制相邻：$C(n,1)\cdot (2n-2)!$</p>
<p>可以把强制相邻看作让把一个人强制绑定到另一个人身上，也就是让这$(2n-2)$个人围成一圈做全排列</p>
<p>虽然强制相邻，但<strong>男左女右</strong>，<strong>男右女左</strong>也是两种方案</p>
<p>所以还要再乘以$2$：$C(n,1)\cdot (2n-2)!\cdot 2$</p>
<p>这就是答案吗？</p>
<p>但有没有可能把一种不合法的方案删了多次呢？</p>
<p>如果一个方案里，既有第一对相邻，也有第二对相邻，那么这个方案会被减掉两次</p>
<p>发现被多减了</p>
<p>$(2n-1)!-C(n,1)\cdot (2n-2)!\cdot 2+C(n,2)\cdot (2n-3)!\cdot x^2$</p>
<p>我们又发现多加上了三对夫妻相邻的方案数</p>
<p>那么就不断加加减减下去，最后写成$\Sigma$的形式</p>
<p>有i对夫妻强制相邻</p>
<p>$\sum^n\limits_{i&#x3D;0}C(n,i)\cdot (2n-i-1)!\cdot{2^i}$</p>
<p>那么加减呢？</p>
<p>观察上面的式子</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020844653.webp"
                      alt="image.png|600"
                ></p>
<p>发现规律：<strong>奇数减，偶数加</strong></p>
<p>为了使奇数减，偶数加，那么就要再做一点修改：</p>
<p>$\sum^n\limits_{i&#x3D;0}C(n,i)\cdot (2n-i-1)!\cdot{2^i}\cdot{(-1)^i}$</p>
<p>把$n$对不坐在一起的问题转换为只限制一对，两对，三对……</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020847026.webp"
                      alt="image.png|600"
                ></p>
<h3 id="x的y次方"><a href="#x的y次方" class="headerlink" title="x的y次方"></a>x的y次方</h3><blockquote>
<p><a class="link"   href="https://acm.hdu.edu.cn/showproblem.php?pid=2204" >HDU2204<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P9118" >P9118<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020849353.webp"
                      alt="image.png|600"
                ></p>
<p>$y$最大的多少？</p>
<p>要保证$2^y&lt;10^{18}$，这是$x$最小的($1$的任意次方等于它本身)</p>
<p>那么$y&lt;64$</p>
<p>$1-100$有多少个数能用$x^2$表示？</p>
<p>这个答案显然是$\sqrt{100}$个</p>
<p>那么$1\to{N}$能表示$x^y$的数一共有$\sqrt[y]{N}$个</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020852314.webp"
                      alt="image.png|600"
                ></p>
<p>那么答案是这个吗？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020853573.webp"
                      alt="image.png|600"
                ></p>
<p>比如$64$，$y&#x3D;2$的时候会被$8$算一次</p>
<p>$y&#x3D;3$的时候会被$4$算一次</p>
<p>$y&#x3D;6$的时候会被$2$算一次</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020855290.webp"
                      alt="image.png|600"
                ></p>
<p>要把它减掉</p>
<p>$-^6\sqrt{N}$</p>
<p>决定$y$次是加还是减呢？</p>
<p>可以用<del>莫比乌斯函数</del></p>
<p>先暴力</p>
<p>当算到$x^2$的时候$x^{4,6,8\dots}$都会被算</p>
<p>也就是$a$的倍数都要$+1$；</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">2</span>;a&lt;=<span class="number">64</span>;a++)</span><br><span class="line">&#123;</span><br><span class="line">    num[a]=<span class="number">0</span>;<span class="comment">//代表x的a次方这种形式的数被算了几次，它应该为1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">2</span>;a&lt;=<span class="number">64</span>;a++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//v表示x^a这种形式的数有多少个</span></span><br><span class="line">    <span class="comment">//pow要下取整，不能四舍五入</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> v=<span class="built_in">pow</span>(n,<span class="number">1.0</span>/a)<span class="number">-1</span>;<span class="comment">//减去1的a次方这个方案数，因为1^a会被算63次//pow(x,y)计算x的y次方--&gt;开a次方根，减去1次方</span></span><br><span class="line">    <span class="comment">//把1去掉</span></span><br><span class="line">    <span class="type">int</span> d=<span class="number">1</span>-num[a];<span class="comment">//代表这个数还要算几次/不应该被算多少次，因为最后要让每个num都是1//3,2,1,0,-1,-2...</span></span><br><span class="line">    <span class="comment">//d*v就是对答案的贡献,通过算了多少次就可以知道容斥系数</span></span><br><span class="line">    ans+=v*d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> b=a;b&lt;=<span class="number">64</span>;b+=a)</span><br><span class="line">    &#123;</span><br><span class="line">        num[b]+=d;<span class="comment">//b被算了这么多次，就把所有a的倍数都加上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans++;<span class="comment">//因为一开始就没算1，所以要加上1</span></span><br></pre></td></tr></table></figure></div>

<p>$pow(n,1.0&#x2F;a)&#x3D;\sqrt[a]{n}$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020930805.webp"
                      alt="image.png|600"
                ></p>
<p>$\because2^{log_2n}&#x3D;n$</p>
<p>$\therefore$原式$&#x3D;n^{\frac{1}{a}}$</p>
<p>$&#x3D;^a\sqrt{n}$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020932102.webp"
                      alt="image.png|600"
                ></p>
<p>$log$和$exp$在<code>cpp</code>里都是以$e$为底的</p>
<p>以什么为底都一样</p>
<p>$exp(x)$就是$e^x$</p>
<h1 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h1><h1 id="矩阵-1"><a href="#矩阵-1" class="headerlink" title="矩阵"></a>矩阵</h1><blockquote>
<p>矩阵乘法和前缀和很像</p>
</blockquote>
<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><p><strong>解方程</strong><br>$$<br>\begin{cases}<br>x_1+x_2&#x3D;2\<br>2x_1+3x_2&#x3D;5 \<br>\end{cases}<br>$$</p>
<p>$\begin{cases}{x_1}&#x3D;1\{x_2&#x3D;1}\end{cases}$</p>
<p>假如稍作变化呢？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020937268.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020939573.webp"
                      alt="image.png|600"
                ></p>
<p>$n$个未知数</p>
<p>要解决$n$元一次方程，怎么解？</p>
<p>要<strong>把未知数消去</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020941862.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020941863.webp"
                      alt="image.png|600"
                ></p>
<p>$x1$就消失了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020942049.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020942601.webp"
                      alt="image.png|600"
                ></p>
<p>$x1$也消失了</p>
<p>$(i)-(1)\cdot\frac{a_{11}}{a_{i1}}$</p>
<p>可以用第$i$个方程-第一个方程乘以$a11$分之$ai1$就可以把所有的$x1$消掉</p>
<p>只有$n-1$个方程，$n-1$个未知数了</p>
<p>不断减去第一行就可以消掉$x1$，剩下的方程不断减去第二行就可以消去$x2$,$\ldots$</p>
<p>不断这样做下去就可以做成一个方程，一个未知数</p>
<p>解出来后一步一步往回带，也可以变成只剩一个未知数</p>
<p>写一下代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020951435.webp"
                      alt="image.png|600"
                ></p>
<p><strong>i&#x3D;1</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020958685.webp"
                      alt="image.png|600"
                ></p>
<p><strong>i&#x3D;2</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021000278.webp"
                      alt="image.png|600"
                ></p>
<p>会变成一个三角形</p>
<p>所以消元后</p>
<p>最后的方程会在最后一行</p>
<p>一般也就$100\to 200$</p>
<p>题目保证有唯一解</p>
<p>假如$a[i][i]&#x3D;0$?</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021009681.webp"
                      alt="image.png|600"
                ></p>
<p>任何一个$a[i][i]&#x3D;0$</p>
<p>这样拿第一个方程的$x1$消去其它方程的$x1$，没有办法消元，因为第一个方程压根就没有$x1$</p>
<p>所以我要用第$i$个方程消去$xi$要先保证有$xi$</p>
<p>可以交换</p>
<p>代码:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="comment">// cin&gt;&gt;b[i];</span></span><br><span class="line">    cin&gt;&gt;a[i][n<span class="number">+1</span>];<span class="comment">//存b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a存系数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//消元</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j][i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">+1</span>;k++)</span><br><span class="line">                    <span class="built_in">swap</span>(a[i][k],a[j][k]);<span class="comment">//交换方程O(1)</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//要把xi从i+1个方程到第n个方程消掉</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="comment">//把xi从第j个方程开始消掉</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> ratio=a[j][i]/a[i][i];<span class="comment">//求应该变的系数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">+1</span>;k++)<span class="comment">//算上更新常数b</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[j][k]-=a[i][k]*ratio;<span class="comment">//每一个位置都要对应减，长度为n</span></span><br><span class="line">                <span class="comment">//单独减b比较麻烦</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)<span class="comment">//解方程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][n<span class="number">+1</span>]-=a[i][j]*x[j];<span class="comment">//把已经回带的未知数移到右边去</span></span><br><span class="line">        &#125;</span><br><span class="line">        x[i]=a[i][n<span class="number">+1</span>]/a[i][i];<span class="comment">//解一元一次方程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>$int$的话写不等于$0$就可以了</p>
<p>但是这里面所有的方程都是<code>double</code>类型的，不可以用<code>!=0</code>来判断</p>
<p>应该这样写</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i])&gt; <span class="number">1e-8</span>)<span class="comment">//fabs取绝对值，在10^-8以上，就不是0</span></span><br><span class="line">......</span><br><span class="line"><span class="type">double</span> ratio=a[j][i]/a[i][i];<span class="comment">//求应该变的系数</span></span><br></pre></td></tr></table></figure></div>

<p>但实际上这种高斯消元很容易被卡</p>
<h3 id="主元消元法"><a href="#主元消元法" class="headerlink" title="主元消元法"></a>主元消元法</h3><p>精度问题</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021035445.webp"
                      alt="image.png|600"
                ></p>
<p>换哪个呢？</p>
<p>一个会除以$0.1$</p>
<p>一个会除以$10$</p>
<p>数学意义上无所谓</p>
<p>但第二个会更好</p>
<p>除以$10$会更好</p>
<p>假如精度误差到了$0.01$的级别</p>
<p>$0.1$会使它波动到$0.09\to 0.1$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021038924.webp"
                      alt="image.png|600"
                ></p>
<p>第二个波动范围更小</p>
<p>因为误差会随着数一起变</p>
<p>数变大误差也就会变大，数变小误差也会变小</p>
<p>这里选的$a[i][i]$应该越大越好</p>
<p><strong>主元消元法：</strong></p>
<p>找到系数最大的那个作为被除数使最优的</p>
<p>假如系数和解都是整数呢？</p>
<p>可以存分子分母</p>
<p>也可以：</p>
<p>举个栗子：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021044736.webp"
                      alt="image.png|600"
                ></p>
<p>假如还是那么写，要乘$1.5$倍</p>
<p>那就可以把它们都变成各自的最小公倍数</p>
<p>这样就可以避免出现小数</p>
<p>但是不断求<code>LCM</code>这样系数可能会越来越大</p>
<p>所以要开<code>long long</code></p>
<p>要是<code>long long</code>还不行就得去用<code>double</code>的方法了</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> a[][];</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="comment">// cin&gt;&gt;b[i];</span></span><br><span class="line">    cin&gt;&gt;a[i][n<span class="number">+1</span>];<span class="comment">//存b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a存系数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//消元</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j][i]!=<span class="number">0</span>)</span><br><span class="line">            <span class="comment">// if(fabs(a[j][i])&gt; 1e-8)//fabs取绝对值，在10^-8以上，就不是0</span></span><br><span class="line">            <span class="comment">// if(fabs(a[j][i])&gt; fabs(a[i][i]))//系数更大，就会使误差更小，也就更优，那就换</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">+1</span>;k++)</span><br><span class="line">                    <span class="built_in">swap</span>(a[i][k],a[j][k]);<span class="comment">//交换方程O(1)</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//要把xi从i+1个方程到第n个方程消掉</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="comment">//把xi从第j个方程开始消掉</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j][i]==<span class="number">0</span>) comtinue;</span><br><span class="line">            <span class="type">int</span> l=a[i][i]/<span class="built_in">gcd</span>(<span class="built_in">abs</span>(a[i][i]),<span class="built_in">abs</span>(a[j][i]))*a[j][i];<span class="comment">//lcm//可能有负数</span></span><br><span class="line">            <span class="type">int</span> retioi=l/a[i][i];</span><br><span class="line">            <span class="type">int</span> retioj=l/a[j][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">+1</span>;k++)<span class="comment">//算上更新常数b</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// a[j][k]-=a[i][k]*ratio;//每一个位置都要对应减，长度为n</span></span><br><span class="line">                a[j][k]=a[j][k]*retioj-a[i][k]*ratioi;</span><br><span class="line">                <span class="comment">//单独减b比较麻烦</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)<span class="comment">//解方程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][n<span class="number">+1</span>]-=a[i][j]*x[j];<span class="comment">//把已经回带的未知数移到右边去</span></span><br><span class="line">        &#125;</span><br><span class="line">        x[i]=a[i][n<span class="number">+1</span>]/a[i][i];<span class="comment">//解一元一次方程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h2><p>可以怎么用高斯消元呢？</p>
<p>输入一个数，输出一个数，一般可以打表</p>
<p>打表打不下的时候可以找规律</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021057735.webp"
                      alt="image.png|600"
                ></p>
<p>假设答案是关于$n$的一次方程</p>
<p>可以得到若干个方程</p>
<p>假如规律不对</p>
<p>那就把它当成$2$次的式子</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021100409.webp"
                      alt="image.png|600"
                ></p>
<p>在把$n&#x3D;4$带进去</p>
<p>若还不满足</p>
<p>再升幂</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021101450.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021101127.webp"
                      alt="image.png|600"
                ></p>
<p>次数比较低的时候可以手解</p>
<p>那么就可以枚举这个规律是几次的</p>
<p>那就把它带到下一项去验证</p>
<p>这样就可以找到规律</p>
<p>条件：一定是$n$的多少次方</p>
<h2 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a>矩阵求逆</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021106592.webp"
                      alt="image.png|600"
                ></p>
<p>矩阵$I$叫做单位矩阵</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021107829.webp"
                      alt="image.png|600"
                ></p>
<p>假如$A\times{B}&#x3D;I$</p>
<p>矩阵$B$是矩阵$A$的逆矩阵</p>
<p>矩阵$A$是矩阵$B$的逆矩阵</p>
<p>怎么求逆矩阵呢？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021110936.webp"
                      alt="image.png|600"
                ></p>
<p>$i&#x3D;j$的时候$&#x3D;1$</p>
<p>$i!&#x3D;j$的时候$&#x3D;0$</p>
<p>这样才能保证得到一个单位矩阵</p>
<p>$n^2$个未知数，$n^2$个方程，这样就可以把逆矩阵求出来了</p>
<p>那么这个的复杂度就会是$n^{2^3}$</p>
<p>也就是$n^6$</p>
<p>有亿点大</p>
<p>怎么优化呢？</p>
<p>用一个小小的<u>小技巧</u></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021116986.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021117476.webp"
                      alt="image.png|600"
                ></p>
<p>对角线有两个是$0$，它们所在的小矩阵，$1$变成了另一个对角线</p>
<p>这个矩阵可以<strong>交换第二行和第三行</strong></p>
<p><strong>可以动手算一下</strong></p>
<p>那假如是这个：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021120083.webp"
                      alt="image.png|600"
                ></p>
<p>对角线为$1$</p>
<p>其实就是把第一行的两倍加到第二行上</p>
<p>就是把某一行的若干倍加到某一行上去</p>
<p>高斯消元的核心操作：交换某两行，把一行的若干倍加到某一行上去</p>
<p>高斯消元每一步相当于做矩阵乘法</p>
<p>一开始有个矩阵$A$</p>
<p>$A\times B&#x3D;I$</p>
<p>用高斯消元不断消$A$，把它消成$I$</p>
<p>正着消除一遍，再倒着消除一遍</p>
<p>就可以把矩阵化为$I$</p>
<p>其实就是乘了个$B$</p>
<p>把消元的过程中把同样的操作在矩阵$I$同样做一遍</p>
<p>就可以把$A\times B\to I$,$I\times B\to B$</p>
<p>就相当于对一个$n\times 2n$的矩阵消元</p>
<p>左边是$A$,右边是$I$</p>
<h1 id="概率和期望"><a href="#概率和期望" class="headerlink" title="概率和期望"></a>概率和期望</h1><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><p><strong>概率：一件事发生的可能性</strong></p>
<p>什么是事件呢？</p>
<p>比如扔骰子🎲，可能扔出${1,2,3,4,5,6}$</p>
<p>这六个数叫做样本空间</p>
<p>每一个值叫做一个样本点</p>
<p><strong>事件：几个样本点的集合</strong></p>
<p>$A&#x3D;{1}\to\frac16$ </p>
<p>$A&#x3D;{1,2,3}\to\frac12$</p>
<ol>
<li>交集<ol>
<li>$A\cap{B}&#x3D;A\cdot{B}$</li>
<li>$A\cup{B}&#x3D;A+B$</li>
<li>$A-A\cdot B&#x3D;A-B$</li>
</ol>
</li>
</ol>
<p>那$A-B$是什么呢？</p>
<p>$A$里面在$B$种出现过的扔掉</p>
<p>就是$A$减去$A$和$B$的交集</p>
<p>除法呢？</p>
<p><strong>除以一个矩阵&#x3D;乘上它的逆矩阵</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021310051.webp"
                      alt="image.png|600"
                ></p>
<p>每个样本点的概率不一定是相等的</p>
<p>$A{1,2,3}&#x3D;A{1}+A{2}+A{3}$</p>
<h3 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h3><p>假如有个事件概率为$P(A)$</p>
<p>任何一个事件的概率都是$0\to 1$的一个实数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021314630.webp"
                      alt="image.png|600"
                ></p>
<p>所有样本点的概率之和为$1$</p>
<p>$P(A)&#x3D;0$,叫做<strong>不可能事件</strong></p>
<p>$P(A)&#x3D;1$,叫做<strong>必然事件</strong></p>
<p>$P(A|B)$ <strong>条件概率</strong>：$B$发生的情况下，$A$发生的概率</p>
<p>看$B$事件的发生对$A$产生了何种影响</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021318047.webp"
                      alt="image.png|600"
                ></p>
<p>$B$事件改变了它的样本空间</p>
<p>$P(A|B)&#x3D;\frac 13$</p>
<p>再换个栗子</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021319834.webp"
                      alt="image.png|600"
                ></p>
<p>$P(A|B)&#x3D;A{1}+A{2}+A{3}&#x3D;\frac{1}{3}+0+\frac{1}{3}&#x3D;\frac 23$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021322346.webp"
                      alt="image.png|600"
                ></p>
<p>$P(A|B)&#x3D;\frac{P(AB)}{P(B)}&#x3D;\frac{\frac{1}{3}}{\frac{1}{2}}&#x3D;\frac{2}{3}$</p>
<p>一共六个样本点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021324733.webp"
                      alt="image.png|600"
                ></p>
<hr>
<p><strong>独立事件</strong></p>
<p>$A$是否发生和$B$是否发生没有关系</p>
<p>$P(A)\times P(B)&#x3D;P(AB)$</p>
<p>$P(A|B)\times P(B)&#x3D;P(AB)$</p>
<p>$P(A)&#x3D;P(A|B)$</p>
<p>$A$发生的概率&#x3D;$B$事件发生的情况下$A$发生的概率</p>
<p>因此B时间的发生对$A$时间的发生没有影响</p>
<p>这个时候这两个事件就是独立的</p>
<p>比如扔两枚骰子🎲&#x2F;生两个孩子👶</p>
<h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><p>扔一枚骰子🎲</p>
<p>每种情况发生的概率是$\frac {1}{6}$</p>
<p>扔出来的数的期望是什么？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021333472.webp"
                      alt="image.png|600"
                ></p>
<p>用每一种情况的这个数去乘以这个情况的概率</p>
<p>第一种情况就是$1\times{\frac{1}{6}}$</p>
<p>第二种情况就是$2\times{\frac{1}{6}}$</p>
<p>$\ldots$</p>
<p>第六种情况就是$6\times{\frac{1}{6}}$</p>
<p>把这六个式子加起来就是数的期望</p>
<p>也就是扔出来数的平均值</p>
<p>每个事件有一个概率，每个事件有一个权值</p>
<p>权值$x$概率之和就是期望</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021336539.webp"
                      alt="image.png|600"
                ></p>
<p>扔出来数平方的平均值</p>
<p>假如十个测试点，输出$Y&#x2F;N$</p>
<p>假如我写了个<code>cout&lt;&lt;Y&lt;&lt;endl;</code></p>
<p>这个期望是$50$分</p>
<p>每个测试点有一半概率是$Y$一半概率是$N$，一个测试点是十分</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021339069.webp"
                      alt="image.png|600"
                ></p>
<p>假如概率不一样呢？</p>
<p>还是一样算</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021341638.webp"
                      alt="image.png|600"
                ></p>
<hr>
<h3 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h3><p>期望的和$&#x3D;$和的期望</p>
<p><em>一枚骰子灌铅，一枚骰子不灌铅</em></p>
<p>$E$代表期望</p>
<p>$E[x_1+x_2]$</p>
<p>两枚骰子有三十六种情况</p>
<p>得算一遍三十六种</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021346265.webp"
                      alt="image.png|600"
                ></p>
<p>再来几枚骰子呢？</p>
<p>这东西就没法算了</p>
<p>期望的和&#x3D;和的期望</p>
<p>$E[x_1+x_2]&#x3D;E[x_1]+E[x_2]$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021349184.webp"
                      alt="image.png|600"
                ></p>
<p>这个式子永远都可以用</p>
<p>即使有关系也可以用</p>
<p>假如要算$E[x_1+{x_1}^2]$</p>
<p>就是$&#x3D;E[x_1]+E[{x_1}^2]$</p>
<p>与它们独立不独立没有影响</p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021403451.webp"
                      alt="image.png|600"
                ></p>
<p>$P(Black|Red)$</p>
<p>比如两面都是黑色的就被排除了</p>
<p>另一面的概率是黑色和红色概率真的一样吗？</p>
<p>选牌的时候，放哪面呢？</p>
<p>有六种情况</p>
<p>第一张牌：<code>红|红</code></p>
<p>第二张牌：<code>红|黑</code></p>
<p>第三张牌：<code>黑|黑</code></p>
<p>条件概率P(<code>下黑|上红</code>)&#x3D;P(<code>下黑上红</code>)$\div$P(<code>上红</code>)</p>
<p>分子是六分之一</p>
<p>分母是二分之一</p>
<p>最终的概率就是三分之一</p>
<p>因为第一张牌两面都是红色，拿它摆上来正面是红的概率要比一红一黑这张牌摆上来正面是红的概率要高</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021410805.webp"
                      alt="image.png|600"
                ></p>
<p>公平：每个人中奖的概率是一样的</p>
<p>第一个人中奖的概率是$n$分之一</p>
<p>第二个人中奖的概率：第一个人没中奖的概率乘以第二个人中奖的概率</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021414382.webp"
                      alt="image.png|600"
                ></p>
<p>第三个人中奖的概率：第一个人第二个人没中奖的概率乘以第三个人中奖的概率</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021415542.webp"
                      alt="image.png|600"
                ></p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021416567.webp"
                      alt="image.png|600"
                ></p>
<p>条件概率</p>
<p>P(<code>男人</code>|<code>色盲</code>)&#x3D;P(<code>男人</code>$\times$<code>色盲</code>)除以P(<code>色盲</code>)</p>
<p>&#x3D;51%x2%&#x2F;51%x2%+49x0.25%</p>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021421358.webp"
                      alt="image.png|600"
                ></p>
<p>(1)取了$2n-m+1$次</p>
<p>哪个空了？</p>
<p>虽然取右边的概率比左边大</p>
<p>也有可能左边$(1-p)$先被取完</p>
<ol>
<li>右边口袋空了<ol>
<li>右边取</li>
</ol>
</li>
<li>左边口袋空了<ol>
<li>右边取了$n-m$次</li>
<li>左边取了$n+1$(又取了一次才发现空了)</li>
<li>第一次取到左边和第二次取左边的概率相同</li>
<li>$(1-p)^{(n+1)}p^{(n-m)}$把左边取光的概率是这个东西吗？</li>
<li>$(1-p)^{(n+1)}p^{(n-m)}$这个式子的意思实际上是顺序取的概率，完全可以交替取,是可以换顺序的，左于左之间是不计顺序的，一种情况的概率是这么多，那么这么多情况叠加起来就是要乘以情况数，因为不记顺序，所以是组合而不是排列（不清楚的可以回去看[[#组合数学|排列和组合的区别]]）；乘上C(2n-m,n)和乘上C(2n-m,n-m)其实是一回事，是相同的这么多次情况，所以没必要乘两遍</li>
<li>最后一次一定是左边，最后发现的时候是左边，前面还差$(2n-m)$次可以任意(<code>n次左</code>,<code>(n-m)次右</code>)</li>
<li>$(1-p)^{(n+1)}p^{(n-m)}\cdot C(2n-m,n)$,</li>
<li>两问，每问两种情况，一共有四种情况，这只是其中一种情况，记得乘上组合的方案数</li>
</ol>
</li>
</ol>
<p>(2)取了$2n-m$次</p>
<h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021434242.webp"
                      alt="image.png|600"
                ></p>
<p>换不换都是一样的</p>
<h4 id="前置：三门问题"><a href="#前置：三门问题" class="headerlink" title="前置：三门问题"></a>前置：三门问题</h4><p>现在有三扇门，一扇门后面是车，另外两扇门后面是羊🐏，你想要车</p>
<p>你选了一个门，主持人打开另外两扇门中的一个</p>
<p>这扇门后面是羊🐏</p>
<p>换了是三分之二</p>
<p>不换是三分之一</p>
<p>和本题有什么区别呢？</p>
<p>这个问题出在小泽和主持人上</p>
<p>并不是同一个角色</p>
<p>主持人是知道哪扇门</p>
<p>主持人没有任何概率会打开车的那扇门</p>
<p>我选三个门的概率是一样的</p>
<p>枚举一下：</p>
<ol>
<li>我选了一号门</li>
</ol>
<p>不换二号门</p>
<p>不换二号门</p>
<ol start="2">
<li>选了二号门 主持人打开三号门</li>
</ol>
<p>换一号门</p>
<ol start="3">
<li>选了三号门，主持人打开二号门</li>
</ol>
<p>换一号门</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021442648.webp"
                      alt="image.png|600"
                ></p>
<h4 id="本题"><a href="#本题" class="headerlink" title="本题"></a>本题</h4><p>一共六种情况</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021444855.webp"
                      alt="image.png|600"
                ></p>
<p>这是一个条件概率</p>
<p>小泽死的情况下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021444194.webp"
                      alt="image.png|600"
                ></p>
<p>我拿到的是好药</p>
<p>P(<code>好</code>,<code>挂</code>)除以P(<code>挂</code>)</p>
<p>小泽挂掉，分母是六分之四</p>
<p>小葱活下来，小泽挂掉，所以分母是六分之二</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021445527.webp"
                      alt="image.png|600"
                ></p>
<p>概率问题中，知道的信息量不一样就会导致事件的概率不一样</p>
<h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021449897.webp"
                      alt="image.png|600"
                ></p>
<p>哪边挂掉的概率小一些呢？</p>
<h4 id="1-1"><a href="#1-1" class="headerlink" title="(1)"></a>(1)</h4><p>第一条路不挂掉的概率&#x3D;${99}^{100}%$</p>
<h4 id="2-1"><a href="#2-1" class="headerlink" title="(2)"></a>(2)</h4><p>第二条路每个石头都不挂掉的概率是$99.9^{1000}%$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021454880.webp"
                      alt="image.png|600"
                ></p>
<p>这两个谁大？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021454462.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021456219.webp"
                      alt="image.png|600"
                ></p>
<p>$$<br>\because\frac{999}{1000}&gt;\frac{998}{999}&gt;\frac{997}{998}\ldots &gt;\frac{990}{991}<br>$$</p>
<p>$$\therefore{\frac{999}{1000}}^{10}&gt;\frac{999}{1000}\cdot\frac{998}{999}\cdot\frac{997}{998}\ldots \cdot\frac{990}{991}&#x3D;\frac{990}{1000}&#x3D;\frac{99}{100}$$</p>
<h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021507295.webp"
                      alt="image.png|600"
                ></p>
<p>经过原点的概率？</p>
<p>首先有三个阶段</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021512528.webp"
                      alt="image.png|600"
                ></p>
<p>第二阶段的末尾和第三个阶段的起点很关键</p>
<p>而第一个阶段和第二阶段极端情况下可以走无穷步</p>
<p>也就是第一象限所有的点都有可能</p>
<p>也就是$\sum^{\infty}\limits_{x&#x3D;0}$$\sum^{\infty}\limits_{y&#x3D;0}$</p>
<p>第一阶段走到$(x,0)$,走$x$步，$x$次反面$(1-p)$，概率为$(1-p)^x$$\times p$</p>
<p>停下来的概率？</p>
<p>也就是抛一次正面的概率$p$</p>
<p>第二阶段走到$(x,y)$，走$y$步，$y$次反面，概率为$(1-p)^y\times p$</p>
<p>停下来的概率是$p$</p>
<p>走到$(x,y)$了，要走第三阶段，走回原点</p>
<p>$q$：向左走</p>
<p>$(1-q)$：向下走</p>
<p>要抛$x+y$次才能回到原点</p>
<p>恰好抛$x$次正面，$y$次反面才可以恰好回到原点</p>
<p>$q^x$*$(1-q)^y$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021519554.webp"
                      alt="image.png|600"
                ></p>
<p>但是还有组合顺序（不计内部顺序，详见[[#组合数学|排列组合]]和[[#4.|火柴]]）：$q^x$*$(1-q)^y$$\times C(x+y,x)$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021522894.webp"
                      alt="image.png|600"
                ></p>
<p>在$x+y$个位置找$x$:$C(x+y,x)$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021521918.webp"
                      alt="image.png|600"
                ></p>
<p>化简呢？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021522343.webp"
                      alt="image.png|600"
                ></p>
<p>[[#4.组合数问题|求和变形]]:</p>
<ol start="4">
<li><strong>变化量有两个：$x$和$y$，但是$x+y$随着$x$，$y$变化：换元法</strong></li>
</ol>
<p>令$t&#x3D;x+y$</p>
<p>$y&#x3D;t-x$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021526859.webp"
                      alt="image.png|600"
                ></p>
<p>枚举到$t$</p>
<p>那么怎么分离无关变量呢？</p>
<p>$p^2$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021527614.webp"
                      alt="image.png|600"
                ></p>
<p>右边这个东西是不是很眼熟？</p>
<p>[[#5.二项式定理|二项式定理]]</p>
<p>$(q+1-q)^t$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021529164.webp"
                      alt="image.png|600"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021529617.webp"
                      alt="image.png|600"
                ></p>
<p>这是一个<strong>等比数列求和</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021530256.webp"
                      alt="image.png|600"
                ></p>
<p>设它为$x$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021530253.webp"
                      alt="image.png|600"
                ></p>
<p>两式一减</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021531181.webp"
                      alt="image.png|600"
                ></p>
<p>$a$就是$(1-p)$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021532567.webp"
                      alt="image.png|600"
                ></p>
<p>一个零点几的数的无穷次方$&#x3D;0$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021533246.webp"
                      alt="image.png|600"
                ></p>
<p>那答案就是$p$</p>
<p><strong>全过程：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021533868.webp"
                      alt="image.png|600"
                ></p>
<h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021536097.webp"
                      alt="image.png|600"
                ></p>
<p>三个矩阵都是$n\times{n}$的</p>
<p>看来不能直接乘，$n^3$会<code>TLE</code></p>
<p>可以不算整个矩阵，可以随机几个位置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021539959.webp"
                      alt="image.png|600"
                ></p>
<p>如果有一个位置不相等，那么一定不同</p>
<p>但这样可以吗？</p>
<p>假如只有一个错的</p>
<p>随机到那一个错的概率是一百万分之一</p>
<p>这个方法过不了</p>
<p>有没有什么<strong>正确率高一点的随机方法</strong></p>
<p>现在的问题是矩阵$A$和$B$是算不出来的</p>
<p>造一个矩阵$D$</p>
<p>矩阵$D$大小为$n\times{1}$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021543345.webp"
                      alt="image.png|600"
                ></p>
<p>矩阵乘法有结合律</p>
<p>可以先算$BD$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021544931.webp"
                      alt="image.png|600"
                ></p>
<p>反过来对吗？</p>
<p>假如$D$全是$0$</p>
<p>想想[[NOIP-数学#Miller-Rabin|miller]]</p>
<p>随机一个$D$</p>
<p>假如通过不了测试</p>
<p>那就不是；如果是，就再随机一个$D$</p>
<p>拿每个矩阵去算一下$ABD$和$CD$</p>
<p>每相等一次，相等的概率就会足够高</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021548886.webp"
                      alt="image.png|600"
                ></p>
<p>加权求和并且错到一起的概率是相当低的</p>
<p>也就是这个的正确率是相当高的</p>
<p>$n$越大，加权求和的随机率越高，正确率越高</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title>Q&amp;A</title>
    <url>/503a6fb7.html</url>
    <content><![CDATA[<p><strong>P5465</strong> @luoguhandongheng 首先i越大，那么点就越靠右，那么假如从i-2号点开始跳，跳一步，有可能到i，也有可能到i+1，但是l_{i+1}可能会比l_i要小，所以我们选择更优的l_{i+1}来更新l_i，这里其实就是告诉在i这个位置有机会花同样的代价到达更优解的位置，而且这是预处理，实际上根本没有向后跳这一步操作，因为我们预处理的时候是从最远的n开始不断靠近的，在这个过程中我们类似于dp的去找到每一个点的最优解，对于f的定义也没必要那么精确。</p>
<hr>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Q&amp;A</tag>
      </tags>
  </entry>
  <entry>
    <title>SNOIP-听课简记</title>
    <url>/87022c29.html</url>
    <content><![CDATA[<blockquote>
<p>本文仅为笔记的简略部分，其中一些较为完整的已独立成文， 请移步至对应文章。</p>
</blockquote>
<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><h2 id="1-4089-大嘴乌鸦"><a href="#1-4089-大嘴乌鸦" class="headerlink" title="1.4089: 大嘴乌鸦"></a>1.4089: 大嘴乌鸦</h2><p><strong>桶，前缀和，位运算</strong></p>
<hr>
<p>我们要找<code>k%(sum[r]^sum[l-1])==0</code>，我们可以先把k的因子记录一遍，存到v数组中，然后枚举这个因子<code>v[j]</code>，那么就是找<code>sum[r]^sum[l-1]==v[j]</code>，根据异或的性质，那么就是<code>sum[l-1]==v[j]^sum[r]</code>，因此我们只需要找到这个l的前缀异或和出现的次数就可以了。</p>
<p>而每经过一个点，就把它对应的前缀异或和出现的次数加一。</p>
<p>一个数的因子最多大概是$\sqrt(n)$个，因此复杂度是$O(n\sqrt(n))$。</p>
<h2 id="2-4090-艾莎"><a href="#2-4090-艾莎" class="headerlink" title="2.4090: 艾莎"></a>2.4090: 艾莎</h2><p><strong>线段树</strong></p>
<hr>
<p>只需要维护长度为2和3的最大子段，</p>
<p>线段树维护区间内所有长度为2的连续子段中最大和区间内所有长度为3的连续子段中最大。</p>
<p>因为任意一个区间都可以被分成两段不同的区间，这两个区间的平均值一定有一个大于等于原来的区间，另一个区间的平均值小于等于原来的平均值，所以这么不断去下去，直到剩下三个，那么假如分出来的那一个点比原来的大，但是剩下的两个比原来的小，由于一个点不能独立为一个区间，因此要保留三个。</p>
<p>合并的时候分两种情况讨论，</p>
<p>区间加的时候就分别两倍三倍加。</p>
<p>我们每个区间记录一下左端的两个值和右端的两个值，合并的时候比较一下原来两个区间的最大值和交界处新产生的值比较一下取最大就可以了。</p>
<h2 id="3-4091-沙奈朵"><a href="#3-4091-沙奈朵" class="headerlink" title="3.4091: 沙奈朵"></a>3.4091: 沙奈朵</h2><p><strong>分块</strong></p>
<hr>
<p>首先题意是要找一定范围内的每一个小区间，每个小区间的答案是这段区间内不同的值的个数（色块数，同一个数为一个色块，色块数的前缀和需要预处理方便区间查询），然后求这些区间答案的和。</p>
<p>采用分块的思想</p>
<p>把序列分成根号个块，每个块长度大概为$\sqrt(n)$</p>
<p>维护一个$a$代表$i$之前的每个$1$到$i$这个位置的染色段数</p>
<p>用<code>A[x]</code>代表当前位置向左所有答案累积和（类似于前缀和一样的东西）。</p>
<p>用<code>B[x]</code>代表当前位置向右产生所有答案的累计和</p>
<p>用<code>C[x]</code>代表当前块的x的个数</p>
<p>用<code>D[x]</code>代表当前块的答案</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307241912656.webp"
                      alt="image.png"
                ></p>
<p>当前位置向左累计产生的答案为红色段加和。</p>
<p>每遇到一个$x$就需要将其A累加到当前块的总答案中，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307242232020.webp"
                      alt="image.png"
                ></p>
<p>每个颜色其实就是$a$的一种状态，</p>
<p>那么怎么转移呢？</p>
<p>算出两个相邻的x之间的答案再乘以之前出现x的次数，累加到A上</p>
<p>正着把这个区间枚举一遍得到A的值和当前块总共的答案，</p>
<p>合并块的时候，左边的块对于右边会产生答案，右边的块对于左边会产生答案，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307241925497.webp"
                      alt="image.png"
                ></p>
<p>查询的时候（临时变量ans）：</p>
<p><code>ans+=l.A[x]*r.C[x]+r.B[x]*l.C[x]+l.C[x]*r.C[x]*(!l.r==r.l)</code></p>
<p><code>new.A=l.A+r.A*l.C</code></p>
<p>如果遇到单点修改，那么就重置一下当前块，复杂度为<code>sqrt(n)</code>，</p>
<p>一开始需要把每个块扫一遍，把每个A,B,C,D都预处理一遍，还要预处理一个区间不同色块数的前缀和，因为从这个点到上一个点产生的答案即为这段区间内色块数，$O(1)$查询</p>
<h2 id="4-4092-绒绒鸹"><a href="#4-4092-绒绒鸹" class="headerlink" title="4.4092: 绒绒鸹"></a>4.4092: 绒绒鸹</h2><p><strong>树链剖分，DFS序</strong></p>
<p>树链剖分：</p>
<p>dfs序可以保证对任何一个点的子树都是序列中的一段区间。</p>
<p>重儿子：子树大小最大的儿子</p>
<p>重链上每取一个区间都是在dfs序上一段连续的区间</p>
<p>往上跳一次轻边至少会翻倍</p>
<p>那么路径最多就可以通过$log$个区间连接起来</p>
<p>维护一下当前位置的i还要跳几步才会跳到重链头</p>
<p>用小根堆维护f的最小值，再开个全局标记。</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p><strong>DFS序</strong></p>
<h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p><strong>none</strong></p>
<hr>
<p>太简单了没啥好说的</p>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p><strong>DP，树状数组</strong></p>
<p>求长度为$k+1$的最长上升子序列的方案数。</p>
<p>$f_i$代表以$i$为结尾的最长上升子序列，</p>
<p>$i$的值可以由$j$的状态转移过来。</p>
<p>那么我们可以令$f_{i,j}$表示以$i$结尾长度为$j$的最长上升子序列的方案数。</p>
<p>那么如果一个$y$的位置长度为$j$可以被更新，那么它的上一个位置$x$长度为$j-1$可以更新它，也就是累加上$x$的答案。</p>
<p>因此要更新需要满足的条件是$a[y]&gt;a[x]$，更新给$f_x$ 的值就是所有满足这个条件的$y$的和。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307251915829.webp"
                      alt="image.png"
                ></p>
<p>即图中所有的$x$的$f$值都需要累加。</p>
<p>那么我们可以开一个二元组来维护这个关系，</p>
<p>$(a_i,f_i)$</p>
<p>这样其实就是在找$a_i$左边的所有的$f_j$的和。</p>
<p>怎么保证$j&lt;i$？</p>
<p>是从前往后插入的。</p>
<p>用树状数组优化区间求和问题。</p>
<p>由于$k&#x3D;11$，因此需要开$11$个树状数组来维护这个问题。</p>
<p>每次更新第$j$层时，需要访问第$j-1$层树状数组。</p>
<h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p><strong>树上倍增，树上区间</strong></p>
<hr>
<p>$i$表示最后一个选择的区间的右端点，</p>
<p>$f_i$表示最多能选的区间，优先选短的区间，</p>
<p>对i而言，找到一个最大的j使得区间和为0，即右端点和左端点左边的前缀和相同</p>
<p>记录一个last为上次和i前置和相同的点的位置，</p>
<p>i一定从j-1转移过来么？</p>
<p>不一定，因为上一段不一定以j-1结尾</p>
<p>那就把j之前的区间的f值取个max来更新$f_i$</p>
<p>$$f_i&#x3D;max(f_j)+1$$</p>
<p>那么q次询问就需要通过数据结构来优化复杂度</p>
<p>以每个i结尾的区间最多只有一个有意义，即最小的，</p>
<p>那么总共就有n个区间有意义，将它预处理出来，然后建树</p>
<p>以i结尾的区间for一遍就可以通过last维护最小的这个区间</p>
<p>选完一个区间后就可以选右端点最小的区间</p>
<p>所以说选完以后选下一个区间是一个固定的过程</p>
<p>预处理</p>
<p>这样出来以后就是一棵树</p>
<p>第一个的是左端点大于l右端点最小的区间</p>
<p>然后一直走直到超出r</p>
<p>倍增求解就可以了</p>
<h2 id="T22526-Princess-Principal"><a href="#T22526-Princess-Principal" class="headerlink" title="T22526 Princess Principal"></a>T22526 Princess Principal</h2><p><strong>树上倍增，树上区间</strong></p>
<hr>
<p>从左端开始不断选最长的区间</p>
<p>从左端不断连边</p>
<p>那就从左边开始不断跳，这样就可以倍增处理了</p>
<h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><p><strong>平衡树，区间求和</strong></p>
<p>不能枚举区间</p>
<p>i为分界点</p>
<p>以i开始的前缀和以i结束的后缀区间</p>
<p>两两组合成的区间，</p>
<p>左边对应最大前缀，</p>
<p>右边对应最大后缀，</p>
<p>只需要把左边的所有最大前缀和右边的最大后缀的和乘起来</p>
<p>求的时候就需要从前往后枚举一遍，边求前缀和边取max</p>
<p>维护一个集合S</p>
<p>S中：维护当前区间除去最大前缀的和</p>
<p>那么这个东西大于0就需要更新</p>
<p>那么i变为i+1后，每个元素都$+&#x3D;a[i+1]$</p>
<p>第二个操作：</p>
<p>找出所有x，y&gt;0</p>
<p>修改为x+y,0</p>
<p>每次插入则修改全局标记</p>
<p>插入的数要减去当前的tag</p>
<p>tag要加上当前插入的数</p>
<p>一开始它们的最大前缀是不一样的</p>
<p>只要后缀被更新一次，那么就不会再不同，那么就可以合并区间</p>
<p>合并以后y的和就可以知道了，</p>
<p>其实就开一个临时变量，然后扫的过程中把最大前缀和的总和记录下来就可以了</p>
<p>记录一下已经合并的区间的数量</p>
<p>这样正着扫一遍，倒着扫一遍，然后两个乘起来就可以了</p>
<h2 id="P2344"><a href="#P2344" class="headerlink" title="P2344"></a>P2344</h2><p><strong>树状数组，DP</strong></p>
<p>设$f_i$表示$1$到$i$的前缀划分成若干个子区间使它$\ge0$</p>
<p>前面有个$j$使得$f_j\ge0$</p>
<p>也就是$pre_i-pre_{j-1}\ge{0}$</p>
<p>$pre_{j-1}\le{pre_i}$</p>
<p>的$f_{j-1}$的和。</p>
<p>那就和上面T2类似了，树状数组维护一个二元组$(pre_{i},f_{i})$求满足上述条件的$f_{j-1}$的和。</p>
<h2 id="P1725"><a href="#P1725" class="headerlink" title="P1725"></a>P1725</h2><p><strong>DP+单调队列优化</strong></p>
<h2 id="P3572"><a href="#P3572" class="headerlink" title="P3572"></a>P3572</h2><p>飞到i最小的代价为$f_i$</p>
<p>一个点可以到一个区间</p>
<p>我们倒过来，其实就是从一个区间中飞过来</p>
<p>可以用单调队列维护dp最小值</p>
<p>以dp值最小为第一关键字，树的高度最大为第二关键字，维护这样一个</p>
<p>假如dp值一样，那么高度越高越优</p>
<p>假如dp值不同，那么dp值越小越优（相对于n的dp值）</p>
<h2 id="P5658"><a href="#P5658" class="headerlink" title="P5658"></a>P5658</h2><p><strong>树</strong></p>
<p>$f_i$代表从i到根有多少合法的子串</p>
<p>是由它父亲转移来的</p>
<p>比它父亲就多了个点，也就是多出了所有以i为结束点的子区间</p>
<p>$g_i$代表以i结尾的到根的合法区间的个数。</p>
<p>假如是（，那么就是0</p>
<p>假如是）</p>
<p>假如j和i这段区间构成匹配的括号串</p>
<p>$g_i$&#x3D;$g_{j-1}+1$</p>
<p>那么我们i的dp值就等于j父亲的dp值+1</p>
<p>我们要维护一个栈使得它dfs的时候和回溯的时候的状态相同</p>
<p>因为匹配的时候我们会弹出两个括号，会导致多弹出，需要记录，回溯的时候再插入</p>
<h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><h2 id="1-开关"><a href="#1-开关" class="headerlink" title="1.开关"></a>1.开关</h2><p><strong>BFS广搜</strong></p>
<p>$s^{16}\times{16}$</p>
<h2 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.</h2><p><strong>最小生成树</strong></p>
<hr>
<p>不需要选出来$sum$</p>
<p>加的时候注意一下有没有超过x就可以了</p>
<p>不需要算出来，</p>
<h2 id="3-1"><a href="#3-1" class="headerlink" title="3."></a>3.</h2><p><strong>最短路</strong></p>
<h2 id="4-1"><a href="#4-1" class="headerlink" title="4."></a>4.</h2><p><strong>匈牙利算法</strong></p>
<hr>
<p>点权从大到小排序</p>
<p>贪心选</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>新矩阵乘法</p>
<p>$C_{i,j}&#x3D;A^k$</p>
<p>其实就是限制了边数的Floyed，k为边数</p>
<p>$C_{i,j}&#x3D;\min(A_{i,k}+B_{k,j})$</p>
<p>令点双为方点，其他为圆点，然后在它们之间连边，那么最终得到的一定是个树</p>
<hr>
<h2 id="我的拓扑"><a href="#我的拓扑" class="headerlink" title="我的拓扑"></a>我的拓扑</h2><p>缩点</p>
<p>点双 边双 </p>
<p>树上差分</p>
<p>圆方树</p>
<p>哈密顿路</p>
<p>竞赛图</p>
<p>DP</p>
<p>DAGDP</p>
<h1 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h2><p>DFS</p>
<h2 id="2-2"><a href="#2-2" class="headerlink" title="2."></a>2.</h2><p>顺着边 点编号是递减的</p>
<p>从点i右边跳到i号点的概率永远是$\frac{1}{i}$，所以在所有点中病毒的情况下，让他们排成一条链的概率就是</p>
<p>给定一个$1\sim{n}$的子集$S$，询问若$i$的父亲在$[1,i-1]$中等概率生成，那么从最后一个点到一号点经过所有$S$中的节点的概率，答案对$998244353$取模。</p>
<p>首先，$i+1$到$i$的概率是$\frac{1}{i}$，$i+1$的父亲是$i$的概率是$\frac{1}{i}$；</p>
<p>$i+2$到$i$的概率是直接跳到$i$的概率加上先跳到$i+1$再跳到$i$，也就是 $\frac{1}{i+1}+\frac{1}{i+1}\times{\frac{1}{i}}&#x3D;\frac{1}{i}$，通过数学归纳法得知，$i$右边的点跳到$i$的概率都是$\frac{1}{i}$。</p>
<p>由于每次跳这些时间是相互独立的，所以原题答案为：</p>
<p>$$\prod_{i&#x3D;1}^{m-1}{\frac{1}{x_i}}$$</p>
<p>最后一个分数取模不要忘了求逆元。</p>
<h2 id="3-2"><a href="#3-2" class="headerlink" title="3."></a>3.</h2><p>题意：对于一个无向图，让你给定每条边方向，使得每个节点的入度为偶数。</p>
<p>首先，士兵人数一定要是偶数，否则不管怎么分配也一定无法分全。</p>
<p>也就是边的数量为偶数。</p>
<p>对于一颗树，叶子节点是绝对不能去的，因为这样不可能是偶数。那就从叶子节点开始，士兵向上走，如果当前点士兵数是奇数，那就让它上面的边的士兵向下走到这个点，否则就向上走。</p>
<p>这样就可以维护所有非根的点的士兵数都为偶数，由于士兵总数为偶数，那么根节点最后也一定是偶数。</p>
<p>但是这样一张无向图不一定是树，所以我们可以建一颗 DFS 树，无向图中， DFS 生成树仅存在树边和回边，所以对于每个回边，我们让它回到深度更大的点，剩下的就和树上是一模一样的了。</p>
<h2 id="4-2"><a href="#4-2" class="headerlink" title="4."></a>4.</h2><p>有一些从右向左扫的激光炮，假如打到了防护罩，那么这个激光炮就会失效。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307272301332.webp"
                      alt="image.png"
                ></p>
<p>对于第$i$个设备，我们定义$r_i&#x3D;\min_{i\in{[l_j,r_j]}}(r_j)$，也就是能打到第$i$号点的激光炮中右端点最小的$r$，那么我们在这里放一个防护罩就一定可以保护$i$不受攻击。</p>
<p>而在$[i,r_i]$中选取一个$j$，那么$r_j\le{r_i}$，这是因为$r_i$是一定覆盖$j$的，若没有比这个还小的$r_j$，那么$r_j&#x3D;r_i$，否则$r_j$就会比$r_i$更小。</p>
<p>而对于$j&gt;r_i$，那么$r_j&gt;r_i$，因此我们可以得出：所有的区间要么互相包含，要么无交，所以就可以根据这样的关系建一颗树：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307272310020.webp"
                      alt="image.png"
                ></p>
<p>在树上进行以点权和为标准的长链剖分，假如一条路径上放了一个防护罩，那么这条路径就是安全的，因为装置在区间的最左端，这样每次贪心地选$k$个长链就可以使保护的权值和最大，从而使破坏的权值和最小。</p>
<h2 id="树上差分"><a href="#树上差分" class="headerlink" title="树上差分"></a>树上差分</h2><p>一条路径，对于叶子节点+1，终点的父亲节点-1，求和只需要求终点的子树和就可以了。</p>
<h2 id="LCA小技巧"><a href="#LCA小技巧" class="headerlink" title="LCA小技巧"></a>LCA小技巧</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307271624631.webp"
                      alt="image.png"
                ></p>
<p>比如要求黑色点$u$和粉色点$v$的$lca$的深度，那么就可以把从$u$到根的路径上的点权都加一，然后求$v$到根的路径上点权的和。（初始点权都是0）</p>
<p>那么对于$\sum_{i\in{S}}dep_{lca(i,z)}$，我们就可以每次把$i$到根路径上的节点点权加一，最后统计$z$到根节点路径点权和，这样就可以把所有$lca$的深度和求解出来。</p>
<p>而对于$\sum_{i&#x3D;l}^r{dep_{lca(i,z)}}$就可以通过前缀和$\sum_{i&#x3D;1}^{r}dep_{lca{(i,z)}}-\sum_{i&#x3D;1}^{l-1}dep_{lca_{(i,z)}}$求解。</p>
<h2 id="长链剖分"><a href="#长链剖分" class="headerlink" title="长链剖分"></a>长链剖分</h2><p>长边组成长链，</p>
<p>至少能查$len$级祖先，$len$为该长链长度，</p>
<p>一个长链肯定能跳到下一个长度和它相同的<strong>下一段长链</strong>。</p>
<p>那么假如$k\le{len}$那么就可以很轻易地查询$k$级祖先，</p>
<p>类似ST的预处理，我们令$p&#x3D;\lfloor{log_j}\rfloor$，那么我们先跳$2^p$步，再跳$k-w^p$步，那么就可以跳到了。</p>
<p>假如第二次跳出了当前的长链，没关系，还可以跳到下一条长度同样为$len$的长链的段，这样就可以查到了。</p>
<h2 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h2><p>所有点到这个点的距离之和最小，那么这个点就是重心。</p>
<p>树的重心就是从上往下遍历找到的最深的满足子树点权和$\ge{\frac{\sum_{i}d_i}{2}}$的点。</p>
<p>那我们把这棵树给序列化，枚举它的前缀区间，直到找到第一个右端点$r$使得$\sum[1,r]\ge{\frac{\sum_{i}d_i}{2}}$，那么现在就有两种情况，第一种就是这个点在重心的子树中，第二种是它不在重心的子树中。假如它不在重心的子树中，那么中心的子树要么在左边的区间，但显然不可能，因为在$r$之前的区间都不满足$\ge{\frac{\sum_{i}d_i}{2}}$的条件，那就只可能是在后面的区间，后面的区间那就从一个非零的点开始找了，否则就找刚才加入的最后一个点（即满足条件的最小的$r$）。</p>
<h1 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h1><h2 id="1-2"><a href="#1-2" class="headerlink" title="1."></a>1.</h2><p>令$f_{i,j,k,0&#x2F;1}$表示走到$(i,j)$异或和为$k$且还剩$0&#x2F;1$颗珍珠的方案数。</p>
<p>递推式为：</p>
<p>$$<br>f_{i,j,k,0}&#x3D;f_{i-1,j,k,1}+f_{i,j-1,k,1}+f_{i-1,j,k\oplus{a_{i,j}},0}+f_{i,j-1,{k\oplus{a_{i,j}}},0}<br>$$</p>
<p>$$<br>f_{i,j,k,1}&#x3D;f_{i-1,j,{k\oplus{a_{i,j}}},1}+f_{i,j-1,{k\oplus{a_{i,j}}},1}<br>$$</p>
<p>最后答案就是$\sum_{k&#x3D;1}^{127}f_{n,m,k,0}\times{k}$。</p>
<h2 id="2-3"><a href="#2-3" class="headerlink" title="2."></a>2.</h2><p>定义$f_i$是从以$i$为根的子树中选出单调递减的路径的方案数，$g_i$是从以$i$为根的子树中选出单调递增的路径的方案数。</p>
<p>对于每个节点一开始$f,g$值都为$1$，因为它们还没有假如任何其它节点，只能选自己的方案数为$1$。然后开始$dfs$，在回溯的时候处理$f_i+&#x3D;\sum_{i&gt;k}f_k,g_i+&#x3D;\sum_{i&lt;k}g_k$，$k$在$i$的子树内。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307282200291.webp"
                      alt="image.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307282222439.webp"
                      alt="image.png"
                ></p>
<p>递归的时候选取一个点作为要选的两个点的 LCA ，然后选取离这个点最近的两个点设为$x,y$，那么我们就需要首先合并$x$和$lca$，也就是更新$lca$的信息（$f,g$），然后合并完之后这就是一个新的集合，那么就可以把它和以$y$为根的子树进行合并，合并的时候分别枚举两个集合中的点$i,j$，假如$i&lt;j$，那么答案累加就是$ans+&#x3D;f_x\times{g_y}$，因为是$i\to{j}$的一条路径，所以$i$到$x$是单调递减的。相反地，如果$i&gt;j$，那么就是$ans+&#x3D;f_y\times{g_x}$。</p>
<p>先合并 lca 和它的第一个子树，也就是目前知道$1$子树的信息以及根节点$0$<strong>当前的</strong>信息，很显然$1$没有其它子树，它的信息不会再被更新，而$0$还是有其它子树的，也就是说它的$f,g$仅限于当前遍历到的子树，即$1$。</p>
<p>那么我们再枚举其它子树，实际上就是不断合并连通块更新信息的同时并累加答案。</p>
<p>这样全部合并完后，$ans$就是答案。</p>
<h2 id="3-3"><a href="#3-3" class="headerlink" title="3."></a>3.</h2><p><strong>数位 DP</strong></p>
<hr>
<p>首先题意是让你找出所有的序列，这个序列满足长度为$n$序列和等于$m$，序列中的每个数都满足$\in{[0,m]}$的范围，该序列的价值为该序列中所有的数的异或和，答案是所有情况的异或和的求和$\pmod{1e9+9}$。</p>
<p>我们可以来看序列中$n$个数和$m$的二进制表示，定义$f_{i,j}$为考虑完前$i$位，且第$i$位的和等于$m$的这一位，下一位进位为$j$的方案数，$g_{i,j}$表示考虑完前$i$位，且第$i$位的和等于$m$的这一位，下一位进位位$j$的所有方案异或和的求和。</p>
<p>因为我们要保证序列和为$m$，所以我们要保证二进制下每一位加起来都等于$m$的这一位。</p>
<p>然后我们枚举一个$k$代表第$i$位我要在$1\sim{n}$中填多少个1。</p>
<p>那么$f_{i+1,{\lfloor\frac{j+k}{2}}\rfloor}&#x3D;f_{i,j}\times{C(^{n}_{k})}$，其中$C$为组合数，意为原来的方案数，在$i$这位又产生了$C(^{n}{k})$种可能，由于相互独立性，因此下一位的方案数是它们相乘。</p>
<p>假如$k$是偶数，那么这一位异或起来一定是$0$，所以不会产生新的贡献，有的只是新的情况，所以就相当于有若干个$g_{i,j}$加了起来组成了新的状态，也就是：</p>
<p>$$<br>g_{i+1,{\lfloor\frac{j+k}{2}}\rfloor}&#x3D;g_{i,j}\times{C(^{n}_{k})}<br>$$</p>
<p>假如$k$是奇数，那么这一位异或起来一定是$1$，而第$i+1$位加一，产生的贡献是$2^{i+1}$，所以会产生情况数$\times$每种情况的贡献，也就是：</p>
<p>$$<br>g_{i+1,{\lfloor\frac{j+k}{2}\rfloor}}&#x3D;g_{i,j}+2^{i+1}\times{f_{i,j}}\times{C(^n_k)}<br>$$</p>
<p>所以最后的答案就是$g_{logm,0}$。</p>
<h2 id="4-3"><a href="#4-3" class="headerlink" title="4."></a>4.</h2><p>类似地，每个人会去能去的档次最高的店，定义$f_{i,j}$为只考虑$[i,j]$这个区间里的人所能得到的最大收益是什么，枚举标准最高的店$k$，定义$g_{k,t}$为有$t$人到第$k$家店，$t$为能到达$k$的人数，那么$f_{i,j}&#x3D;f_{i,k-1}+f_{k+1,j}+g_{k,t}$。</p>
<p>$g$表示合理选择第$k$家店的档次使得收益最大的收益。</p>
<p>$t&#x3D;S_{i,j}-S_{i,k-1}-S_{k+1,j}$</p>
<p>接下来就是求出所有的$g_{k,t}$，用$c_i$表示$i$的花费，$h_j$代表有$j$个人来的最高收益，也就是$g_{k,j}$。</p>
<p>$h_j&#x3D;max(i\times{j}-c_i)$，</p>
<p>$i_1&lt;i_2$</p>
<p>$i_1\times{j-c_{i_1}}$</p>
<p>$i_2\times{j-c_{i_2}}$</p>
<p>2比1优的时候，往后2都会比1优，由于2的斜率比1斜率大，交点之后2更优</p>
<p>假如$i_1\times{j_1}-c_1\ge{i_2\times{j_2}-c_2}$</p>
<p>这样处理完之后函数的斜率是单调递增的，</p>
<p>往后优解不一定是连续的，优先选斜率大的。</p>
<p>所以维护的是所有可能成为最优解的斜线，被覆盖的没必要维护（覆盖可以通过函数图像的交点位置来判断），维护可以用单调栈。</p>
<p>最后处理出来就是一个永远最优的分段函数。</p>
<h2 id="快乐"><a href="#快乐" class="headerlink" title="快乐"></a>快乐</h2><p>定义$S_{i,j}$为完全包含在$[i,j]$区间内的线段的个数(人数)，这样就可以线性求完全包含在$[i,j]$内并且包含我枚举的$k\in[i,j]$的一个区间，也就是$S_{i,j}-S_{i,k-1}-S_{k+1,j}$ ,$k$为我枚举的假设最大值，让这些能到$k$的区间都到$k$，然后求一下这段区间。</p>
<h2 id="凌乱"><a href="#凌乱" class="headerlink" title="凌乱"></a>凌乱</h2><p>如何选择一种切法使得这个矩阵凌乱度最小</p>
<p>$f_{1,1,i,m}\le{f_{1,1,i+1,m}}$，</p>
<p>也就是说是单调不降的，</p>
<p>所以最大就是</p>
<p>$g_{i,j,k,l}&#x3D;x$左上角$(i,j)$，右上角$(i,k)$，最大的数满足$f_{i,j,x,k}\le{l}$（左上角右下角，矩阵凌乱度$\le{l}$，</p>
<p>假如横着切，上下两个矩阵都小于等于l-1</p>
<p>$g_{i,j,k,l-1}&#x3D;y$</p>
<p>下面</p>
<p>$g_{y+1,j,k,l-1}&#x3D;x$</p>
<p>$g_{i,j,k,l}&#x3D;g_{g_{i,j,k,{l-1}}+1,j,k,{l-1}}$</p>
<p>竖着切：</p>
<p>$$g_{i,j,k,l}&#x3D;max(y),y&#x3D;min(g_{i,j,y,l-1},g_{i+1,y+1,k,l-1})$$</p>
<p>因为就要切在下边界较小的那一个矩阵，因此要取min</p>
<p>$h_y&#x3D;min(g_{i,j,y,l-1},g_{i+1,y+1,k,l-1})$</p>
<p>$h_y$是先增后减的。</p>
<p>$g_{i,j,k,l}\ge{g_{i,j,k+1,l}}$</p>
<p>相当于面积相同的情况下，宽越大，高越长。</p>
<p>在中间竖着切了一刀，左边随着宽不断增大，高是不断减小的，右边相反，</p>
<p>所以$h_y$的第一项是单调不增的，第二项是单调不减的，</p>
<p>加上一个取min操作，将会存在一个分界点，使得其图像为一个单峰函数，</p>
<p>设分界点为$z$，$z$左侧第一项大于等于第二项，$z$右侧第一项小于等于第二项</p>
<p>因此$h_y$是先增后减的，可以通过二分查找这个分界线，然后比较它上面和下面的值谁更大。</p>
<p>$O(N&#x3D;n^3logn\times{logn})$</p>
<h2 id="P9387"><a href="#P9387" class="headerlink" title="P9387"></a>P9387</h2><p>$4k\oplus{4k+1}\oplus{4k+2}\oplus{4k+3}&#x3D;0$</p>
<p>这样就可以快速处理出$x$的值。</p>
<p>我们设$f_{i,j,k&#x3D;0&#x2F;1,t&#x3D;0&#x2F;1}$表示我考虑了二进制的前$i$位$(0\sim{i})$，当前位将向下进位的值是$j,j\in{0\sim{n}}$，$k$表示$b$是否大于$0$：$true&#x2F;false$，$t$表示前$i$位是否大于$n$，此时的方案数。</p>
<p>（$b$大于或等于$0$）</p>
<p>那就可以从低位到高位进行 DP 了，初始时$f_{-1,0,0,0}&#x3D;1$</p>
<p>转移方程是：</p>
<p>$$<br>f_{i+1,y,O_b|t,0&#x2F;1}+&#x3D;f_{i,j,t,k}<br>$$</p>
<p>这里$y&#x3D;\lfloor\frac{O_a+O_b+O_c+j}{2}\rfloor$。</p>
<p>$O_x$代表$x$的当前这一位的值，由于要满足$(a+b+c)\oplus{a}\oplus{c}&#x3D;x$，因此设$z&#x3D;{O_a+O_b+O_c}\pmod{2}$，$z\oplus{O_a}\oplus{O_c}&#x3D;O_x$。而这位的$O_a,O_b,O_c$分别枚举一下就好了，选出符合这个条件的进行转移。</p>
<p>$n$个二进制数加起来最多进$n-1$位，三个数最多进$2$位。</p>
<p>至于$\le{n}$，假如下一位小于$n$的下一位，那么就是小于<br>$n$，为$0$，假如下一位和$n$相同，那就继承上一个状态，因为还要接着比下去，如果下一位比$n$大，那就是大于，为$1$。</p>
<p>最后的答案就是$f_{60,0,1,0}$，因为$1e18$的二进制位数不会超过$60$位。</p>
<h1 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h1><h2 id="1-3"><a href="#1-3" class="headerlink" title="1."></a>1.</h2><h2 id="2-4"><a href="#2-4" class="headerlink" title="2."></a>2.</h2><h2 id="3-4"><a href="#3-4" class="headerlink" title="3."></a>3.</h2><h2 id="4-4"><a href="#4-4" class="headerlink" title="4."></a>4.</h2><h2 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h2><p>对于$n,m$和质数$p$，有$C(^n_m)\equiv{C(^{\lfloor\frac{n}{p}\rfloor}<em>{\lfloor\frac{m}{p}\rfloor})C(^{n%p}</em>{m%p})}$</p>
<p>$p&#x3D;2$时，$C(n,m)&#x3D;1,n\ge{m}$，所以$m$第$i$位为1时，$n$的第$i$位为1，$m$的第$i$位为$0$时，$n$的第$i$位为$0&#x2F;1$，所以$n&amp;m&#x3D;1$。</p>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>$\phi(n)&#x3D;\prod^{t}_{i&#x3D;1}(p_i-1)p_i^{a_i-1}&#x3D;n\cdot (1-\frac 1 {p_1})(1-\frac 1 {p_2})(1-\frac 1 {p_3})\dots(1-\frac 1 {p_t})$</p>
<p>$n&#x3D;p_1^{a_1}p_2^{a_2}\dots{p_t^{a_t}}$</p>
<p>$1-\frac{1}{p_1}&#x3D;\frac{p_1-1}{p_1}$</p>
<p>相乘即得。</p>
<h2 id="P2261余数求和"><a href="#P2261余数求和" class="headerlink" title="P2261余数求和"></a>P2261余数求和</h2><p>对于$n\in[1,1e7]$，求$ans_n&#x3D;\sum_{i&#x3D;1}^n{n}\mod{i}$。</p>
<p>来求解一下递推式：</p>
<p>$ans_n-ans_{n-1}&#x3D;\sum^{n-1}<em>{i&#x3D;1}{n}\bmod{i}-\sum</em>{i&#x3D;1}^{n-1}{n-1}\bmod{i}$。</p>
<p>这里第一项之所以枚举到$n-1$是因为枚举到$n$会使$n\bmod{n}&#x3D;0$所以就省掉了。</p>
<p>接着化简：</p>
<p>$$<br>\begin{aligned}<br>ans_n-ans_{n-1}&amp;&#x3D;\sum^{n-1}<em>{i&#x3D;1}{n}\bmod{i}-\sum</em>{i&#x3D;1}^{n-1}{n-1}\bmod{i}\<br>&amp;&#x3D;\sum_{i&#x3D;1}^{n-1}[(n%{i})-(n-1)%{i}]\<br>&amp;&#x3D;n-1-\sum_{i&#x3D;1}^{n-1}i\times[n%{i}&#x3D;0]\<br>&amp;&#x3D;2n-1-\sum_{i&#x3D;1}^{n}i\times[n%{i}&#x3D;0]\<br>&amp;&#x3D;2n-1-\sigma_k(n)\<br>\<br>\therefore ans_n&amp;&#x3D;ans_{n-1}+2n-1-\sigma_k(n)<br>\end{aligned}<br>$$</p>
<p>然后就可以线性递推了。</p>
<h2 id="原T4"><a href="#原T4" class="headerlink" title="原T4"></a>原T4</h2><p>求 $f_i&#x3D;\sum_{j&#x3D;0}^{m}j^i$  </p>
<p>那么我们先求一下 $\sum_{j&#x3D;0}^m(j+1)^i$  </p>
<p>那么这个是什么呢？  </p>
<p>实际上是 $f_i-0^i+(m+1)^i$  </p>
<p>因为这样实际上是枚举了 $1-m+1$  </p>
<p>相当在原来的枚举基础上少枚举了 $0$ 但是多枚举了 $m+1$  </p>
<p>那我们接着往下处理这个式子 </p>
<p>$$<br>\begin{aligned}<br>&amp;f_i-0^i+(m+1)^i\<br>&amp;&#x3D;\sum_{j&#x3D;0}^m(j+1)^i \<br>&amp;&#x3D;\sum_{j&#x3D;0}^{m}\sum_{k&#x3D;0}^{i}C_i^k j^k \<br>&amp;&#x3D;\sum_{k&#x3D;0}^{i}C_i^k\sum_{j&#x3D;0}^{m}j^k \<br>&amp;&#x3D;\sum_{k&#x3D;0}^{i}C_i^kf_k\<br>&amp;&#x3D;\sum_{k&#x3D;0}^{i-2}C_i^kf_k+C_i^{i-1}f_{i-1}+C_i^if_i\<br>&amp;&#x3D;\sum_{k&#x3D;0}^{i-2}C_i^kf_k+if_{i-1}+f_i\<br>\therefore &amp;if_{i-1}&#x3D; (m+1)^i-0^i-\sum_{k&#x3D;0}^{i-2}C_i^kf_k<br>\end{aligned}<br>$$</p>
<p>这样我们就得到了递推式</p>
<h2 id="错排"><a href="#错排" class="headerlink" title="错排"></a>错排</h2><p>对于每个$n$，求出有多少长度为$n$的排列，使得$p_i!&#x3D;i$。</p>
<p>我们设某个位置使得$p_j&#x3D;n$，那么就分情况讨论：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307292358909.webp"
                      alt="image.png"
                ></p>
<ol>
<li>假设$p_n&#x3D;j$，所以现在有两对错排已经确定了，那就是从剩下的$n-2$个数中选错排，而$j$的位置有$n-1$种可能，也就是$f_{n-2}\times(n-1)$。</li>
<li>假设$p_n!&#x3D;j$，我们把$p_n$移到$p_j$的位置，也就是说有$p_j!&#x3D;p_j$，所以有一对错排已经确定了，还剩$n-1$对，那么就是$f_{n-1}\times(n-1)$</li>
</ol>
<p>于是$f_n&#x3D;f_{n-2}\times(n-1)+f_{n-1}\times(n-1)$。</p>
<h2 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h2><p>计算$\sum_{i&#x3D;1}^{n}x_i&#x3D;m,x_i\ge{1}$的解的个数。</p>
<h3 id="隔板法"><a href="#隔板法" class="headerlink" title="隔板法"></a>隔板法</h3><p>把一个1看作一个小球</p>
<p>间隙插隔板</p>
<p>分组</p>
<p>组合数</p>
<p>$C(m-1,n-1)$</p>
<h3 id="实际意义"><a href="#实际意义" class="headerlink" title="实际意义"></a>实际意义</h3><p>选代表元</p>
<p>设$l_i,r_i$</p>
<p>每一对$l_i,r_i$对应着一个代表元，即方案</p>
<p>$x_i&#x3D;l_i+r_i+1$</p>
<p>$\sum{x_i}&#x3D;m$</p>
<p>设$l,r$都为$y$</p>
<p>$\sum(l_i+r_i)&#x3D;m-n$</p>
<p>那就是$\sum^{2n}_{i&#x3D;1}y_i&#x3D;m-n$</p>
<p>y都加一</p>
<p>$\sum^{2n}_{i&#x3D;1}(y_i+1)&#x3D;m-n+2n$</p>
<p>设$y_i+1&#x3D;z_i$</p>
<p>$\sum_{i&#x3D;1}^{2n}z_i&#x3D;m+n$</p>
<p>$C(m+n-1,2n-1)$</p>
<h2 id="翻折法"><a href="#翻折法" class="headerlink" title="翻折法"></a>翻折法</h2><p>遇到函数图像就把剩下的路径翻折</p>
<p>这样既可以求解不合法的方案数了</p>
<p>$C(n-k,m+k)$</p>
<h1 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h1><h2 id="1-4"><a href="#1-4" class="headerlink" title="1."></a>1.</h2><p>根据相对关系分三种情况讨论倒推出之前的位置。</p>
<h2 id="2-5"><a href="#2-5" class="headerlink" title="2."></a>2.</h2><p>每段的下一个与当前字符的关系都是相同的，</p>
<p>其实就是字符匹配，KMP</p>
<h2 id="3-5"><a href="#3-5" class="headerlink" title="3."></a>3.</h2><p>质因数分解</p>
<p>对于每个质数的指数相加起来，判断每个指数是不是k的倍数就可以了。</p>
<p>那么可以</p>
<p>维护每一位模k等于多少。</p>
<p>把每个区间维护成前缀和的形式，</p>
<p>那么区间求商那就是指数相减模k等于0</p>
<p>所以就是两个前缀模k意义下是相等的</p>
<p>维护一下模意义下的哈希就可以了</p>
<p>每一位都是0~k-1</p>
<p>递推的时候加一个数就进行哈希处理。</p>
<p>那么怎么对一个数快速进行质因数分解，</p>
<p>先用线性筛预处理出每个数的最小质因子，然后对每个数分别除一下就可以了。</p>
<p>哈希值要开大一些</p>
<h2 id="4-5"><a href="#4-5" class="headerlink" title="4."></a>4.</h2><p>Alice n&#x2F;2上取整</p>
<p>Bob n&#x2F;2下取整</p>
<p>$\sum{v_i}+\sum{lcp(i,j)}$</p>
<p>可以dfs记忆化搜索一下。</p>
<p>对每个串进行赋值，那么就可以直接进行点权相减</p>
<p>$v_i+\frac{1}{2}\sum_j{lcp(s_i,s_j)}$</p>
<p>这样能保证两个点加起来正好lcp被加了一遍</p>
<p>这样sort一下然后计算即可</p>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>字符串严格匹配</p>
<p>前半部分和后半部分</p>
<p>假如已经知道了一个长串的border，那么加上一个字符，那就继续比较下一个字符</p>
<p>这么说同时去掉最后一个字符也是相同的。</p>
<p>对于一个更长的串，那么它的border是被比它短的border更新而来的。</p>
<p>也就是用短串的border推到长串的border</p>
<p>设nxt_i表示长度为i的前缀border长度</p>
<p>一个串可以有很多border，排序后小的border是大的border的border</p>
<p>那么就维护每一个border的状态</p>
<p>从下往上枚举看看哪个border的下一个字符是匹配的</p>
<p>字符串匹配</p>
<p>判断m在n中出现了几次</p>
<p>一个是hash，一个是kmp</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307301513197.webp"
                      alt="image.png"
                ></p>
<h2 id="P3193"><a href="#P3193" class="headerlink" title="P3193"></a>P3193</h2><p>dp_i,j表示考虑完前i个字符目前匹配长度为j，匹配可以用KMP</p>
<p>只要保证j&lt;t就可以保证</p>
<p>然后把递推转化为矩阵快速幂就可以了</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>比较两个东西一不一样。</p>
<p>类似于编码的过程。</p>
<p>$\sum{s_i\times{b^i}}$</p>
<p>对于字母串，每个字符串当成一个26进制的数，b&#x3D;26</p>
<p>这么大的数肯定是存不下的，那就找一个大数取模</p>
<p>有$\frac{1}{p}$的概率相等。</p>
<p>优点：</p>
<p>判断t在s的某个位置是否出现</p>
<p>如何快速得到字串的哈希值？</p>
<p>前缀和预处理</p>
<p>也就是区间求和</p>
<p>$hash_i&#x3D;hash_{i-1}\times{b}+s_i$</p>
<p>$\sum_{i&#x3D;1}^n{s_i\times{b^{n-i}}}$</p>
<h2 id="P2312"><a href="#P2312" class="headerlink" title="P2312"></a>P2312</h2><p>让左边右边同时模上一个大质数，然后我们求一下在模意义下是否等于0就可以了。</p>
<p>可以设多个模数，增加正解的概率。</p>
<h2 id="P5537"><a href="#P5537" class="headerlink" title="P5537"></a>P5537</h2><p>对于走到每个节点，路径会产生一个序列，这个序列是唯一的，</p>
<p>每一个点都对应一个操作序列，</p>
<p>并且这个序列都唯一确定这个节点。</p>
<p>对于操作序列，若完全相等，那么到达的点相等。</p>
<p>每次对于这个$[l,r]$操作序列进行一个二分。</p>
<p>这个具有单调性，因为假如到这个操作序列的某个前缀已经走不通了，那么后面的也一定走不通。</p>
<p>所以我们要找的能走通的序列长度最长值。</p>
<p>对于每个点都处理出它对应的操作序列。</p>
<p>根节点是x？</p>
<p>也就是先到x再到要到的点，再进行拼接。</p>
<p>可以用线段树维护，可以合并两个哈希值</p>
<p>$h_1+h_2+\sum{B^{S_1}}$</p>
<h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><p>中间点很重要</p>
<p>一个回文串两边同时操作可以改变长度</p>
<p>来二分一下这个最长长度</p>
<p>回文中心</p>
<p>回文半径</p>
<p>abcba</p>
<p>!#a#b#c#b#a</p>
<p>感叹号是边界</p>
<p>b#b</p>
<p>这样回文中心就很显然了。</p>
<p>核心思想：<strong>求每个点的回文半径</strong></p>
<p>回文半径即对应回文子串的长度</p>
<p>假设之前有串覆盖到了我这个点，那么就可以对称过去，最大为覆盖区间的右端点，最大继承到右端点，也就是继承对称点回文半径的信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307302223107.webp"
                      alt="image.png"
                ></p>
<p>对于这张图，红色点的回文半径已经求出来了，也就是对应红色的区间，下面我往后枚举，发现要求黑色点的回文半径的时候，这个点在红色点的回文半径内，这就意味着红色区间内有点与其对称，而对称的灰色点在之前已经被处理过了。</p>
<p>所以我们就可以继承灰色点的回文半径，也就是说我们不用再枚举一遍了，<del>少走几十年弯路</del>。</p>
<p>假如灰色点的回文半径并没有超过红色点，那么黑色点的继承到的回文半径也不会超过红色区间。</p>
<p>假如灰色点的回文半径超过了红色点，那么黑色点的继承到的回文半径只能到红色点的回文半径的边界，因为再往外黑色点和灰色点就不是对称的了。</p>
<p>因此总结下来就是继承到的回文半径的位置要和红色点回文半径的位置取个$\min$。</p>
<h2 id="HDU5371"><a href="#HDU5371" class="headerlink" title="HDU5371"></a>HDU5371</h2><p>给定一个长度为n的数列 ，现在要求你找出最长的形似$s+s^R+s$的子串，$s^R$是$s$的反串。</p>
<p>两个回文中心。</p>
<p>只要两个回文半径可以互相覆盖到彼此的回文中心，那么就可以满足条件。</p>
<p>使满足这个条件下使两个回文中心间距最大就可以了。</p>
<p>$S_2-r_2\le{S_1}$</p>
<h2 id="P6216"><a href="#P6216" class="headerlink" title="P6216"></a>P6216</h2><p>$t$在$s$中哪些位置出现了可以用 KMP 。</p>
<p>对每个位置处理出$s_2$是否可以从这里开始到完全匹配，</p>
<p>也就是对于每一个$s_2$匹配的位置，我在它匹配的左端点的位置加一。</p>
<p>查询时右端点要减去$s_2$的长度，这样就可以保证区间内的“1”都是合法的，这样就可以去找区间里1的个数来计算$s_2$出现的次数，</p>
<p>然后枚举这个点的回文中心，</p>
<p>所有回文子串的公差为$1$，</p>
<p>右端点同时减去$s_2$的长度后公差依然是1.</p>
<p>左右端点都是等差数列。</p>
<p>可以用前缀和优化：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307302254026.webp"
                      alt="image.png"
                ></p>
<p>然后我们其实就是要求剩下的这个三角形中所有点的和。</p>
<p>$\sum_{i&#x3D;l}^{r-|s_2|+1}a_i\times(r-|s_2|-i+1)$</p>
<h2 id="P5446"><a href="#P5446" class="headerlink" title="P5446"></a>P5446</h2><p>$R\le{S}$时，满足条件的$R$一定是$S$的前缀，所以我们枚举$S$ 的前缀，</p>
<p>若对于每个枚举的$R$，对它进行不断翻转，若得到的$R$不是$S$的前缀，那就跳过。</p>
<p>对于最后一步，是关于$R$右端点为中心的回文串，判断一下即可 ，如果可以就可以判断这个 R 串是否可以。</p>
<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>树形结构，</p>
<p>从根走到底那就是一个字符串，</p>
<p>可以插入字符串，</p>
<p>没有出边就新建一条，</p>
<p>所以就可以用一棵树表示这个集合，</p>
<p>即一个字典树，</p>
<p>可以求 lcp，</p>
<p>即两个点 lca 的深度。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307302309042.webp"
                      alt="image.png"
                ><br>对于这颗Trie树上的字符串$\text{aba}$和$\text{abc}$，它们的lca是$b$，$b$的深度是$2$，因此它们的的$lcp$长度就是2。</p>
<h3 id="01Trie"><a href="#01Trie" class="headerlink" title="01Trie"></a>01Trie</h3><p>各种操作一样，字符集变成了0和1。</p>
<p>可以进行二进制操作</p>
<p>这样就可以对某个数得到异或值最大。</p>
<p>因为假如一个树二进制表示为$10110$，那么我就可以贪心地选择每位，如果可以我地最优选择是$01001$，假如某一位上没有我想要的（序列中没有该数），那就别无选择，但这样一个流程下来我得到的是最优解。</p>
<p>进行一个贪心</p>
<h2 id="P3065"><a href="#P3065" class="headerlink" title="P3065"></a>P3065</h2><p>建一棵树，</p>
<p>把小于号换做有向边，</p>
<p>跑拓扑排序，</p>
<p>出现环了这条路就走不通，假如之前已经有$a&lt;b&lt;c$，</p>
<p>后面又从$c\to{a}$，说明$c&lt;a$，那么就产生了矛盾，那么这条路就不能继续往下走。</p>
<h2 id="CF178F3"><a href="#CF178F3" class="headerlink" title="CF178F3"></a>CF178F3</h2><p>树形背包问题。</p>
<p>$nS_ik$</p>
<p>$dep_x\times{a}\times{b}$</p>
<p>$nk$</p>
<p>$n$个节点转移，其它的节点复制，因为只有一个儿子</p>
<h2 id="P4551"><a href="#P4551" class="headerlink" title="P4551"></a>P4551</h2><p>把一条路径拆成两段，</p>
<p>那就是$s$到根的异或和异或上$t$到根的异或和，</p>
<p>这个到根的异或和可以 dfs 处理一遍，</p>
<p>要找到一个$d_y$异或上$d_x$最大</p>
<p>对一个数求异或和最大，请问另一个数？</p>
<p>那就可以建01trie了。</p>
<h2 id="可持久化"><a href="#可持久化" class="headerlink" title="可持久化"></a>可持久化</h2><p>求$l,r$建出trie树</p>
<p>版本思想，</p>
<p>我有$q$次修改，那就有$q$个版本的 trie 树，</p>
<p>插入字符串的时候，新建一个部分 trie 树，这个trie 树上只保留信息改变的节点，也就是新加的节点和被影响到的原来的节点，</p>
<p>每个版本的trie树只需要记录根节点的信息。</p>
<p>对于没受到新节点影响的节点，直接对它们连接即可，</p>
<p>原来的查询可以照常进行。</p>
<h2 id="P5283"><a href="#P5283" class="headerlink" title="P5283"></a>P5283</h2><p>枚举右端点，找到使得异或和最大的左端点。</p>
<p>对于$S_i$找到一个$max_{j&lt;i}S_i{\oplus}S_j$</p>
<p>边查边插入右端点，用可持久化线段树。</p>
<p>最大值被选后，次大值才有可能成为答案，类似于超级钢琴</p>
<p>维护l,r，按照v用优先队列排序</p>
<p>大区间就会变成两个小区间，区间内的异或最大值可以用01trie解决</p>
<h2 id="Exkmp"><a href="#Exkmp" class="headerlink" title="Exkmp"></a>Exkmp</h2><p>维护最右端点使得之前的lcp延伸到这个端点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307302329248.webp"
                      alt="image.png"
                ></p>
<p>黑色为原序列，我现在要求每一个后缀与原序列的 lcp，即最大公共前缀。</p>
<p>比如我现在要求粉色点的 lcp，</p>
<p>但是发现这个点在当前最大lcp的右端点的范围内（红色线），即我们知道了灰色与黑色的 lcp，而灰色与蓝色的粉色部分又相同，于是蓝色和黑色的粉色部分也相同。</p>
<p>而对于粉色部分，我们已经知道了绿色与的 lcp，绿色&lt;粉色，相同位置的绿色&#x3D;粉色，于是绿色的 lcp 就可以被粉色点继承；假如绿色&gt;粉色，但是超出部分在蓝色部分中不一定相同，因此最多能继承到粉色的边界处，因此绿色的 lcp的右端点下标要与粉色右端点下标取$\min$后继承。</p>
<p>而对于字符串$b$与字符串$a$的每个后缀的 lcp ，就可以把$a$接到$b$的后面，然后从长度为$a$的后缀开始扫就可以了。</p>
<p>每次维护的就是当前 lcp 延展到的最大右端点以及当前的递推数组，也就是用到的绿色的 lcp 的长度。</p>
<p>后缀长度由长枚举到短，第一次没有可以继承的，那就只能自己扫一遍了。</p>
<h2 id="P7114"><a href="#P7114" class="headerlink" title="P7114"></a>P7114</h2><p>$n-border&#x3D;len$</p>
<p>C即为$S-(AB)^i$</p>
<p>C是确定的，C中奇数的个数很好求，</p>
<p>然后枚举一个AB的长度，也就是循环节的长度，再枚举一个循环的次数，</p>
<p>若$len|n$，那么$len$即循环节，用这个判断我们枚举的AB长度是否合法。</p>
<p>AB会在这个循环节内出现，A出现的频率为$1\sim{len-1}$，所以就枚举所有的A，</p>
<p>然后用桶记录每个奇数出现的次数，加起来，看看是否满足$F(A)&lt;F(C)$，那就累加答案。</p>
<h1 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h1><h2 id="1-5"><a href="#1-5" class="headerlink" title="1."></a>1.</h2><p>树形 DP</p>
<p>设$f_x$代表从$x$出发到其子树内最长链的长度。</p>
<p>转移就是$f_x&#x3D;\max(f_x,f_y+(a_x\oplus{a_y}))$</p>
<p>$ans&#x3D;\max(ans,f_x+f_y+(a_x\oplus{a_y}))$</p>
<h2 id="2-6"><a href="#2-6" class="headerlink" title="2."></a>2.</h2><p>用$f_{x,y}$代表从$y$出发到$x$的路径条数。</p>
<p>可以拓扑排序并转移。</p>
<p>若$z$是$x$的一个前驱，那么$f_{x,y}+&#x3D;f_{z,y}$</p>
<p>由于我们只关心奇偶性，因此只记录0 1就可以了，转移就是$f_{x,y}&#x3D;f_{x,y}\oplus{f_{z,y}}$。</p>
<p>用bitset维护就可以了。</p>
<h2 id="3-6"><a href="#3-6" class="headerlink" title="3."></a>3.</h2><p>$dp_x$表示让$x$值为1的最少子树中$1$的个数。</p>
<p>看下$dp_1$是否大于1的个数。</p>
<h2 id="4-6"><a href="#4-6" class="headerlink" title="4."></a>4.</h2><p>前i个数已经分成了j个集合的方案数，转移：</p>
<p>$S_{n,m}&#x3D;S_{n-1,m}\times{m}+S_{n-1,m-1}$</p>
<p>树上？</p>
<p>按照bfs序 DP</p>
<p>$S_{3,k}$</p>
<p>$S_{4,k}&#x3D;S_{3,k}\times{k-2}+S_{3,k-1}$</p>
<p>$S_{n,m}&#x3D;S_{n-1,m}\times{m-dep}+S_{n,m-1}$</p>
<p>要么就加到剩下的集合，要么就自己新开一个集合。</p>
<p>从上到下 DP。</p>
<p>这样就能保证DP到一个点的时候，它的祖先已经处理好了。</p>
<h2 id="P3304"><a href="#P3304" class="headerlink" title="P3304"></a>P3304</h2><p>求有多少条边满足所有直径都经过该边。</p>
<ul>
<li>直径是一定有交点。</li>
<li>如果分叉了，那么两端是一样长的，否则就可以有更大的直径。</li>
<li>两个树，两个直径，将两棵树的根节点连接起来，一共可能有六条直径。</li>
</ul>
<p>从树上某个点dfs，深度最深的点一定是某个直径的端点，</p>
<p>查路径长度直接查LCA就可以了。</p>
<p>先找出来一条直径，</p>
<p>从右端点 DFS，</p>
<p>对每个点记录它到子树里最深的一条链，</p>
<p>然后如果和当前点到右端点的长度相同，那么就可以替代，</p>
<p>执行完所有的操作后主链上剩下的就是公共的边。</p>
<h2 id="P3177"><a href="#P3177" class="headerlink" title="P3177"></a>P3177</h2><p>一条边被多少个点对经过就是它的贡献。</p>
<p>其实就是这条边左右两边黑色点的对数加上白色点的对数。</p>
<p>设$f_{x,t}$表示在x子树内选了t个黑点，最小贡献是。</p>
<p>新加子树y，</p>
<p>$f_{x,a+b}+&#x3D;f_{x,a}+f_{y,b}+v(x,y)$</p>
<p>$a(k-a)+(S-a)\times{(n-S)-(k-a)}$</p>
<p>合并的时候$a:0\sim{S}$</p>
<p>n方个点对，那就是n方</p>
<h2 id="P3174"><a href="#P3174" class="headerlink" title="P3174"></a>P3174</h2><p>$f_x$表示从x开始向子树里找一条链使这个毛毛虫最大。</p>
<p>枚举儿子</p>
<p>$f_x&#x3D;f_y+sum_x+1-1$</p>
<p>在lca处合并</p>
<p>找最大的两个$f_y$</p>
<p>$f_x&#x3D;f_{y_1}+f_{y_2}+sum_x-1(+1)$父节点</p>
<h2 id="CF1153D"><a href="#CF1153D" class="headerlink" title="CF1153D"></a>CF1153D</h2><p>$dp_x$表示x为1儿子最小填1的个数，</p>
<p>对于max和min分别讨论</p>
<hr>
<p>设$dp_x$设x在子树中有s个叶子，x最多能排多少名。</p>
<p>1:</p>
<p>$f_x&#x3D;\max(s-\min(s_i-f_i))$</p>
<p>0:</p>
<p>$f_x&#x3D;\sum{(f_i-1)}+1$</p>
<h2 id="P3523"><a href="#P3523" class="headerlink" title="P3523"></a>P3523</h2><p>对K二分，</p>
<p>也就是以每个我选的点为中心，K为半径形成一片覆盖区，如果能全部覆盖全部关键点，那这个K就可以满足。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307312019283.webp"
                      alt="image.png"
                ></p>
<p>如上图，红色点为关键点，蓝色点为我选的节点，蓝色⚪为当前覆盖区，显然，上图为一种合法的方案。</p>
<p>对于每一个点和一个K，一定是让一个关键点再覆盖范围边界被覆盖到是最优的，因此我们要让这些关键点刚好卡上这些边界，这样就可以使它可以覆盖到更远的点。</p>
<p>所以我们定义$f_x$代表x子树中最远还没有覆盖的点的位置，如果这个距离等于K了，我就在这里选一个点。</p>
<p>定义$g_x$代表覆盖到的最近的已经选的点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307312224158.webp"
                      alt="image.png"
                ></p>
<p>如果某个关键点到$y$的距离即$f_x+g_x\le{K}$，那么这个关键点就会被波及。</p>
<p>那么就可以更新$f_x&#x3D;-INF,g_x&#x3D;0$</p>
<h2 id="1453"><a href="#1453" class="headerlink" title="1453"></a>1453</h2><p>基环树</p>
<p>树上问题是求解<strong>最大独立集</strong></p>
<p>设$f_{x,0&#x2F;1}$x这个点选&#x2F;不选，子树的最大权值</p>
<p>选了那就是x的权值加上儿子都不能选</p>
<p>对每个子树做一个DP，每个点对应选这个点对应的权值和不选这个点对应的权值。</p>
<h2 id="P4381"><a href="#P4381" class="headerlink" title="P4381"></a>P4381</h2><p>设$f_x$表示从$x$到其子树的最长路径是多少。</p>
<p>断环为链，记录链上的路径前缀和$S$，答案就是</p>
<p>枚举 $y$并维护$x$的前缀最大值</p>
<h2 id="CF187E"><a href="#CF187E" class="headerlink" title="CF187E"></a>CF187E</h2><p>选了根节点之后，答案就是每个点的子树大小之和。</p>
<p><strong>换根DP</strong></p>
<p>$f_y&#x3D;f_x+n-2\times{size_y}$</p>
<p>把x换到儿子y上。</p>
<h2 id="P2986"><a href="#P2986" class="headerlink" title="P2986"></a>P2986</h2><p>换根DP</p>
<p>$f_y&#x3D;f_x+size_x\times{w}-size_y\times{w}$</p>
<h2 id="P4438"><a href="#P4438" class="headerlink" title="P4438"></a>P4438</h2><p>对每个点记录x y有多少，</p>
<p>$f_{x,j,k}$x节点，j个l，k个r的贡献大小。</p>
<h2 id="P2014"><a href="#P2014" class="headerlink" title="P2014"></a>P2014</h2><p>在x的子树中选了大小为i的子树得到的最大价值</p>
<p>$dp_{x,i+j}&#x3D;dp_{x,i}+dp_{y,j}$</p>
<p>$dp_{x,1}&#x3D;a_x$</p>
<p>$O(n^2)$</p>
<p>只要下标小于等于$size$，那么就是两两配对$n^2$的</p>
<h2 id="LOJ160"><a href="#LOJ160" class="headerlink" title="LOJ160"></a>LOJ160</h2><p>dfs 序——后dfs优化背包</p>
<p>先 dfs 子树，再把根计入。</p>
<p>只有递归完了子树，根节点才会被假如</p>
<p>$dp_{x,i}$　dfs序到了x在这里，总递归完的子树为i的方案</p>
<p>$dp_{x,i}&#x3D;\max(dp_{x-size_x,i},dp_{x-1,i-w_i}+v_i)$</p>
<h2 id="P1080"><a href="#P1080" class="headerlink" title="P1080"></a>P1080</h2><p>$a_i,b_i$</p>
<p>交换：微扰法</p>
<p>把所有的人的$a_ib_i$排序</p>
<h2 id="P3574"><a href="#P3574" class="headerlink" title="P3574"></a>P3574</h2><p>设$f_x$为只走x子树中的点，所求的最小值。</p>
<p>$dp_i+2\sum_{i&lt;j}size+1$</p>
<p>类似于国王的游戏</p>
<p>$b_j+a_i\le{b_i+a_j}$</p>
<p>$a_i-b_i$越小越放到前面。   </p>
<h1 id="Day9"><a href="#Day9" class="headerlink" title="Day9"></a>Day9</h1><p><strong>NONE</strong></p>
<h1 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h1><h2 id="1-6"><a href="#1-6" class="headerlink" title="1."></a>1.</h2><h2 id="2-7"><a href="#2-7" class="headerlink" title="2."></a>2.</h2><p>设$dp_{i,j}$为从某个1开始走到i,j的最小花费。</p>
<p>而每一层点特别多的时候就可以用多源最短路。</p>
<p>$f_{i,j}&#x3D;\min({f_{i_1,j_1}}+|i-i_1|+|j-j_1|)$</p>
<p>令$f^1_{i,j}&#x3D;\min({f^1{i_1,j_1}})+i+j$</p>
<p>然后就可以将第一维排序，</p>
<p>然后查询的时候就相当于查询第二维的区间最小值，这样就可以用线段树或者树状数组来做。</p>
<p>插入点的优先级要比查询的优先级高。</p>
<p>就可以分成两个象限来处理，$x&lt;0&#x2F;x&gt;0$。</p>
<h2 id="3-7"><a href="#3-7" class="headerlink" title="3."></a>3.</h2><p>暴力枚举点对可以$n^2$解决。</p>
<p>可以先把一个点和它所有互质的点都预处理出来。</p>
<p>对每个点维护一下到根有多少互质的点。</p>
<p>然后就可以用树上差分，$O(n^2)$预处理,$O(1)$查询。</p>
<p>我们只关心质因子的种类，而不是个数。</p>
<p>那么其实就是两个集合的交集为空。</p>
<p>容斥？</p>
<p>$(^{r-l+1}<em>2)-\sum_P(^{cut_p}<em>2)+\sum</em>{PQ}(^{cut</em>{PQ}}<em>2)-\sum</em>{PQR}(^{cut_{PQR}}_2)$</p>
<p>加入元素？</p>
<p>删去元素？</p>
<h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><p>一个序列，长度为n，每次区间询问。</p>
<p>先把这些询问按照某种方式打乱顺序。</p>
<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><h2 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h2><h2 id="Unordered-Map"><a href="#Unordered-Map" class="headerlink" title="Unordered Map"></a>Unordered Map</h2><h1 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h1><h2 id="1-7"><a href="#1-7" class="headerlink" title="1."></a>1.</h2><p>按照a排序</p>
<p>维护前缀和</p>
<p>枚举r的同时更新与l有关的变量的最小值</p>
<h2 id="2-8"><a href="#2-8" class="headerlink" title="2."></a>2.</h2><p>令f为长度为i有j个顶的个数</p>
<p>每次插入新排列的最大值，</p>
<p>插入再原本的顶旁边顶的数不会变，</p>
<p>最左边和最右边也不会变，其它地方顶的数量就会加一。</p>
<h2 id="3-8"><a href="#3-8" class="headerlink" title="3."></a>3.</h2><p>将点按$x_i$排序。</p>
<p>$dp_{i,0&#x2F;1}$表示第以i个点为端点向左&#x2F;向右的方案数。</p>
<h2 id="4-7"><a href="#4-7" class="headerlink" title="4."></a>4.</h2><p>假如$a_i&lt;a_j$，在满足$i&lt;k&lt;j$的情况下，$a_k&gt;a_i$，这个时候以$k,j$作为前两位更优，因为大小和第三个数的选择范围；</p>
<p>假如$a_i&gt;a_j$，中间存在一个$k$满足$a_k&gt;a_j$，这个时候$i,k$更优。</p>
<p>所以这个时候对一个点，选左边&#x2F;右边的第一个比它大的数更优。</p>
<p>有用的前两个数只有$O(n)$个。</p>
<p>对询问按照左端点从大到小排序。</p>
<p>对序列从右向左扫描，每次找一个c的最大后缀，也就是找到$a_i+a_j$的最大值，来和我当前的这个点$k$匹配，而$k&gt;&#x3D;$某个数，所以是最大后缀，用线段树维护。 </p>
<h2 id="P8819"><a href="#P8819" class="headerlink" title="P8819"></a>P8819</h2><p>给每个点随机一个权值，</p>
<p>统计所有起点的点权和和所有点的点权和。</p>
<p>如果相等，那么说明符合。</p>
<p>那么就维护每个点以它为终点的激活边的起点的权值和与每个点以它为终点的失活边的起点的权值和，然后每次进行这种操作的时候给对应加上或者减去对应权值和即可。</p>
<h1 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h1><h2 id="1-8"><a href="#1-8" class="headerlink" title="1."></a>1.</h2><p>海底高铁</p>
<h2 id="2-9"><a href="#2-9" class="headerlink" title="2."></a>2.</h2><p>同Day7 T1</p>
<h2 id="3-9"><a href="#3-9" class="headerlink" title="3."></a>3.</h2><p>每个点记录以它为左上角&#x2F;右下角为顶点的正方形的最大边长，</p>
<p>那么边长区间就是$l\sim{l_{i,j}}$ 。</p>
<p>如果组成正方形，那么两点处于对角线位置，再判断左上角的长度是否合法和右下角长度是否合法。</p>
<p>三个条件：</p>
<p>$l_{x_1,y_1}\ge{x_2-x_1}$</p>
<p>$r_{x_2,y_2}\ge{x_2-x_1}$</p>
<p>$x_2-x_1\ge{l}$</p>
<p>所以就枚举对角线，算对角线上的两个点</p>
<p>枚举$x_2$，看有几个合法的$x_1$</p>
<p>那就分别算$1\sim{l-1}$和$1\sim{r}$所有$\ge{x_2-l_{x_1,y_1}}$的点，$O(1)$查询。</p>
<p>可以树状数组</p>
<h2 id="4-8"><a href="#4-8" class="headerlink" title="4."></a>4.</h2><blockquote>
<p>又是全排列</p>
</blockquote>
<p>$dp_{i,j}$代表考虑了前i个数，选择情况为j（二进制下表示，0代表未选，1待选已选），这种情况下的逆序对数。</p>
<p>状压 DP</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Training</tag>
      </tags>
  </entry>
  <entry>
    <title>ZR 七连测</title>
    <url>/6289c257.html</url>
    <content><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>一道二维前缀和。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309030657655.webp"
                      alt="image.png"
                ></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2005</span>;</span><br><span class="line"><span class="type">int</span> mp[N][N];</span><br><span class="line"><span class="type">int</span> sum[N][N];</span><br><span class="line"><span class="type">int</span> sumRigh[N][N],sumDown[N][N];</span><br><span class="line"><span class="type">char</span> a[N][N];</span><br><span class="line">string s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;E:/下载/Compressed/problem_2633/ex_A2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="type">int</span> n, m, h, w, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;h,&amp;w,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s\n&quot;</span>, a[i] + <span class="number">1</span>);</span><br><span class="line">        s[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="comment">// 每个点只看它的右边和下边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// if(i - 1 &gt;= 1) a[i][j] += (a[i-1][j]!=a[i][j]);</span></span><br><span class="line">            <span class="comment">// if(j - 1 &gt;= 1) a[i][j] += (a[i][j-1]!=a[i][j]);</span></span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt;= n) mp[i][j] += (a[i + <span class="number">1</span>][j] != a[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= m) mp[i][j] += (a[i][j + <span class="number">1</span>] != a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="comment">// 每个点只看它的右边和下边</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + mp[i][j]; <span class="comment">// printf(&quot;sum[%d][%d] = %d\n&quot;, i, j, sum[i][j])</span></span><br><span class="line">            <span class="keyword">if</span>(a[i][j] != a[i + <span class="number">1</span>][j] &amp;&amp; i + <span class="number">1</span> &lt;= n) sumDown[i][j] = sumDown[i][j - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">// 下面总和</span></span><br><span class="line">            <span class="keyword">else</span> sumDown[i][j] = sumDown[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] != a[i][j + <span class="number">1</span>] &amp;&amp; j + <span class="number">1</span> &lt;= m) sumRigh[i][j] = sumRigh[i - <span class="number">1</span>][j] + <span class="number">1</span>; <span class="comment">// 右边总和</span></span><br><span class="line">            <span class="keyword">else</span> sumRigh[i][j] = sumRigh[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// printf(&quot;sum[%d][%d] = %d\n&quot;,i,j,sumRigh[i][j]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + h - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j + w - <span class="number">1</span> &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            x1 = i;</span><br><span class="line">            y1 = j;</span><br><span class="line">            x2 = i + h - <span class="number">1</span>;</span><br><span class="line">            y2 = j + w - <span class="number">1</span>;</span><br><span class="line">            now = sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2] - sum[x2][y1 - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// for(int l = y1; l &lt;= y2; l++) // 最后一行</span></span><br><span class="line">            <span class="comment">//     if(a[x2][l] != a[x2 + 1][l] &amp;&amp; x2 + 1 &lt;= n) now--;</span></span><br><span class="line">            now -= sumDown[x2][y2] - sumDown[x2][y1 - <span class="number">1</span>];</span><br><span class="line">            now -= sumRigh[x2][y2] - sumRigh[x1 - <span class="number">1</span>][y2];</span><br><span class="line">            <span class="comment">// for(int l = x1; l &lt;= x2; l++)</span></span><br><span class="line">            <span class="comment">//     if(a[l][y2] != a[l][y2 + 1] &amp;&amp; y2 + 1 &lt;= m) now--;</span></span><br><span class="line">            <span class="keyword">if</span>(now &gt;= k) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309030657593.webp"
                      alt="image.png"
                ></p>
<p>记 $b_i$ 为 $a_{i}$ 和 $a_{i-1}$ 之间需要共同减掉的次数，那么就要满足 $b_{i-1}+b_i&#x3D;a_i$。</p>
<p>然后考虑每个 $b_i$，把它变成一个 $\pm b_0+c$ 的形式，如果 $n$ 是奇数，那么 $b_{n-1}&#x3D;b_0+c$ ，然后 $b_0+b_{n-1}&#x3D;k$，这样就可以解出 $b_0$ ，然后求其它的 $b_i$，如果算出有结果小于零或者是小数，那就是无解，否则有解。</p>
<p>如果 $n$ 是偶数，这时候 $b_{n-1}&#x3D;-b_0+c$，$b_0+b_{n-1}&#x3D;k$，这时候如果带入的话就会都消掉什么也解不出来，这时候 $c$ 和 $k$ 是相同的，</p>
<p>$\pm b_i&#x3D;b_0+c,b_i\ge0$ 这样就可以把 $b_0$ 解出一个范围，如果这个范围内有非负整数解的话，那就满足条件，否则无解。</p>
<p>考场就写了个 $sum$ 是否为偶数的特判🤣。</p>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309030742707.webp"
                      alt="image.png"
                ></p>
<p>$f_i&#x3D;\sum_{j\in S} f_{i-j}\times (i-j+1)$，可以用矩阵乘法维护这个十五行的矩阵。</p>
<p>考虑构造左边的矩阵，</p>
<p>比如 1 存在的话，那么第一行第一列就是 $i$，因为 $f_i&#x3D;f_{i-1}\times i$。</p>
<p>然后存在的话就填 $i-k+1$ ，不然就填 0，然后下面几行该位存在就往后填一位 1，这样就可以保证递推。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309030729551.webp"
                      alt="image.png"
                ></p>
<p>这时候可以尝试使用矩阵快速幂，但是这里的每次要乘的矩阵都不相同，所以不可以通过矩阵乘法来维护，但是这个模数非常特殊，比较小，如果在矩阵里把每个数都模一个 2027，这个矩阵第一行其实是循环的，下面是不变的，$n$ 很大的情况下会形成很多个循环节，每个对应一个矩阵乘法，然后后面可能会剩一些，但也不会超过 2027。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309030738609.webp"
                      alt="09XDUSI%$7_RX3%Y1K2(NYS.png"
                ></p>
<p>由于矩阵乘法满足结合律，所以可以先处理一段循环节，然后再处理矩阵快速幂，最后再加上多出来的矩阵。</p>
<p>递推式也可以写成：</p>
<p>$$<br>f_i&#x3D;i\times{\sum f_{i-j}}<br>$$<br>如果这样递推出来的话就是 $\dfrac{f_{n}}{n}$，因为最后一个不需要考虑，</p>
<p>但是如果 $n$ 是 2027 的倍数的话，就不能直接推到第 $n$ 项，需要求出 $n-1$ 项再求第 $n$ 项。</p>
<p>考场代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">2027</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span> + <span class="number">3e7</span>;</span><br><span class="line">ll f[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;E:/下载/Compressed/problem_2635/ex_C2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">        s.<span class="built_in">emplace_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;j : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = i + j;</span><br><span class="line">            <span class="keyword">if</span>(v &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            f[v] += f[i] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, (f[n] % mod));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我这样递推最后就不用乘以一个 $n$。</p>
<h2 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h2><blockquote>
<p>二分答案</p>
</blockquote>
<p>往里放数，使得每两个数之间的差都小于等于 $k$ 是否可行。</p>
<p>每个数可以往左放和往右放，肯定是把这个序列分成好多段，一些是往左放一些是往右放，所以每一段就可以用 RMQ 求一个差的最大值，由于分界点的位置知道，剩下的东西就很好维护，而且相邻两个分界点的数差也不能超过 $k$。</p>
<p>记 $dp_i$ 表示以 $i$ 和 $i+1$ 为一个分界点时是否可行。</p>
<p>它可以从前面最远的一个 $j$ 满足 $f_j&#x3D;1$ 转移而来，</p>
<p>这个 $j$ 要满足 $j\sim{i}$ 这些数的差的最大值小于等于 $k$。</p>
<p>并且 $a_j-a_{i+1}\le{x}$，这是因为可以把原序列分为若干段，要么是左要么是右，两个相邻的分界点由于是放在同一端，所以它们的端点之间也需要满足条件。</p>
<p>满足条件的 $a_j$ 是一段区间，也就是 $a_{i+1}-k\sim{a_{i+1}+k}$。</p>
<p>而满足以 $i$ 为右端点的后缀且满足这段后缀最大差小于等于 $k$ 可以用倍增求出最小的 $j$ ，然后用线段树维护合法的分界点，查询 $a_j$ 在某段区间中 $j$ 的最大值即可。</p>
<p>但是由于常数问题，会被卡到 80 分。</p>
<hr>
<p>一百分：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309031923691.webp"
                      alt="image.png"
                ></p>
<p>实际上就是没有放，只是不断扩展这两段区间，每次判断一下范围即可。</p>
<hr>
<p>不会编了。</p>
<p>考场代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] - q.<span class="built_in">front</span>() &lt;= a[i] - q.<span class="built_in">back</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] - q.<span class="built_in">back</span>() &lt;= x) q.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i] - q.<span class="built_in">front</span>() &lt;= x) q.<span class="built_in">push_front</span>(a[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] - q.<span class="built_in">front</span>() &gt; a[i] - q.<span class="built_in">back</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] - q.<span class="built_in">front</span>() &lt;= x) q.<span class="built_in">push_front</span>(a[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i] - q.<span class="built_in">back</span>() &lt;= x) q.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;E:/下载/Compressed/problem_2636/ex_D2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minn = <span class="number">0x3f3f3f3f</span>,maxn = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        minn = <span class="built_in">min</span>(minn, a[i]);</span><br><span class="line">        maxn = <span class="built_in">max</span>(maxn, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    r = maxn - minn;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>用了一个 deque 进行贪心模拟，甚至有 55 分。</p>
<h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><h2 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a>T1</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202309101131130.webp"
                      alt="image.png"
                ></p>
<p>题意简化：</p>
<p>给你一个序列，问有多少对数在模 200 意义下相等。</p>
<hr>
<p>那就对 $0\sim200$ 内每一个数建一个桶，答案就是 $\sum_{i&#x3D;1}^n {i\choose2}$。</p>
<p>记得开 <code>long long</code>。</p>
<p>代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> sum[N][<span class="number">205</span>];</span><br><span class="line">ll c[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">200000</span>; ++i)</span><br><span class="line">        c[i][<span class="number">2</span>] = <span class="number">1ll</span> * i * (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span>) a[i] += ((-a[i]/<span class="number">200</span>)<span class="number">+1</span>)*<span class="number">200</span>;</span><br><span class="line">        a[i] %= <span class="number">200</span>;</span><br><span class="line">        sum[i][a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) </span><br><span class="line">            sum[i][j] += sum[i + <span class="number">1</span>][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; ++i)</span><br><span class="line">        ans += c[sum[<span class="number">1</span>][i]][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202309101139779.webp"
                      alt="image.png"
                ></p>
<p>考虑贪心做法：</p>
<p>最小：</p>
<p>从左往右考虑，这个人如果左边右边还有自己的位置都没有人，那么肯定是往右会更优，因为往右可能会与下一个人相遇，而往左或者不动概率就会小。</p>
<p>而对于周围有人的情况，那就直接过去即可。</p>
<hr>
<p>最多：</p>
<p>最少的时候我们尽量让一个周围都没人的人往右靠，那么最多与他相反，在不与他人重合的情况下，优先往左靠。</p>
<hr>
<p>DP 的话那就令 $f_{i,0&#x2F;1&#x2F;2}$ 代表考虑完了前 $i$ 个位置并且第 $i$ 个位置是向左&#x2F;不动&#x2F;向右，的最小&#x2F;最大房屋数，本人当时就这么写的但是转移方程看上去很麻烦就没有信心推下去，写了一半 DP 一半贪心，光荣挂分。</p>
<h2 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h2><blockquote>
<p>CF1735C</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202309101202567.webp"
                      alt="image.png"
                ></p>
<p>有两个串 $S$ 和 $T$， 存在 $S\to T$ 的一个映射关系，映射关系为字母之间的一个环，大小为 26。</p>
<p>现在给定 $T$， 求字典序最小的 $S$。</p>
<p>可以考虑贪心的做法，从前往后遍历，对于每个第一次出现的字母，寻找它对应的合法的且字典序最小的一个映射。</p>
<p>这里合法指的是不能提前形成环，也就是不能在大小 $&lt;26$ 之前就形成了环，比如 $\text{ab}$ 不能与 $\text{ba}$ 建立一个映射关系，因为如果这样 $a$ 就是 $b$ 的下一个，$b$ 也是 $a$ 的下一个，这样就构成了一个二元环，其它元素没有办法插入，也就不合法。</p>
<p>当前环的大小可以每次向前跳统计长度，也可以通过并查集维护大小。</p>
<p>代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span><span class="number">+7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">char</span>&gt; mp, az;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">		mp.<span class="built_in">clear</span>();</span><br><span class="line">		az.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 为每个字符寻找映射</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(mp[s[i]]) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, mp[s[i]]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">char</span> t= <span class="string">&#x27;a&#x27;</span> ; t &lt;= <span class="string">&#x27;z&#x27;</span>; t++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(t == s[i]) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span>(!az[t]) <span class="comment">// t还没有映射对象</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="type">char</span> tt = t;</span><br><span class="line">						<span class="type">int</span> cnt = <span class="number">0</span>; </span><br><span class="line">						<span class="keyword">while</span>(tt &amp;&amp; tt != s[i])</span><br><span class="line">						&#123;</span><br><span class="line">							cnt++;</span><br><span class="line">							tt=mp[tt]; </span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span>(tt == s[i] &amp;&amp; cnt &lt; <span class="number">25</span>) <span class="keyword">continue</span>; <span class="comment">// 判断不合法情况</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, t); <span class="comment">// 可以的话那么t就是字典序最小的映射</span></span><br><span class="line">						mp[s[i]] = t;</span><br><span class="line">						az[t] = mp[s[i]];</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="T4-1"><a href="#T4-1" class="headerlink" title="T4"></a>T4</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202309101217268.webp"
                      alt="image.png"
                ></p>
<p>首先暴力可以想到跑 Floyed 全源最短路，枚举一个中间点，复杂度 $O(n^3)$</p>
<hr>
<p>$1\to u$ 的路径其实分为两段，$1\to p+u\to p$，我们要求这个路径的最小值，</p>
<p>由于后半部分边是反向的，所以我们可以建反向图（分层图），然后在原图和反向图之间两个编号相同的点之间建立一条边权为 0 的边，然后以原图的 1 号点为原点，以反向图中的每一个点为终点跑最短路即可。</p>
<p>复杂度就是 Dijkstra 的复杂度。</p>
<h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><h2 id="T1-2"><a href="#T1-2" class="headerlink" title="T1"></a>T1</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309161947002.webp"
                      alt="image.png"
                ></p>
<p>随便手搓几个样例我们发现这个序列里只有 1 和 2。</p>
<p>那么思路就是：</p>
<p>从左向右遍历区间，记录 1 的个数，找出所有 2 的连续区间，如果这个区间的长度是奇数，那么就把答案加上 $(len+1)&#x2F;2$，同时判断左端点的左边是否为 1，如果是，就要把它减去，然后把这一位的 1 给减去。</p>
<p>如果这个 2 的区间长度是奇数，那么就把答案加上 $len&#x2F;2$，同时判断左端点的左边 1 给减去，同时把 1 的个数加一，因为我们把最后一个二看成 1，减去以后它相当于不变，也就是把这个 2 给变成 1。</p>
<p>代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e7</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// int a[] = &#123;0, 1, 2, 2, 1, 2, 2, 2, 1&#125;;</span></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n, s1, s2;</span><br><span class="line">ll s3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Gen</span><span class="params">(<span class="type">int</span> n, <span class="type">unsigned</span> s1, <span class="type">unsigned</span> s2, <span class="type">unsigned</span> s3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        s1 ^= s3;</span><br><span class="line">        s3 += <span class="number">3055373123u</span>;</span><br><span class="line">        a[i] = (<span class="number">1</span> &lt;&lt; ((s1 &gt;&gt; s2) &amp; <span class="number">1</span>));</span><br><span class="line">        s2 = (s2 ^ s3) &amp; <span class="number">31</span>;</span><br><span class="line">        s3 = (s3 &gt;&gt; s2) | ((s3 &lt;&lt; (<span class="number">31</span> ^ s2)) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%lld&quot;</span>, &amp;n, &amp;s1, &amp;s2, &amp;s3);</span><br><span class="line">    <span class="built_in">Gen</span>(n, s1, s2, s3);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> fir = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fir)</span><br><span class="line">            &#123;</span><br><span class="line">                fir = <span class="literal">false</span>;</span><br><span class="line">                l =  r = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                r = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((a[i] == <span class="number">1</span> || i == n) &amp;&amp; !fir) <span class="comment">// 结束一段 2 的区间</span></span><br><span class="line">        &#123;</span><br><span class="line">            fir = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(len &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[l - <span class="number">1</span>] == <span class="number">1</span>) sum1--;</span><br><span class="line">                <span class="keyword">if</span>(a[i] == <span class="number">1</span>) sum1--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans += len / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[l - <span class="number">1</span>] == <span class="number">1</span>) sum1--;</span><br><span class="line">                sum1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (sum1 + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;, sum1);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 2 2 1 1 ans = 2</span></span><br><span class="line"><span class="comment">// 1 2 2 1 1 1 2 2 2 1 ans = 4</span></span><br><span class="line"><span class="comment">// 2 2 2 2 ans = 3</span></span><br><span class="line"><span class="comment">// 1 2 2 1 2 2 2 1 ans = 4</span></span><br></pre></td></tr></table></figure></div>

<h2 id="T2-2"><a href="#T2-2" class="headerlink" title="T2"></a>T2</h2><blockquote>
<p>一眼最短路</p>
</blockquote>
<h2 id="T3-2"><a href="#T3-2" class="headerlink" title="T3"></a>T3</h2><h2 id="T4-2"><a href="#T4-2" class="headerlink" title="T4"></a>T4</h2><h1 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h1><h2 id="T1-3"><a href="#T1-3" class="headerlink" title="T1"></a>T1</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309242115447.webp"
                      alt="image.png"
                ></p>
<p>普通攻击给到血量最小的，再现攻击给到血量最大的。</p>
<p>有个东西叫做 [[数据结构#Multiset|multiset]]，可以在 log 的时间内维护一个有序的序列。</p>
<h2 id="T2-3"><a href="#T2-3" class="headerlink" title="T2"></a>T2</h2><h2 id="T3-3"><a href="#T3-3" class="headerlink" title="T3"></a>T3</h2><h2 id="T4-3"><a href="#T4-3" class="headerlink" title="T4"></a>T4</h2>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Training</tag>
      </tags>
  </entry>
  <entry>
    <title>图论</title>
    <url>/34778.html</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><ul>
<li>度（Degree）：一个顶点上的度是指与该顶点相关联的边的条数，顶点$v$的度记作$d(v)$。</li>
<li>入度（In-degree）和出度（Out-degree）：对于有向图来说，一个顶点的度可细分为入度和出度。顶点的入度是指与其关联的各边之中，以其为终点的边数；出度则是相对的概念，指以该顶点为起点的边数。</li>
<li>自环（Loop）：若一条边的两个顶点为同一个顶点，则此边称之为自环。</li>
<li>路径（Path）：在图上随便走，走出来的就是路径。</li>
<li>环：起点&#x3D;终点的路径。</li>
<li>简单路径：每个点至多走一次的路径（点不能重复，边可以）。</li>
<li>简单环：去掉起点终点后变成简单路径（起点终点可以走两遍）。</li>
<li>完全图：所有点之间都有边。该图有$n$个顶点，$\dfrac{n\times(n-1)}{2}$条边。</li>
</ul>
<p>无向图总度数一定是偶数，因为从什么都没有开始每次加一条边，就有两个点的度数加一。</p>
<h1 id="特殊的图"><a href="#特殊的图" class="headerlink" title="特殊的图"></a>特殊的图</h1><ul>
<li><p>树：无环，无向，连通$n$个点的树$n-1$条边。<br>  无环，无向，不连通？——森林（每个连通块都是一个树）。<br>  无环，连通，有向？——有向图的树。</p>
<ul>
<li>外向树：边都指向叶子节点的树</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302181130889.webp"
                      alt="image.webp"
                ></li>
<li>内向树：边都指向根的树</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302181131257.webp"
                      alt="image.webp"
                ><br>  有环，无向，连通？——章鱼图&#x2F;基环树。</li>
</ul>
<p>  章鱼（$n$条边）变树：断掉环上的一条边。</p>
<p>  树变章鱼：任意连接一组边。</p>
<p>  扩展——<em>树形DP</em>。</p>
<p>  <strong>没有上司的舞会plus</strong> ：</p>
<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302181139263.webp"
                      alt="image.webp"
                ><br>  不可断环为树（数据范围）。</li>
</ul>
<p>  1.对环上的每一个点做一次 树形DP<br>  2.环形DP</p>
<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302181148138.webp"
                      alt="image.webp"
                ><br>  代表选到环上第几个点&#x2F;第i个点选没选&#x2F;第1个点选没选。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302181150117.webp"
                      alt="image.webp"
                ></li>
</ul>
</li>
</ul>
<p>如何找环呢？</p>
<p>从根节点开始 DFS，</p>
<p>直到从某一个点走到了它的祖先，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302191854777.webp"
                      alt="image.webp"
                ></p>
<p>如果 DFS 途中找到了这个点的祖先，</p>
<p>那么就反向跳不断地跳到他的父亲，</p>
<p>直到找到这个点，</p>
<p>那么经历的所有点便组成了一个环。</p>
<ul>
<li><p>仙人掌图</p>
<ul>
<li>边仙人掌图：把每一个点都换成一个环，边是用来连接不同的环的。</li>
<li>点仙人掌图：用点连接的仙人掌图。</li>
<li>一般也是 DP 题。</li>
<li>做法：树形DP 环形DP交替进行：树形——环形——树形。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302191918711.webp"
                      alt="image.webp"
                ></li>
</ul>
</li>
<li><p>有向无环图（DAG）：</p>
<ul>
<li>DP：状态看作点，转移看作边，其实 DP 就是 DAG。</li>
</ul>
</li>
<li><p>二分图（无向图）：（<em>染色问题</em>：一个点和它相邻的点的颜色一定不同的图）图分为左边和右边两个部分，所有边都在中间，左边右边内部都没有边。</p>
</li>
<li><p>方格图：</p>
<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302191930716.webp"
                      alt="image.webp"
                ></li>
<li>类似国际象棋的棋盘。</li>
</ul>
</li>
</ul>
<h2 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a>二分图判定</h2><p><strong>树是二分图</strong>。</p>
<p>只需要把深度为奇数的点放在左边，</p>
<p>深度为偶数的点放在右边（没有上司的舞会），</p>
<p>那么边一定全在中间。</p>
<p>什么图不是二分图呢？</p>
<p>有奇环的图就一定不是，没有奇环就是（环上的点数是奇数），</p>
<p>代码思路：随便找到一个点把它染成白色，再染相邻的点。</p>
<p>何时结束？</p>
<p>染完以后发现相邻有与自己颜色相同的点，那么就不是二分图。</p>
<p><strong>二分图不一定连通。</strong></p>
<h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>$f[i]  [j]$代表从$i$到$j$有边。</p>
<ul>
<li>好处：询问快，好写。</li>
<li>坏处：空间较大，没有办法处理重边。</li>
</ul>
<h2 id="边表（链式前向星）"><a href="#边表（链式前向星）" class="headerlink" title="边表（链式前向星）"></a>边表（链式前向星）</h2><ul>
<li>建立$n$个链表</li>
<li>见<a class="link"   href="https://blog.csdn.net/acdreamers/article/details/16902023" >深度理解链式前向星_ACdreamers的博客-CSDN博客_链式前向星<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302191940590.webp"
                      alt="image.webp"
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302191940046.webp"
                      alt="image.webp"
                ></li>
</ul>
<p><strong>既然会存图了，那么我们做一下章鱼图DP吧！</strong></p>
<p>对环上的每一个点做一个 树形DP</p>
<p>保证不要 DFS 到环上</p>
<p>做完 树形DP 后再对环做一个 环形DP 那么就做完了</p>
<h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><ul>
<li>单源最短路（一个点到其他所有点）<ul>
<li>三角不等式$(dist i,k &lt;&#x3D; dist i,j+dist j,k)$</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302192122110.webp"
                      alt="image.webp"
                ></li>
</ul>
</li>
<li>多源最短路（多个点到所有点的最短路——<del>多次单源最短路</del>）</li>
</ul>
<h2 id="Floyed——多源最短路-DP"><a href="#Floyed——多源最短路-DP" class="headerlink" title="Floyed——多源最短路(DP)"></a>Floyed——多源最短路(DP)</h2><p><strong>条件</strong>：边权大于等于0 。</p>
<p>$F i,j,k$代表从$j$走到$k$中间经过的每个点编号都小于$i$。</p>
<p>现在又加了一条边。</p>
<p>这条边可选可不选。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302192129552.webp"
                      alt="image.webp"
                ></p>
<p>但是$i$可以通过枚举解决。</p>
<p>进行一个<strong>状态压缩</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302192133270.webp"
                      alt="image.webp"
                ></p>
<p>注意要先枚举中间点。</p>
<h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><p>首先，$i$到$j$之间最短路一定不超过$n-1$条边，</p>
<p>每次循环枚举所有的边来进行松弛操作，后面的边会被前面的边更新。</p>
<p>即使最差的顺序，倒着遍历，导致每次只能更新一条边，那最多也不会超过 $n-1$ 次操作。</p>
<p>所以就得到了如下代码，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302252234022.webp"
                      alt="image.webp"
                ></p>
<p>是不是肥肠简单捏。</p>
<p>代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10000007</span></span><br><span class="line"><span class="type">int</span> n,dist[maxn],m,first[maxn];</span><br><span class="line"><span class="type">int</span> s[maxn],e[maxn],d[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;s[i],&amp;e[i],&amp;d[i]);<span class="comment">//起点，终点，长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//起点距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//最多n-1条边,最多松弛n-1次，因为如果倒着来的话，所有点的dist都未知，每次只能更新一个点，因此每轮会至少松弛一个点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)<span class="comment">//枚举边</span></span><br><span class="line">        &#123;</span><br><span class="line">            dist[e[j]]=<span class="built_in">min</span>(dist[e[j]],dist[s[j]]+d[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是复杂度比 Dijkstra 高。</p>
<p>但是它能处理负边权和负环，因为它每一条边都会看$n-1$次，保证不会漏掉更优解。</p>
<p>如果进行 $n-1$ 次松弛后还能进行第 $n$ 次松弛，那么就有负环。</p>
<p>因为假如一张图所有的点的最短路都被求了出来，并且其中不存在负环，这时遍历每一条边进行松弛操作，我们会发现什么也不会发生。</p>
<p>若仅仅出现了负边权，其实也什么都不会发生。</p>
<p>举个例子：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307201352241.webp"
                      alt="graph (2).png"
                ></p>
<p>对于这样一张图，进入环以后会发现：每条边被松弛一遍后，每个点的 $dist$ 值都是固定的，无法被更新。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307201353906.webp"
                      alt="graph (3).png"
                ></p>
<p>而对于这样一张有负环的图，当遍历回原点这条边时，会发现它的$dist$变小了，那么在下一次的松弛操作中，就会有边受到这条边的影响而变小。</p>
<p>根据负环的定义：<strong>边权和为负数的环</strong>。我们可以知道，其实关键就是在于从进入环到回到起点的那一刻，起点的$dist$有没有被更新，而如果边权和为负数的话，那么该点一定会被更新，进而进入一种循环，环上的最短距离不断变小，不断绕圈圈，到最后变成负无穷。</p>
<p>导致了负环连出去的点最短路径都是负无穷。</p>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><blockquote>
<p>关于SPFA ，它死了。</p>
</blockquote>
<p>和 BFS 不一样的地方就是一个点可能被扔进队列多次，</p>
<p>实际上就是 Bellman-Ford 的队列优化，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302252245462.webp"
                      alt="image.webp"
                ></p>
<p>复杂度$O(nm)$近似$O(m)$</p>
<p>如果边权大于等于零，一定是用 Dijkstra$+$堆。</p>
<p>如果小于零那就是 SPFA 。</p>
<h3 id="双端队列优化"><a href="#双端队列优化" class="headerlink" title="双端队列优化"></a>双端队列优化</h3><p>在松弛操作的时候，假如这条边的终点没被标记，假如终点的dist值比队头要大，那就放在队尾，如果比队头小，那就加在队头。</p>
<p>代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=fir[now];i;i=ed[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=ed[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dist[v]&gt;dist[now]+ed[i].val)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v]=dist[now]+ed[i].val;</span><br><span class="line">                <span class="keyword">if</span>(!righ[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    righ[v]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!q.<span class="built_in">empty</span>()&amp;&amp;dist[q.<span class="built_in">front</span>()]&lt;dist[v]) q.<span class="built_in">push_back</span>(v);<span class="comment">//队列不空防止RE，小的就放在队头，大的就放在队尾</span></span><br><span class="line">                    <span class="keyword">else</span> q.<span class="built_in">push_front</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><blockquote>
<p>图上边权大于等于0 。</p>
</blockquote>
<p>复杂度 $O(n^2+m)$。</p>
<p>记$dist_i$代表从起点到$i$的最短距离。</p>
<p>$1$号点到自己距离为$0$。</p>
<p>其他点为无穷大。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303112229422.webp"
                      alt="image.webp"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303112230818.webp"
                      alt="image.webp"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302221108718.webp"
                      alt="image.webp"
                ></p>
<p>把一号点放到右边，</p>
<p>进行一个<strong>松弛操作，</strong></p>
<p>“用已知更新未知”。</p>
<p>用已知最短路的点更新未知最短路的点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302221113575.webp"
                      alt="image.webp"
                ></p>
<p>用<strong>dist最短的点</strong>去更新其他点，</p>
<p>更新过最短距离的点不会被再次更新</p>
<p>因为边权大于等于$0$，</p>
<p>假如$j$走到$i$，</p>
<p>并且$dist[i]$ &lt; $dist[j]$，</p>
<p>$j$不可能走出比$dist[i]$ 还短的路，</p>
<p>因此$dist[i]$ 不会被更新。</p>
<h3 id="Dijkstra-Heap优化"><a href="#Dijkstra-Heap优化" class="headerlink" title="Dijkstra+Heap优化"></a>Dijkstra+Heap优化</h3><p>1.询问最小值。</p>
<p>2.删除最小值。</p>
<p>3.修改某些值。</p>
<p>大根堆：仿函数 <code>greater&lt;int&gt;</code></p>
<p>用 <code>pair</code> 的话默认是按照 <code>first</code> 排序，其次按照 <code>second</code> 排序。</p>
<p>可以使用堆&#x2F;线段树。</p>
<p>代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="type">int</span> dist[maxn],first[maxn];</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">bool</span> righ[maxn];<span class="comment">//这个点有没有放到右边去</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">    <span class="type">int</span> p,d;<span class="comment">//原点到p的最短距离为d</span></span><br><span class="line">    <span class="built_in">point</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">point</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;p=a;d=b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)<span class="comment">//STL默认大根堆，上面是大的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.d&gt;b.d;<span class="comment">//小根堆</span></span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;point&gt; heap;</span><br><span class="line"><span class="comment">//松弛操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> e,next;</span><br><span class="line">    <span class="type">int</span> d;<span class="comment">//长度</span></span><br><span class="line">&#125;ed[maxn];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    ed[cnt].next=first[u];</span><br><span class="line">    ed[cnt].e=v;</span><br><span class="line">    ed[cnt].d=w;</span><br><span class="line">    first[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));<span class="comment">//全部都赋值为最大值</span></span><br><span class="line">    dist[s]=<span class="number">0</span>;<span class="comment">//s到s</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        heap.<span class="built_in">push</span>(<span class="built_in">point</span>(i,dist[i]));<span class="comment">//可以无变量名</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(righ[heap.<span class="built_in">top</span>().p])<span class="comment">//有些点被拿到了右边但是左边没有删除</span></span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">        point now=heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> p=now.p;</span><br><span class="line">        <span class="comment">// int d=now.d;//未加堆优化版，找到目前dist最小的点</span></span><br><span class="line">        <span class="comment">// int p=-1;//代表还没选任何点</span></span><br><span class="line">        <span class="comment">// for(int j=1;j&lt;=n;j++)//循环后就找到了在左边最短路最小的点</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     if(!righ[j]&amp;&amp;(p==-1||dist[p]&gt;dist[j]))//righ[]代表有没有放到右边去</span></span><br><span class="line">        <span class="comment">//         p=j;</span></span><br><span class="line">        righ[p]=<span class="number">1</span>;<span class="comment">//放到右边，枚举出边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=first[p];j; j=ed[j].next)<span class="comment">//ed[j].e即为p的下一个点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> e=ed[j].e;</span><br><span class="line">            <span class="type">int</span> d=dist[p]+ed[j].d;</span><br><span class="line">            <span class="keyword">if</span>(dist[e]&gt;d)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[e]=d;</span><br><span class="line">                heap.<span class="built_in">push</span>(<span class="built_in">point</span>(e,d));<span class="comment">//改不了那就丢一个新元素进去</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// dist[ed[j].e]= min(dist[ed[j].e],dist[p]+ed[j].d);//或者这样</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="built_in">add_edge</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[i]==<span class="number">1061109567</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">2147483647</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于 Dijkstra 采用的是贪心策略，每个点只被加入堆中一次，这样的话一旦出现负环，那么明明可以绕很多圈让路径长度变为负无穷，但是 Dijkstra 只会跑一遍，导致贪心最优得出答案错误。</p>
<p>负边权也是同理，假如当前最小的$dist$值的点并没有连接负边权的点，那么 Dijkstra 就不会考虑不在考虑范围之内的负边，但往往这种时候选更大的$dist$点来获取该负边会更优。</p>
<p>例如该图，求 A 到 B 的最短路。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307201200333.webp"
                      alt="image.png"
                ></p>
<p>最小距离为2，但是 Djkstra 会认为是4。</p>
<p>堆的做法（优先队列）：</p>
<p>$$(n+m)  \times  log(n+m)$$</p>
<p>手写堆：$$(n+m)\times log_n$$<em>(斐波那契堆会更快)</em></p>
<h2 id="Johnson"><a href="#Johnson" class="headerlink" title="Johnson"></a>Johnson</h2><blockquote>
<p>一种多源最短路算法</p>
</blockquote>
<p>新建一个虚拟节点零号点，把它向其它所有点连接一条边权为 0 的边，</p>
<p>然后用 Bellman-Ford 求出 0 号点到其它所有点的最短路，记为 $h_i$。</p>
<p>设存在一条从 $u$ 到 $v$ 权值为 $w$ 的边，把它的权值设置为 $w+h_u-h_v$，这样以每个点为起点，跑 $n$ 遍 Dijkstra 就可以求出任意两点间的最短路了。</p>
<p>如果不这样处理，将会导致负边权。</p>
<p>在新图上跑 Dijkstra 后，对于 $u\to{v}$ 的路径，结果是原来的最短路 $+,h_s-h_t$，所以最后还要再 $-h_s+h_t$ 才能得到正确最短路。</p>
<p>原图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309022153246.webp"
                      alt="graph.png"
                ></p>
<p>新图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309022154468.webp"
                      alt="graph (1).png"
                ></p>
<p>一开始的预处理，到超级源点的最短距离要么就是零，要么就是负数，所以不需要初始数组为极大值。</p>
<p>但是如果是SPFA的话，需要判断是否有更新过，不然不会入队，所以还是要标记初始为极大值。</p>
<p>代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">6e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, edcnt;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> s[N],t[N],d[N];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, val, nxt;</span><br><span class="line">&#125;e[(M &lt;&lt; <span class="number">1</span>) + N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id,len;</span><br><span class="line">    <span class="built_in">point</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">point</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">id</span>(a),<span class="built_in">len</span>(b)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> point &amp;x)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> len &gt; x.len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].nxt = fir[u];</span><br><span class="line">    e[edcnt].to = v;</span><br><span class="line">    e[edcnt].val = w;</span><br><span class="line">    fir[u] = edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;point&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">point</span>(s,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        point now = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[now.id]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[now.id] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = fir[now.id]; i; i = e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            <span class="type">int</span> d = dist[now.id] + e[i].val;</span><br><span class="line">            <span class="keyword">if</span>(d &lt; dist[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = d;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(<span class="built_in">point</span>(v,dist[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;s[i],&amp;t[i],&amp;d[i]);</span><br><span class="line">    <span class="type">int</span> tot = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s[++tot] = <span class="number">0</span>;</span><br><span class="line">        t[tot] = i;</span><br><span class="line">        d[tot] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">// 多加了一个源点，所以最多松弛 n 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n + m; ++j) <span class="comment">// n+m条边</span></span><br><span class="line">            h[t[j]] = <span class="built_in">min</span>(h[t[j]], h[s[j]] + d[j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n + m; ++j)</span><br><span class="line">        <span class="keyword">if</span>(h[t[j]] &gt; h[s[j]] + d[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">Add</span>(s[i], t[i], d[i] + h[s[i]] - h[t[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Dijkstra</span>(i);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            ans += j * (dist[j] == <span class="number">0x3f3f3f3f</span> ? <span class="number">1e9</span> : dist[j] - h[i] + h[j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">6e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, edcnt;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, val, nxt, from;</span><br><span class="line">&#125;e[(M &lt;&lt; <span class="number">1</span>) + N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id,len;</span><br><span class="line">    <span class="built_in">point</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">point</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">id</span>(a),<span class="built_in">len</span>(b)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> point &amp;x)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> len &gt; x.len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].nxt = fir[u];</span><br><span class="line">    e[edcnt].from = u;</span><br><span class="line">    e[edcnt].to = v;</span><br><span class="line">    e[edcnt].val = w;</span><br><span class="line">    fir[u] = edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> inque[N];</span><br><span class="line">    <span class="type">int</span> times[N];</span><br><span class="line">    <span class="built_in">memset</span>(times, <span class="number">0</span>, <span class="built_in">sizeof</span>(times));</span><br><span class="line">    <span class="built_in">memset</span>(inque, <span class="number">0</span>, <span class="built_in">sizeof</span>(inque));</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    times[s] = <span class="number">1</span>;</span><br><span class="line">    h[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        inque[now] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = fir[now]; i; i = e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            <span class="type">int</span> d = h[now] + e[i].val;</span><br><span class="line">            <span class="keyword">if</span>(d &lt; h[v])</span><br><span class="line">            &#123;</span><br><span class="line">                h[v] = d;</span><br><span class="line">                <span class="keyword">if</span>(!inque[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    inque[v] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    times[v]++;</span><br><span class="line">                    <span class="keyword">if</span>(times[v] &gt; n)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;point&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">point</span>(s,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        point now = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[now.id]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[now.id] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = fir[now.id]; i; i = e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            <span class="type">int</span> d = dist[now.id] + e[i].val;</span><br><span class="line">            <span class="keyword">if</span>(d &lt; dist[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = d;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(<span class="built_in">point</span>(v,dist[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">Add</span>(u, v, w);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">Add</span>(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">SPFA</span>(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        e[i].val += h[e[i].from] - h[e[i].to];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Dijkstra</span>(i);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            ans += j * (dist[j] == <span class="number">0x3f3f3f3f</span> ? <span class="number">1e9</span> : dist[j] - h[i] + h[j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="负环判定"><a href="#负环判定" class="headerlink" title="负环判定"></a>负环判定</h2><p>整个环权值的和为负</p>
<ol>
<li>做 SPFA 时候可以多记一个$cnt_i$<br> 代表到这个点的最短路经历了几条边<br> 如果这个数量超过了$n-1$，说明有负环</li>
<li>如果一个点入队超过$n-1$次，也说明有负环<br> 在SPFA中入队一次说明在Bellman-Ford中被更新一次，入队次数$\le$更新次数。</li>
</ol>
<h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302261942380.webp"
                      alt="image.webp"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302262023262.webp"
                      alt="image.webp"
                ></p>
<p>对应最短路中的 $d &lt;&#x3D; dist [i]+w[i]$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302262026480.webp"
                      alt="image.webp"
                ></p>
<p>最大值对应最短路</p>
<p>解释：</p>
<p>对于每一个 $a_i$ ，都有一个$a_i$-$a_j$$\leqslant$$k_i$ </p>
<p>也就是$a_i$$\leqslant$$a_j$+$k_i$ </p>
<p>这不就是最短路中的松弛操作嘛！</p>
<p>要使这些条件都满足</p>
<p>式子上下相加</p>
<p>那么一定是对每一个不等式的右面之和取一个$min$</p>
<p>也就是求一个<del>最小值</del>最短路</p>
<hr>
<p>那么同理</p>
<p>最小值对应最长路</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202302262039228.webp"
                      alt="image.webp"
                ></p>
<h1 id="树上差分"><a href="#树上差分" class="headerlink" title="树上差分"></a>树上差分</h1><blockquote>
<p>例子：对于树上的一些路径进行访问，问一条路径上的点被访问的次数。</p>
</blockquote>
<p>每次有一个 $s,t$ 的询问，可以找到它们的公共祖先 lca，然后进行如下操作：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">d[s]++;</span><br><span class="line">d[t]++;</span><br><span class="line">d[lca]--;</span><br><span class="line">d[fa[lca]]--;</span><br></pre></td></tr></table></figure></div>

<p>这样访问值的时候，访问以该节点为根的子树和即可。</p>
<p>而假如对边差分，可以把边权对应到较深的点上，然后就可以得到一下操作：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">d[s]++;</span><br><span class="line">d[t]++;</span><br><span class="line">d[lca] -= <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P3128" >P3128<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, ans;</span><br><span class="line"><span class="type">int</span> cf[N];</span><br><span class="line"><span class="type">int</span> dep[N];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">int</span> st[N][<span class="number">25</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt, to;</span><br><span class="line">&#125;e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].nxt = fir[u];</span><br><span class="line">    fir[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = fir[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        st[v][<span class="number">0</span>] = u;</span><br><span class="line">        dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">23</span>; j++)</span><br><span class="line">            st[v][j] = st[st[v][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">23</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(dep[st[u][i]] &gt;= dep[v])</span><br><span class="line">            u = st[u][i];</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">23</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(st[u][i] != st[v][i])</span><br><span class="line">            u = st[u][i], v = st[v][i];</span><br><span class="line">    <span class="keyword">return</span> st[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = cf[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = fir[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == st[u][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        sum += <span class="built_in">dfs2</span>(v);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cf[x]++;</span><br><span class="line">    cf[y]++;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">lca</span>(x, y);</span><br><span class="line">    cf[l]--;</span><br><span class="line">    cf[st[l][<span class="number">0</span>]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">update</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="树上序列"><a href="#树上序列" class="headerlink" title="树上序列"></a>树上序列</h1><p>树的存储方式： 当作无向图</p>
<p>概念略</p>
<p>自己也是自己的祖先</p>
<h2 id="最近公共祖先问题（LCA）"><a href="#最近公共祖先问题（LCA）" class="headerlink" title="最近公共祖先问题（LCA）"></a>最近公共祖先问题（LCA）</h2><p>公共祖先：两个点祖先的交集</p>
<p>最近：最靠下的公共祖先</p>
<p>最近公共祖先有什么用呢？</p>
<p>判断两个点怎么走</p>
<p>那么怎么求呢？</p>
<p>暴力？</p>
<p>若假定 $p1 p2$ 深度相同</p>
<p>可以让左右两点同时向上跳</p>
<p>某时刻两点重合</p>
<p>意味着遇到了公共祖先</p>
<ol>
<li>调整深度</li>
<li>一起跳</li>
</ol>
<p>优化：</p>
<p>慢是因为一步一步跳的</p>
<p>所以我们可以考虑每次可以每次多跳几步</p>
<h3 id="倍增求LCA"><a href="#倍增求LCA" class="headerlink" title="倍增求LCA"></a>倍增求LCA</h3><p>$f [i]  [j]$ 表示从 $i$ 向上跳 $2^j$ 步会跳到哪个点 </p>
<p>需要预处理</p>
<p>$f[i]   [0]&#x3D;fa[i]$</p>
<p>$2^j$&#x3D;$2^{j-1}$ + $2^{j-1}$</p>
<p>$f[i]   [j]&#x3D;f[   [i]   [j-1]   ]   [j-1]$</p>
<p>向上跳 $2^{j-1}$ 步再跳一遍</p>
<p>那么求出来可以有什么用呢？</p>
<p>求 $p1$ 和 $p2$ 之间的边权最小值</p>
<p>最小值？</p>
<p>不支持修改操作。</p>
<h3 id="DFS-序求-LCA"><a href="#DFS-序求-LCA" class="headerlink" title="DFS 序求 LCA"></a>DFS 序求 LCA</h3><p>对于 $u$ 和 $v$ 的 $lca$，在 dfs 序上 $lca$ 一定在 $u$ 和 $v$ 之间，于是我们可以维护 dfs 序区间最小的点的父节点即 $lca$。</p>
<p>注意区间长度本来为 $dfsn_{y}-dfsn_x+1$，但是由于查询的是 $[dfsn_x+1,dfsn_y]$，所以区间长度为 $dfsn_y-dfsn_x$。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> idx, n, m, root, cnt;</span><br><span class="line"><span class="type">int</span> dfsn[N], st[<span class="number">25</span>][N], fir[N];</span><br><span class="line"><span class="type">int</span> Log2[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">&#125;e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Log2[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        Log2[i] = Log2[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfsn[x] &lt; dfsn[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].nxt = fir[u];</span><br><span class="line">    fir[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfsn[u] = ++idx;</span><br><span class="line">    st[<span class="number">0</span>][idx] = fa; <span class="comment">// 以 idx 为起点长度为 (1 &lt;&lt; i) 的区间内 dfsn 最小的点的父亲</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = fir[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> (dfsn[x] &gt; dfsn[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="type">int</span> d = Log2[dfsn[y] - dfsn[x]]; <span class="comment">// +1 -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(st[d][dfsn[x] + <span class="number">1</span>], st[d][dfsn[y] - (<span class="number">1</span> &lt;&lt; d) + <span class="number">1</span>]); <span class="comment">// [dfsn_u + 1, dfsn_v]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, u, v; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Log2[n]; i++) <span class="comment">// Log2[i] 下取整</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; j++)</span><br><span class="line">            st[i][j] = <span class="built_in">get</span>(st[i - <span class="number">1</span>][j], st[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lca</span>(u, v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="树的序列化-并不是完整的线段树"><a href="#树的序列化-并不是完整的线段树" class="headerlink" title="树的序列化(并不是完整的线段树)"></a>树的序列化(并不是完整的线段树)</h2><ul>
<li>树状数组</li>
<li>线段树</li>
</ul>
<h3 id="1-DFS序"><a href="#1-DFS序" class="headerlink" title="1.DFS序"></a>1.DFS序</h3><ul>
<li>作用：树上子树查询修改<ul>
<li><ol>
<li>以$P$为根子树权值和</li>
</ol>
</li>
<li><ol start="2">
<li>把以$P$为根的子树全部加上某一个值</li>
</ol>
</li>
<li><ol start="3">
<li>把根换成$P$</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303111506405.webp"
                      alt="image.webp"
                ></p>
<p>任何一段子树都对应一段序列上的区间</p>
<ol>
<li>递归求出</li>
<li>BFS 求出</li>
</ol>
<p>代码见 $VScode$</p>
<p>序列是写好了，那么怎样实现它的作用呢？</p>
<p>$1.$ $2.$都好说</p>
<p>但是3.怎么实现呢</p>
<p>会改变 dfs 序</p>
<p>解决方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303112037146.webp"
                      alt="image.webp"
                ></p>
<p>只换一次</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303112038613.webp"
                      alt="image.webp"
                ></p>
<p>哪些点的子树会发生变化？</p>
<p>只有$1$号点到$p$号点路径上的点的子树才会发生变化</p>
<p>不会影响其它点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303112051568.webp"
                      alt="image.webp"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303112055185.webp"
                      alt="image.webp"
                ></p>
<p>把一段区间的询问改成两段区间的询问就可以了</p>
<hr>
<h3 id="2-括号序列"><a href="#2-括号序列" class="headerlink" title="2.括号序列"></a>2.括号序列</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303112058427.webp"
                      alt="image.webp"
                ></p>
<p>它能解决什么样的问题呢？</p>
<p><strong>链上操作</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303112104130.webp"
                      alt="image.webp"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303112105384.webp"
                      alt="image.webp"
                ></p>
<p>用 LCA 把这段链分成两部分</p>
<p>这样就可以分别进行求解（ <del>可能LCA被算了两次，减去一个就可以了</del> ）</p>
<p>$5 \to 1$</p>
<p>$1 \to 9$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303112108436.webp"
                      alt="image.webp"
                ></p>
<p>链求和转换为两端区间求和</p>
<p>只能用来求链的和</p>
<p>不能求最大值最小值</p>
<p>可以用倍增来做</p>
<h1 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h1><ul>
<li>概念：$n$个点中找$n-1$条边，使它组成一颗树</li>
</ul>
<h2 id="1-Prim"><a href="#1-Prim" class="headerlink" title="1.Prim"></a>1.Prim</h2><blockquote>
<p>每次选择与生成树这个连通块的最小的一条连接的边，加到这个连通块内。</p>
</blockquote>
<p>维护两个集合：</p>
<p>左边的集合：还没有加到生成树中的点</p>
<p>右边的集合：加到生成树的点</p>
<p>$dist$ 数组：点i经过一条边到<strong>生成树</strong>上的最短距离</p>
<p>走不到就是无穷大（初始化）</p>
<p>一开始生成树上是没有点的</p>
<p>所以点 $1$ 的 $dist$ 就是 $0$</p>
<p>然后用一号点更新其他点</p>
<p><strong>每轮选左边 $dist$ 值最小的点加到右边然后用它来更新其它点</strong></p>
<p>把所有点都放到右边以后就做完了</p>
<p>这就是<strong>PRIM</strong>算法（<del>Djkstra的孪生兄弟</del>）</p>
<p>它与 Dijkstra 最大的不同就是 Dijkstra 维护的是到起点的距离，而 Prim 维护的是到已经生成的最小生成树的连通块的距离。</p>
<p>堆优化：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303112233270.webp"
                      alt="image.webp"
                ></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(<span class="built_in">point</span>(s, dist[s]));</span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[t.p]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[t.p] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = fir[t.p]; i; i = ed[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = ed[i].e;</span><br><span class="line">            <span class="keyword">if</span> (ed[i].d &lt; dist[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = ed[i].d;</span><br><span class="line">                heap.<span class="built_in">push</span>(<span class="built_in">point</span>(v, dist[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>$n^2$ 代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) dist[i] = graph[<span class="number">1</span>][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="type">int</span> minc = INF, p;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[i] == <span class="number">0</span> &amp;&amp; dist[i] &lt; minc)</span><br><span class="line">                &#123;</span><br><span class="line">                    minc = dist[i];</span><br><span class="line">                    p = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minc == INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            vis[p] = <span class="number">1</span>;</span><br><span class="line">            res += dist[p];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[i] == <span class="number">0</span> &amp;&amp; dist[i] &gt; graph[p][i])</span><br><span class="line">                    dist[i] = graph[p][i];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>复杂度：$O((N+M)logN)$ 适合稠密图，也就是点少于边。</p>
<h2 id="2-Kruskal"><a href="#2-Kruskal" class="headerlink" title="2.Kruskal"></a>2.Kruskal</h2><h3 id="前置：并查集"><a href="#前置：并查集" class="headerlink" title="前置：并查集"></a>前置：并查集</h3><p>支持两种操作：</p>
<ul>
<li>查询两元素是否在同一集合中</li>
<li>合并两集合</li>
</ul>
<p>代码也是十分的好写啊</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303121559302.webp"
                      alt="image.webp"
                ></p>
<p>假如是条链呢？</p>
<p>那这样就太慢了</p>
<p>我们可以进行一些优化</p>
<h4 id="启发式合并"><a href="#启发式合并" class="headerlink" title="启发式合并"></a>启发式合并</h4><p>之前不是谁都可以做父亲吗</p>
<p>现在谁的子树大，谁就是父亲</p>
<h4 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h4><p>谁的深度大，谁就是父亲</p>
<h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>不改变合并过程</p>
<p>但在<code>get_root</code>找根的时候</p>
<p>把所有点的父亲都变成根</p>
<p>因为我们不关心树上的父子关系，我们只关心根是谁</p>
<p><strong>贪心+并查集</strong></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>将边从小到大排序，从小到大每次挑一个加入到最小生成树中，若形成环则跳过，判断环可以用并查集实现。</p>
<p>当在边数远大于点数的稠密图中，Kruskal 会重复判断一些边导致超时，这时 Prim 更优。</p>
<p>所以 Kruskal 适合边数较少的稀疏图。</p>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p><a class="link"   href="https://www.acwing.com/problem/content/1142/" >AcWing1140<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], w[t][j]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">prim</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/1143/" >AcWing1141<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, M = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求原图的最小生成“森林”</span></span><br><span class="line"><span class="comment">// 总边权减去生成的边权即可</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        e[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e + <span class="number">1</span>, e + <span class="number">1</span> + m);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b), w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a != b) p[a] = b;</span><br><span class="line">        <span class="keyword">else</span> res += w; <span class="comment">// 在找最小生成树的时候把不需要的边给存起来就好了</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/1144/" >AcWing1142<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>, M = <span class="number">11111</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        cin &gt;&gt; e[i].a &gt;&gt; e[i].b &gt;&gt; e[i].w;</span><br><span class="line">    <span class="built_in">sort</span>(e, e + m);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b);</span><br><span class="line">        <span class="type">int</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n - <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/1145/" >AcWing1143<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2200</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于缩点，变完以后求一个最小生成树</span></span><br><span class="line"><span class="comment">// 其实直接跑最小生成树即可</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> g, u, v, w;</span><br><span class="line">        cin &gt;&gt; g &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">if</span>(g == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">find</span>(u), b = <span class="built_in">find</span>(v);</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> e[++cnt] = &#123;u, v, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e + <span class="number">1</span>, e + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b);</span><br><span class="line">        <span class="keyword">if</span>(a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += e[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/1146/" >AcWing1144<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">2e6</span> + <span class="number">7</span>; <span class="comment">// 严格来说最多有 2mn - m - n 条边</span></span><br><span class="line"><span class="comment">// 由于边权只有两种，所以直接按照顺序建边即可，无需排序</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ids[N][N];</span><br><span class="line"><span class="type">int</span> p[N * N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：如果边权可正可负，所以不一定是最小生成树的问题</span></span><br><span class="line"><span class="comment">// 而这个问题边肯定越少越好</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_edges</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dw[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> z = <span class="number">0</span>; z &lt; <span class="number">2</span>; z++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u++)</span><br><span class="line">                    <span class="keyword">if</span>((u &amp; <span class="number">1</span>) == z)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> x = i + dx[u], y = j + dy[u];</span><br><span class="line">                        <span class="type">int</span> w = dw[u];</span><br><span class="line">                        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt; n || y &lt; <span class="number">0</span> || y &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="type">int</span> a = ids[i][j], b = ids[x][y];</span><br><span class="line">                        <span class="keyword">if</span>(a &lt; b) e[++cnt] = &#123;a, b, w&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, t = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++, t++)</span><br><span class="line">            ids[i][j] = t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m; i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = ids[x1][y1], b = ids[x2][y2];</span><br><span class="line">        p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_edges</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b), w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul>
<li>任意一颗最小生成树一定可以包含无向图中最小的边。</li>
<li>给定一张无向图，若从中选出小于 $n - 1$ 条边使其构成一个生成森林，然后再从剩下的边中选取 $m - k$ 条边使得它成为一颗生成树，并且选出的权值之和最小。那么该生成树一定可以包含这 $m - k$ 条边中连接生成森林的两个不连通节点的权值最小的边（相当于缩点后求最小生成树）。</li>
</ul>
<p><a class="link"   href="https://www.acwing.com/problem/content/1148/" >AcWing1146<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>虚拟源点的思想。</p>
<p>让这 $n + 1$ 个点连通，求个最小生成树即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n + <span class="number">1</span>; j ++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) dist[j] = <span class="built_in">min</span>(dist[j], w[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[<span class="number">0</span>][i]);</span><br><span class="line">        w[i][<span class="number">0</span>] = w[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">prim</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/1147/" >AcWing1145<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>可以先二分后遍历。</p>
<p>也可以用并查集维护连通块的数量。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = N * N / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找一个最小的 d 值，使得将所有 &gt; d 的边删完后连通块的个数 &lt;= k</span></span><br><span class="line"><span class="comment">// 用并查集维护连通块数量即可，当它等于 k 时，此时的边权就是答案</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, m;</span><br><span class="line">PII q[M];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">double</span> w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dist</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx = q[a].x - q[b].x;</span><br><span class="line">    <span class="type">int</span> dy = q[a].y - q[b].y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; q[i].x &gt;&gt; q[i].y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            e[++m] = &#123;i, j, <span class="built_in">dist</span>(i, j)&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(e + <span class="number">1</span>, e + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="type">int</span> cnt = n;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k) <span class="keyword">break</span>; <span class="comment">// 防止了一开始 k = cnt 的情况</span></span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b);</span><br><span class="line">        <span class="type">double</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            cnt--;</span><br><span class="line">            res = w; <span class="comment">// 防止了 k = 0 的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/348/" >AcWing346<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>每次合并连通块的时候，要把这两个连通块变成一张完全图，这样合并到最后得到的也是完全图。</p>
<p>加边，最小只能加原来的边权加一，因为要保证最小生成树不变且唯一。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = (N * N) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[N], siz[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> edge &amp;t) <span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;e[i].a, &amp;e[i].b, &amp;e[i].w);</span><br><span class="line">        <span class="built_in">sort</span>(e + <span class="number">1</span>, e + n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i, siz[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b);</span><br><span class="line">            <span class="type">int</span> w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(a != b)</span><br><span class="line">            &#123;</span><br><span class="line">                res += (siz[a] * siz[b] - <span class="number">1</span>) * (w + <span class="number">1</span>);</span><br><span class="line">                siz[b] += siz[a];</span><br><span class="line">                p[a] = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/1150/" >AcWing1148<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>严格次小生成树。</p>
<ol>
<li>先求最小生成树，然后依次枚举删去最小生成树中的边再跑最小生成树。</li>
</ol>
<p>这样做是 $O(mlogm + nm)$ </p>
<p>这样做得到的只是次小生成树，不保证严格次小。</p>
<ol start="2">
<li>先求最小生成树，然后依次枚举非树边，然后将该边加入树中，同时从树中这个环上任意去掉一条边，使得最终的图是一颗树，那么一定能求出次小生成树。</li>
</ol>
<p>要保证求得是仅次于最小的最小，所以删去的边要尽可能大，其实就是求树上任意两点间的一个极值，这个可以用倍增来做，也可以暴力预处理。</p>
<p>复杂度： $n^{2}+m$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310051540963.webp"
                      alt="image.png"
                ></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"><span class="type">int</span> dist2[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ed[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt, to, val;</span><br><span class="line">&#125;e[N &lt;&lt; <span class="number">1</span>]; <span class="comment">// 建树即可</span></span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].nxt = fir[u];</span><br><span class="line">    e[cnt].val = w;</span><br><span class="line">    fir[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> maxd, <span class="type">int</span> maxd2, <span class="type">int</span> d[], <span class="type">int</span> d2[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[u] = maxd, d2[u] = maxd2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = fir[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> td1 = maxd, td2 = maxd2; <span class="comment">// 保证每次循环 td1 和 td2 初值一样</span></span><br><span class="line">        <span class="keyword">if</span>(e[i].val &gt; td1)</span><br><span class="line">        &#123;</span><br><span class="line">            td2 = td1;</span><br><span class="line">            td1 = e[i].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e[i].val &lt; maxd &amp;&amp; e[i].val &gt; maxd2) td2 = e[i].val;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u, td1, td2, d, d2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        ed[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ed + <span class="number">1</span>, ed + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = ed[i].a, b = ed[i].b;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b), w = ed[i].w;</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)</span><br><span class="line">        &#123;</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">            sum += w;</span><br><span class="line">            <span class="built_in">add</span>(a, b, w);</span><br><span class="line">            <span class="built_in">add</span>(b, a, w);</span><br><span class="line">            ed[i].f = <span class="literal">true</span>; <span class="comment">// 是树边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">dfs</span>(i, <span class="number">-1</span>, <span class="number">-1e9</span>, <span class="number">-1e9</span>, dist[i], dist2[i]);</span><br><span class="line">    <span class="comment">// 当前点编号，父节点编号，当前边权最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span>(!ed[i].f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = ed[i].a, b = ed[i].b, w = ed[i].w;</span><br><span class="line">            <span class="keyword">if</span>(w &gt; dist[a][b])</span><br><span class="line">                res = <span class="built_in">min</span>(res, sum + w - dist[a][b]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w &gt; dist2[a][b]) res = <span class="built_in">min</span>(res, sum + w - dist2[a][b]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="3-次小生成树"><a href="#3-次小生成树" class="headerlink" title="3.次小生成树"></a>3.次小生成树</h2><p>我们发现次小生成树肯定是通过最小生成树来求的（替换一条边）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303121644918.webp"
                      alt="image.webp"
                ></p>
<p>路径上找到最大的 V1 进行替换</p>
<p>换为$V_2$</p>
<p>怎么找最大的边呢？</p>
<p>进行一个倍增 LCA</p>
<p>在 LCA 的过程中找到最大值</p>
<p>1.先求最小生成树</p>
<p>2.用非树上的边替换树上链的最大值</p>
<p>3.求最大值可以用 LCA 来做</p>
<p>我不倍增求了</p>
<p>我暴力！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303121650480.webp"
                      alt="image.webp"
                ></p>
<p>$O(nm)$</p>
<p>因为 Kruscal 求的时候对每条边排了个序</p>
<p>所以可以用排的序对非树边从小到大去枚举</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303121653816.webp"
                      alt="image.webp"
                ></p>
<p>以这张图为例</p>
<p>先一点点求一个$V_1$，也就是加粗的边</p>
<p>然后$V_2$仅次大于$V_1$</p>
<p>我们发现在$V_2$的链上有两条加粗的边，也就是求$V_1$的时候访问过了</p>
<p>假如用$V_2$替换掉这两条加粗边中的一条，那么会不会是次小生成树</p>
<p>设加粗边中的一条长度为$a$</p>
<p>那么分别替换后树的变化</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303121656465.webp"
                      alt="image.webp"
                ></p>
<p>很明显，在$V_1$的时候就替换$a$比在$V_2$的时候再替换$a$还要小</p>
<p>而在$V_1$的时候并没有替换$a$</p>
<p>所以$V_2$替换了$a$一定不会是次小的</p>
<p>因为拿$V_1$替换$a$是更优的</p>
<p>换而言之</p>
<p>一条边之前已经被更小的边判断过了</p>
<p>拿更大的边去判断已经判断过的边是没有意义的</p>
<p>也就是把非树边从小到大枚举</p>
<p>整个树上的边最多只需要被判断一次就够了</p>
<p>所以复杂度就变为了$O(m+n)$</p>
<p>那怎么保证只判断一次呢？</p>
<p><del>遍历一次就把它删掉</del></p>
<p>当然是用并查集咯</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303121703782.webp"
                      alt="image.webp"
                ></p>
<p>假设这是第一次遍历</p>
<p>那么就把这条路径上的点并为一个集合</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303121704207.webp"
                      alt="image.webp"
                ></p>
<p>第二次遍历</p>
<p>因为右下角的那个点更深，因此向上跳</p>
<p>发现跳到了之前已经跳到过的点</p>
<p>那么就直接跳到它的祖先</p>
<p>也就是向上跳一步</p>
<p>就把它加到它父亲的并查集里</p>
<p>再跳到它父亲的祖先位置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303121706757.webp"
                      alt="image.webp"
                ></p>
<p>换句话说</p>
<p>假如某条边已经被考虑过了</p>
<p>那么就把它连接的两个点加到同一个并查集中</p>
<p>这样就可以保证每个点只访问了一次</p>
<p>并查集$O(1)$查询</p>
<h1 id="欧拉路"><a href="#欧拉路" class="headerlink" title="欧拉路"></a>欧拉路</h1><h2 id="欧拉路径"><a href="#欧拉路径" class="headerlink" title="欧拉路径"></a>欧拉路径</h2><p>一条路径经过所有的边且只经过一次。</p>
<p>若起点和终点相同，则称之为<strong>欧拉回路</strong>。</p>
<p>无向图存在欧拉回路的条件：所有点的度数都为偶数。</p>
<p>无向图存在欧拉路径： 恰有两个点度数为奇数（起点和终点）。</p>
<p>有向图存在欧拉回路：所有点都满足 <strong>入度等于出度</strong>。</p>
<p>有向图存在欧拉路径：恰有一个点入度比出度多一（终点），另一个点出度比入度多一，其余点入度和出度相同。</p>
<h2 id="Hierholzer"><a href="#Hierholzer" class="headerlink" title="Hierholzer"></a>Hierholzer</h2><p>从起点开始 DFS ，然后枚举它的出边，继续 DFS 。</p>
<p>走过的边都标记（删边），遇到走过的边就<code>continue</code>。</p>
<p>回溯的时候再压入栈内，因为如果一开始就压栈，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307191517951.webp"
                      alt="image.png"
                ></p>
<p>看这张图，$1\to{2}\to{3}$，</p>
<p>遍历到 $3$ 的时候，那么栈内现在就是 $1 2 3$。</p>
<p>然后再遍历 $3$ 的出边，万一选了 $3\to{1}$ 这条边，那么再把 1 加入栈中，发现没法走了，回溯，接着遍历剩下的边，这时我们发现答案是错的，因为 $3\to{1}$ 这条边出现的时机很尴尬，如果它现在就出现了，那么就没法遍历 $4$ 和 $5$ 了，而由于回溯操作，我们可以悔棋，来调整它出现的顺序使其合理。</p>
<p>所以我们可以回溯后再让它进栈，因为这样的话遍历到 $1$ 发现没法走的时候，$1$ 会被加入栈，而 $3$ 不会，因为它还有其它出边要遍历，这样就可以给 $1$ 这个终点预留一个“上一个点”的位置，直到从 $3\to{5}\to{4}\to{3}$ 的时候，$3$ 会被加入栈，这时 $3\to{1}$ 这条边出现的顺序就正确了，因为 $3$ 的所有出边都已经遍历完了，不会出现其它边要出现在它之前的情况，然后往前回溯也是同理。</p>
<p>再举个例子便于理解：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307191529974.webp"
                     
                ></p>
<p>对于这样一张图，</p>
<p>如果先递归后压栈，那么得到的欧拉路径为：</p>
<p>$${9}\to{6}\to{3}\to{2}\to{1}\to{4}\to{2}\to{5}\to{6}\to{7}\to{8}\to{5}\to{4}$$</p>
<p>如果先压栈后递归，得到的欧拉路径为：</p>
<p>$${9}\to{6}\to{3}\to{2}\to{1}\to{4}\to{2}\to{5}\to{4}\to{6}\to{7}\to{8}\to{5}$$</p>
<p>这里后半段应该是 ${5}\to{6}\to{7}\to{8}\to{5}\to{4}$，但是如果在$5$处往下递归的时候递归到 $4$ 直接压栈，就会导致后面 ${5}\to{6}\to{7}\to{8}$  这个环不能插在它前面。</p>
<p>对于有向图，最后压栈的是前几个被遍历的，因此答案是反的，想办法 <code>reverse</code> 一下就好了。</p>
<p><strong>代码：</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,st,cnt;</span><br><span class="line"><span class="type">int</span> d[<span class="number">1000</span>][<span class="number">1000</span>],ans[<span class="number">1000</span>],f[<span class="number">1000</span>];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[u][v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[u][v]--,d[v][u]--;<span class="comment">//删边</span></span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    S.<span class="built_in">push</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        d[a][b]++,d[b][a]++;</span><br><span class="line">        f[a]++,f[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(f[i]%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st=i;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;st&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// S.push(st);</span></span><br><span class="line">    <span class="built_in">dfs</span>(st);</span><br><span class="line">    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ans[++p]=S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans<span class="number">+1</span>,ans+p<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 9 12</span></span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// 1 4</span></span><br><span class="line"><span class="comment">// 2 4</span></span><br><span class="line"><span class="comment">// 2 5</span></span><br><span class="line"><span class="comment">// 4 5</span></span><br><span class="line"><span class="comment">// 2 3</span></span><br><span class="line"><span class="comment">// 5 6</span></span><br><span class="line"><span class="comment">// 3 6</span></span><br><span class="line"><span class="comment">// 6 7</span></span><br><span class="line"><span class="comment">// 7 8</span></span><br><span class="line"><span class="comment">// 8 5</span></span><br><span class="line"><span class="comment">// 6 9</span></span><br></pre></td></tr></table></figure></div>

<p>对于链式前向星，也可以这样写：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> edcnt = <span class="number">1</span>;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[x];i;i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        vis[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>还可以这样写</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ola</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[x];i;i=fir[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        fir[x]=e[i].nxt;</span><br><span class="line">        <span class="built_in">ola</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    S.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样就相当于直接在原图上进行修改了。</p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p><strong>BZOJ3724 Krolestwo：</strong></p>
<p><a href="">题解</a></p>
<p><a class="link"   href="https://www.acwing.com/problem/content/description/368/" >AcWing366<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>本题建立双向边的有向图，边数$\times{2}$，记得空间开两倍，然后易得每个点的入度都等于出度，那么就在这上面当成有向图的欧拉回路就可以了。</p>
<p><a class="link"   href="https://white.fallingsakura.top/451678749/" >题解<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="DAG拓扑排序"><a href="#DAG拓扑排序" class="headerlink" title="DAG拓扑排序"></a>DAG拓扑排序</h1><blockquote>
<p>有向无环图可以称作拓扑图</p>
</blockquote>
<p><strong>拓扑序列</strong>：所有的边都是从前指向后的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307181013336.webp"
                      alt="image.png"
                ></p>
<p>并不是所有图都有拓扑序，有环就不行。</p>
<ol>
<li>统计每个点的入度</li>
<li>将所有入度为 $0$ 的点入队</li>
<li>BFS（取出队头元素，遍历所有它的出边）</li>
</ol>
<p>假设 $t\to{j}$，</p>
<p>$d_j$ 代表 $j$ 的入度。</p>
<p>入度为 $0$ 说明没有任何一点在我前面。</p>
<p>所有入度为 $0$ 的点都可以当作起点。</p>
<p>所以第一步就是把所有入度为 $0$ 的点入队。</p>
<p>然后取出队头，枚举出边。</p>
<p>然后删掉这条边（$t\to{j}$）</p>
<p>就是 $d[j]-1$.</p>
<p>假如入度为 $0$ 就让它入队</p>
<p>如果有环</p>
<p>那么一定有一些点不会入队</p>
<p>如果一个图上并没有环</p>
<p>那么就可以把它拓扑掉</p>
<p>一个有向无环图一定有入度为$0$的点</p>
<p>反证法：</p>
<p>假如每个点的入度都不为$0$</p>
<p>那么一定可以沿着某个点无穷无尽的往上找</p>
<p>假如一共$n$个点</p>
<p>当找到第$n+1$的点时这个图就出现了环</p>
<p>所以有向无环图至少存在一个入度为零的点</p>
<p>把它作为突破口</p>
<p><em>挖墙脚</em></p>
<p>加入队列的顺序就是拓扑序列</p>
<h1 id="DFS树"><a href="#DFS树" class="headerlink" title="DFS树"></a>DFS树</h1><p>生成过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307200910137.gif"
                     
                ></p>
<p>生成结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307200911360.webp"
                      alt="image.png"
                ></p>
<p>首先我们定义生成的边为树边，指向祖先的边称作回边，</p>
<p>遍历时遇到子树节点的边叫做前向边，遍历时遇到访问过的非祖先节点形成的边叫做横叉边。</p>
<p>观察这棵树，我们不难发现一些结论：</p>
<ol>
<li>生成树中，回边连接的一定是子孙节点。如果连接的是兄弟节点，那么肯定会沿着这条“回边”继续 DFS 下去，那么这条回边将会成为树边，“兄弟”节点也不再是兄弟关系，而是子孙关系。</li>
<li>当树边 $u\to{v}$ 不存在连接它祖先和它的子孙节点的回边时，它是桥。</li>
<li>回边一定不是桥。</li>
<li>假如无向连通图有桥，那么就不可能使每条边给定一个方向后成为一个强连通图。因为假定 $uv$ 桥的方向是 $u\to{v}$，那么此时就不存在 $v\to{u}$ 的一条路径。</li>
<li>假如无向连通图无桥，那么就可以使每条边给定一个方向后成为一个强连通图，使树边均向下，回边均向上。</li>
<li>根节点可以移动到任意节点，任意节点都可以回到根节点。</li>
<li>回边和横叉边的终点时间戳一定大于起点。</li>
<li>对于每个强连通分量中的 dfs 生成树，必然存在一个点是其它所有点的祖先，即根节点 $u$ 是 dfs 序最小的点，若存在一个点$v$不在以$u$为根的树中，那么一定存在一条 $u\to{v}$ 的回边或者横叉边，而这两种边出现则意味着 $v$ 一定在之前被访问过，而这与 $u$ dfs 序最小矛盾。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307262202871.webp"
                      alt="graph (4).png"
                ></p>
<p>比如本图中$5\to{2}$为回边，$1\to{5}$ 为前向边，$3\to{4}$为树边。</p>
<p>而改变一下 dfs 的顺序那么 dfs 生成树的形态将会不同。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307262213841.webp"
                      alt="graph (5).png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307262213510.webp"
                      alt="graph (6).png"
                ></p>
<p>比如上面两图。</p>
<p>仅改变了遍历顺序，生成的 dfs 树的形态便不同，每条边的性质也可能不同。</p>
<h1 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p><a class="link"   href="https://blog.csdn.net/doubleguy/article/details/109264374" >图解理解更佳<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<ul>
<li>点的连通性：无向图中，若点 $i$ 到点 $j$ 有路径，那么 $i$ 和 $j$ 就是连通的。</li>
<li>连通图：无向图中，任意两点间均有路径。</li>
<li>连通分量：分量其实就是子图，特指无向图。<strong>无向图</strong>的连通分量是它的<strong>最大连通子图</strong>，也就是说对于一个点蔓延出去的所有边，不能再往上加边了，而不是边数最多的连通子图，因此一个无向图可以有多个连通分量，<strong>连通分量</strong>也叫做<strong>连通块</strong>。也叫做<strong>极大连通分量</strong>，是一个概念。任何连通图的连通分量有且只有一个，即它本身。<strong>极小连通分量</strong>是在保持连通性的前提下的最小子图，形态是一棵树。</li>
<li>强连通图：特指<strong>有向图</strong>。有向图中，点 $i$ 到点 $j$ 有路径，则称这两点强连通。若任意一对顶点之间是强连通的，那么就是强连通图。</li>
<li>强连通分量：有向图中的极大强连通子图。与上面类似的，极大强连通分量与极小连通分量。</li>
<li>生成树：连通图中包含所有顶点的极小连通子图。</li>
<li>桥：无向图中，若删除了一条边，整个图的连通分量发生了改变，那么这条边就是桥。桥其实就是连通各个连通块之间的唯一的边。</li>
<li>生成森林：即一个非连通图中，包含多个连通块，每个连通块的生成树所组成的集合。</li>
</ul>
<h2 id="Tarjan求强连通分量"><a href="#Tarjan求强连通分量" class="headerlink" title="Tarjan求强连通分量"></a>Tarjan求强连通分量</h2><blockquote>
<p>有向图求 SCC</p>
</blockquote>
<p>我们维护两个变量：</p>
<p>$dfn_i$ 代表第 $i$ 号点的遍历次序（时间戳），也就是第几个被搜索到的。</p>
<p>$low_i$ 代表第 $i$ 号点经过最多一条非树边可达的与它强连通的点的 dfs 序，</p>
<p>$low(p)$ 可以通过 DP 得到，</p>
<p>对于某个以 $p$ 为起点的边 $p\to{q}$</p>
<p>如果 $q$ 未访问过，则 $q$ 在 $p$ 的子树上，如果某节点 $r$ 从 $q$ 起可以经过最多一条回边可以到达，那么从 $p$ 开始也可以到达（先从 $p$ 到 $q$ 再从 $q$ 到 $r$），所以可以先递归处理 $q$，然后更新$low(p)&#x3D;\min(low(p),low(q))$。</p>
<p>如果 $q$ 已经访问过，并且 $p$ 与 $q$ 强连通，那么 $low(p)&#x3D;\min(low(p),dfsn(q))$，其实就是访问到了非树边。</p>
<p>强连通性不存在传递性。比如 $u$ $v$ 之间强连通，$v$ $q$ 之间强连通，那么 $u$ $q$ 之间不一定强连通，$u\rightarrow v \leftarrow q$，因此只能用 $q$ 的 $dfsn$ 来更新 $p$ 的 $low$。</p>
<p>那么我怎么确定一个点是否可达呢？</p>
<p>因为回边和横叉边都指向 dfs 序较小的节点，而前向边又不影响上述转移方程，所以我们只需要确定哪些点比该点的 dfs 序小切能到达该点，这可以用一个栈来维护。</p>
<p>每次搜到新点就让它入栈，对点 $p$ 的子树搜索结束时，若$low(p)&#x3D;n&lt;dfsn(p)$，设 dfs 序为 $n$ 的点为 $q$，则 $p$ 点可达的 $q$ 点都可达（$q$ 是 $p$ 的子树中经过不超过一条非树边能够到达的 dfs 序最小的点，这么说 $q$ 是 $p$ 的祖先），而 $q$ 可能不止 $p$ 这一颗子树，所以 $p$ 应当留在栈内，因为它们都可能通过 $p$ 强连通，都可能是一个强连通分量。</p>
<p>也就是说，栈内的元素是当前搜索到的可能为强连通分量的元素，一个树在没有把它的若干子树搜索完全的情况下，之前搜索的树的子树不会出栈，出栈即意味着找到了一个强连通分量，当且仅当返回时发现$low(p)&#x3D;dfsn(p)$。</p>
<p>显然，这样维护的栈内元素的 $dfsn$ 是递增的。</p>
<p>每个点的 $low()$ 值初始化为它的 $dfsn$。</p>
<p>我们实际上在找的每个节点的 $low()$ 值就是它在它所在的强连通分量的根节点的 $dfsn$。</p>
<p>一个点的子树搜索完毕时，它的 $low()$ 才会被更新。</p>
<p>得到的强连通分量编号的顺序符合拓扑序（编号越小，拓扑序越靠后）。</p>
<p>把每个强连通分量缩为一个点之后，得到的是一张<strong>有向无环图</strong>，因为只要能遍历到其中一个点，就一定能遍历到该强连通分量的所有点。</p>
<p><strong>强连通分量中</strong>，tarjan 关注的是<strong>在不在一个强连通分量内</strong>。</p>
<p>而<strong>割点割边</strong>问题中关注<strong>搜索子树的个数</strong>。</p>
<p>代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+7</span>;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g_2[N];</span><br><span class="line"><span class="comment">//cscc代表强连通分量的数量，scc代表每个点所属的强连通分量的编号，ins代表是否在栈中</span></span><br><span class="line"><span class="type">int</span> dfsn[N],low[N],ins[N],scc[N],deep,cscc,n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[p]=dfsn[p]=++deep;</span><br><span class="line">    ins[p]=<span class="number">1</span>;</span><br><span class="line">    s.<span class="built_in">push</span>(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;q:g[p])<span class="comment">//遍历出边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfsn[q])<span class="comment">//未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(q);</span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[p],low[q]);</span><br><span class="line">        &#125;<span class="comment">//访问过且q可达p，因为栈中元素强连通</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ins[q]) low[p]=<span class="built_in">min</span>(low[p],dfsn[q]);<span class="comment">//注意这里为什么是dfsn[q]而不是low[q]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[p]==dfsn[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">        cscc++;</span><br><span class="line">        <span class="keyword">while</span>(top!=p)</span><br><span class="line">        &#123;</span><br><span class="line">            top=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            ins[top]=<span class="number">0</span>;</span><br><span class="line">            scc[top]=cscc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//原图不一定是强连通图，因此每个节点都要看一遍</span></span><br><span class="line">        <span class="keyword">if</span>(!dfsn[i])<span class="comment">//未访问过</span></span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[i])<span class="comment">//以i为起点的出边</span></span><br><span class="line">            <span class="keyword">if</span>(scc[i]!=scc[j])<span class="comment">//如果不是一个强连通分量，那就可以把两个强连通分量当作两个点连接起来</span></span><br><span class="line">                g_2[scc[i]].<span class="built_in">push_back</span>(scc[j]);<span class="comment">//j是i的出边，即j的强连通分量是i的强连通分量的出边</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>重边与自环对于有向图求强连通分量来说没有影响。</p>
<h2 id="Tarjan求割点与桥"><a href="#Tarjan求割点与桥" class="headerlink" title="Tarjan求割点与桥"></a>Tarjan求割点与桥</h2><blockquote>
<p>无向图</p>
</blockquote>
<p>首先我们来明确一下这两个概念的定义：</p>
<ul>
<li>割点：删去这个点会使无向图的连通分量数增加。</li>
<li>桥（割边）：删去这条边会使无向图的连通分量数增加。</li>
</ul>
<p>那么我总不能把每条边和每个点都删掉看看吧，这样肯定行不通。</p>
<p>如何求割点与割边？</p>
<h3 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h3><p>在无向图中，$low$ 值为不经过父亲节点能到达的 dfsn 最小的节点 ，换句话说，是经过以自身为根节点的子树中至多一条非树边能够到达的最小 dfs 序的点。</p>
<p>无向图中，只需要考虑回边，因为无向图的 dfs 树不存在横叉边和前向边。</p>
<p>设以 $p$ 为根的子树为 $subtree(p)$，那么 $low(p)$ 就是 $subtree(p)$ 中的点和通过一条回边能到达 $subtree(p)$ 的点中 $dfsn$ 最小的值。</p>
<p>若 $p$ 存在一个子节点 $q$ 满足 $low(q)\ge{dfsn(p)}$，说明 $q$ 无法通过它的子树<strong>逃</strong>到比 $p$ dfs 序更小的节点。所以 $q$ 想要到达父亲节点外面的点，也就是<strong>逃</strong>出去，只能通过它的父亲节点也就是 $p$ 点，因此只要删去 $p$ 点，$q$ 和 $dfsn$ 小于 $p$ 的点就分开了，因此 $p$ 是一个割点。</p>
<p>那$q$是不是割点呢？不一定是。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307281815999.webp"
                      alt="image.png"
                ></p>
<p>这样一张图，有颜色的都是割点&#x2F;割边（注：左边从下往上第三个点应该也是割点）。</p>
<p>很明显割点的父亲或儿子不一定也是割点。</p>
<p>两个割点之间也不一定是割边。</p>
<p>割边的两端也不一定是割点。</p>
<p>这里引入一个结论：割边两端点都是割点当且仅当去掉这条割边后得到的连通块大小都 $\ge{2}$，因为叶子不可能为割点。</p>
<p>所以重复一遍：$p$ 的子节点 $q$ 满足 $low(q)\ge{dfsn(p)}$，那么说明 $p$ 是割点。</p>
<p>还有一种特殊情况，当 $p$ 是 dfs 树的根节点时，不存在比 $p$ dfs 序更小的点。</p>
<p>因此对于<strong>根节点</strong>，若有两个以上子节点，那就是割点。</p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P3388" >P3388 割点<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+7</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> dfsn[N],low[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; point;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p,<span class="type">bool</span> root=<span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    low[p]=dfsn[p]=++cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;q:e[p])<span class="comment">//枚举p的出边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfsn[q])<span class="comment">//这个点没访问过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(q,<span class="literal">false</span>);<span class="comment">//递归，并且这个点不是根</span></span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[p],low[q]);<span class="comment">//更新父节点的low值</span></span><br><span class="line">            tot+=(low[q]&gt;=dfsn[p]);<span class="comment">//子节点的low值比父节点的dfs序还要大，那就把需要p的无法逃脱的子树个数加一</span></span><br><span class="line">            <span class="comment">//需要p的子树是指删去p后子树无法与外界联系</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//访问过，那就对low值取min</span></span><br><span class="line">        &#123;</span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[p],dfsn[q]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot&gt;root)<span class="comment">//是根那就要大于1，否则就要大于0</span></span><br><span class="line">        point.<span class="built_in">push_back</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="割边"><a href="#割边" class="headerlink" title="割边"></a>割边</h3><blockquote>
<p>割边，也叫做桥，定义之前说过。</p>
</blockquote>
<p>较割点，修改一下$low$的定义：</p>
<ul>
<li>经过以自身为根节点的子树中至多一条非树边能够到达的最小 dfs 序的点，<strong>其中非树边不包括儿子到父亲的反向边</strong>。</li>
</ul>
<p>所以对于$low_q&gt;dfn_p$，那么$p\leftrightarrow{q}$这条边就是桥。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+7</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> dfsn[N],low[N],fa[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; point;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan_0</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[p]=dfsn[p]=++cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;q:e[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfsn[q])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[q]=p;</span><br><span class="line">            <span class="built_in">tarjan_0</span>(q);</span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[p],low[q]);</span><br><span class="line">            <span class="keyword">if</span>(low[q]&gt;dfsn[p]) bridges.<span class="built_in">emplace_back</span>(p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fa[p]!=q) low[p]=<span class="built_in">min</span>(low[p],dfsn[q]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>它和割点的区别在于它不能到它的父亲。</p>
<h3 id="点双连通分量"><a href="#点双连通分量" class="headerlink" title="点双连通分量"></a>点双连通分量</h3><blockquote>
<p>v-DCC</p>
</blockquote>
<p>是满足图中不包含任意割点的极大连通子图。</p>
<p>即删去任何一个点不会使这个图的连通性发生改变。</p>
<p>一个孤立的点是一个点双连通分量，两个割点是一个点双连通分量。</p>
<p>对于自环，我们特判掉即可，实际上也是一个孤立点。</p>
<p><strong>对于不同的两个点双之间有且只有一个公共点，且这个点就是割点。</strong></p>
<p>假如有多个公共点，那么删除任意一个公共点，两个点双之间还是可以相互连通，那么它们就可以合并为一个大的点双，因此有以上结论。</p>
<p>所以我们求点双连通分量也就是求每个割点的子树。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, edcnt, cnt, cdcc;</span><br><span class="line"><span class="type">int</span> fir[N], low[N], dfsn[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dcc[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; point;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">&#125;e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to = v;</span><br><span class="line">    e[edcnt].nxt = fir[u];</span><br><span class="line">    fir[u] = edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p, <span class="type">bool</span> root = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    dfsn[p] = low[p] = ++cnt;</span><br><span class="line">    s.<span class="built_in">push</span>(p);</span><br><span class="line">    <span class="keyword">if</span> (root &amp;&amp; fir[p] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dcc[++cdcc].<span class="built_in">emplace_back</span>(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = fir[p]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfsn[q])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(q, <span class="literal">false</span>);</span><br><span class="line">            low[p] = <span class="built_in">min</span>(low[p], low[q]);</span><br><span class="line">            <span class="keyword">if</span> (low[q] &gt;= dfsn[p])</span><br><span class="line">            &#123;</span><br><span class="line">                tot++;</span><br><span class="line">                <span class="keyword">if</span> (tot &gt; root) point.<span class="built_in">push_back</span>(p);</span><br><span class="line">                cdcc++;</span><br><span class="line">                <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (top != q)</span><br><span class="line">                &#123;</span><br><span class="line">                    top = s.<span class="built_in">top</span>();</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    dcc[cdcc].<span class="built_in">emplace_back</span>(top);</span><br><span class="line">                &#125;</span><br><span class="line">                dcc[cdcc].<span class="built_in">emplace_back</span>(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[p] = <span class="built_in">min</span>(low[p], dfsn[q]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfsn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cdcc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cdcc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="type">int</span>)dcc[i].<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j : dcc[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, j);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="边双连通分量"><a href="#边双连通分量" class="headerlink" title="边双连通分量"></a>边双连通分量</h3><blockquote>
<p>e-DCC</p>
</blockquote>
<p>与点双类似，即不含割边的最大子图。</p>
<p>但是这个是不能通过反向边回到父亲，而重边其实属于非树边是可以走的，因此不可以通过判 $fa$ 来判断不能回到父亲，要通过判断反向边的方式。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">7</span>, M = <span class="number">2e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt, edcnt = <span class="number">1</span>, cdcc;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dcc[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="type">int</span> fir[N], low[N], dfsn[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">&#125;e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to = v;</span><br><span class="line">    e[edcnt].nxt = fir[u];</span><br><span class="line">    fir[u] = edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[p] = dfsn[p] = ++cnt;</span><br><span class="line">    s.<span class="built_in">push</span>(p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = fir[p]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfsn[q])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(q, i);</span><br><span class="line">            low[p] = <span class="built_in">min</span>(low[p], low[q]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != (f ^ <span class="number">1</span>)) low[p] = <span class="built_in">min</span>(low[p], dfsn[q]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[p] == dfsn[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">        cdcc++;</span><br><span class="line">        <span class="keyword">while</span> (top != p)</span><br><span class="line">        &#123;</span><br><span class="line">            top = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            dcc[cdcc].<span class="built_in">emplace_back</span>(top);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfsn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cdcc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cdcc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="type">int</span>)dcc[i].<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j : dcc[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="练习题1"><a href="#练习题1" class="headerlink" title="练习题1"></a>练习题1</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303122017234.webp"
                      alt="image.webp"
                ></p>
<p>用在一条边上是最优的</p>
<p>枚举每条边，看看把所有花费都用在它身上能降低多少代价</p>
<p>如果是树边，那么直接减去</p>
<p>如果非树边，那就和链上最大值作差，使差值最大（也就是减小地最大）</p>
<h1 id="练习题2"><a href="#练习题2" class="headerlink" title="练习题2"></a>练习题2</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303122031634.webp"
                      alt="image.webp"
                ></p>
<p>先求生成树中白色边最少有多少条</p>
<p>其次算生成树中白色边最多有多少条</p>
<p>也就是白边优先跑一遍 Kruscal</p>
<p>再黑边优先跑一边 Kruscal</p>
<p>如果存在一个斐波那契数处于这个最大值和最小值的区间内</p>
<p>那么就存在这样一颗生成树</p>
<p>否则不存在</p>
<p>因为白边最小到白边最多的过程就是一条条把黑边替换成白边的过程</p>
<h1 id="练习题3"><a href="#练习题3" class="headerlink" title="练习题3"></a>练习题3</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303122047616.webp"
                      alt="image.webp"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303122046326.webp"
                      alt="image.webp"
                ></p>
<p>使它们差分序列$&#x3D;0$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303122051449.webp"
                      alt="image.webp"
                ></p>
<p>让这$m$个值相同</p>
<p>在<strong>差分序列</strong>中体现为前面的某个值加上x，后面的某个值减去x</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303122058923.webp"
                      alt="image.webp"
                ></p>
<p>在这段差分序列中，和是不变的</p>
<p>如果是有解的，那么首先要保证这$m$项的和等于$0$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202303122059718.webp"
                      alt="image.webp"
                ></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>基础算法</title>
    <url>/af411f31.html</url>
    <content><![CDATA[<h1 id="尺取法"><a href="#尺取法" class="headerlink" title="尺取法"></a>尺取法</h1><p>其实就是双指针法。</p>
<p>给一道例题找找感觉吧：</p>
<p><a class="link"   href="http://acm.hdu.edu.cn/showproblem.php?pid=2029" >HDU2029判断回文串<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="type">bool</span> ans=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++,j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans) cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>尺取法可以解决滑动窗口问题，也可以进行数组去重。</p>
<p>指针不够的时候可以加；</p>
<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><blockquote>
<p>这是一种非常考验边界处理细节的一种算法。</p>
</blockquote>
<p><a class="link"   href="https://blog.csdn.net/weixin_43305485/article/details/122347842" >STL<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">100000</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">2</span>*<span class="built_in">int</span>(<span class="number">1e9</span>)<span class="number">+10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> num[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">34</span>&#125;; </span><br><span class="line">	<span class="built_in">sort</span>(num,num<span class="number">+6</span>);                           <span class="comment">//按从小到大排序 </span></span><br><span class="line">	<span class="type">int</span> pos1=<span class="built_in">lower_bound</span>(num,num<span class="number">+6</span>,<span class="number">7</span>)-num;    <span class="comment">//返回数组中第一个大于或等于被查数的值 </span></span><br><span class="line">	<span class="type">int</span> pos2=<span class="built_in">upper_bound</span>(num,num<span class="number">+6</span>,<span class="number">7</span>)-num;    <span class="comment">//返回数组中第一个大于被查数的值</span></span><br><span class="line">	cout&lt;&lt;pos1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num[pos1]&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;pos2&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num[pos2]&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">sort</span>(num,num<span class="number">+6</span>,cmd);                      <span class="comment">//按从大到小排序</span></span><br><span class="line">	<span class="type">int</span> pos3=<span class="built_in">lower_bound</span>(num,num<span class="number">+6</span>,<span class="number">7</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;())-num;  <span class="comment">//返回数组中第一个小于或等于被查数的值 </span></span><br><span class="line">	<span class="type">int</span> pos4=<span class="built_in">upper_bound</span>(num,num<span class="number">+6</span>,<span class="number">7</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;())-num;  <span class="comment">//返回数组中第一个小于被查数的值 </span></span><br><span class="line">	cout&lt;&lt;pos3&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num[pos3]&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;pos4&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num[pos4]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>其实也有一种可以不用 <code>greater&lt;int&gt;()</code> 仿函数的方法：</p>
<ul>
<li>小于等于：查找最小的大于某数的下标(upper_bound) - 1</li>
<li>小于：查找最小的大于等于某数的下标(lower_bound) - 1</li>
</ul>
<p>在这里不多赘述，只可意会不可言传。</p>
<h2 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P1462#submit" >P1462通往奥格瑞玛的道路<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><code>二分+最短路</code></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50005</span>,M=<span class="number">1000005</span>;</span><br><span class="line"><span class="type">int</span> n,m,b;</span><br><span class="line"><span class="type">int</span> f[N],fir[N],cnt,dist[N],righ[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> next,to,w;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].next=fir[u];</span><br><span class="line">    e[cnt].to=v;</span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    fir[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> p,d;</span><br><span class="line">    <span class="built_in">node</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;p=a;d=b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.d&gt;b.d;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijksta</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;f[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        dist[i]=<span class="number">1e9</span>;</span><br><span class="line">    <span class="built_in">memset</span>(righ,<span class="number">0</span>,<span class="built_in">sizeof</span>(righ));</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">node</span>(i,dist[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(righ[q.<span class="built_in">top</span>().p]) q.<span class="built_in">pop</span>();</span><br><span class="line">        node now=q.<span class="built_in">top</span>();</span><br><span class="line">        <span class="type">int</span> p=now.p;</span><br><span class="line">        righ[p]=<span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=fir[p];j;j=e[j].next)</span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="type">int</span> v=e[j].to;</span><br><span class="line">            <span class="keyword">if</span>(f[v]&gt;x) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> d=e[j].w+dist[p];</span><br><span class="line">            <span class="keyword">if</span>(d&lt;dist[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v]=d;</span><br><span class="line">                </span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">node</span>(v,d));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]&lt;=b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">erfen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=MAX,mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        c=<span class="built_in">dijksta</span>(mid);</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">            mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l=mid<span class="number">+1</span>;</span><br><span class="line">            mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dijksta</span>(MAX)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;AFK&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">erfen</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P1824" >P1824进击的奶牛<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1000010</span>],n,c;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">P</span><span class="params">(<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,last=-maxn;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]-last&gt;=d)</span><br><span class="line">        &#123;</span><br><span class="line">            last=a[i];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k&gt;=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a<span class="number">+1</span>,a+n<span class="number">+1</span>);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1e9</span>,ans,mid;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">P</span>(mid=l + r &gt;&gt; <span class="number">1</span>))</span><br><span class="line">            ans=mid,l=mid<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P1419" >P1419<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,s,t;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100050</span>];</span><br><span class="line"><span class="type">double</span> sum[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//预处理前缀和（-k）</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i]*<span class="number">1.0</span>-k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s,p=<span class="number">0</span>;i&lt;=n;i++,p++)<span class="comment">//单调队列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;=l&amp;&amp;sum[q[r]]&gt;sum[p]) r--;</span><br><span class="line">        q[++r]=p;</span><br><span class="line">        <span class="keyword">while</span>(i-q[l]&gt;t)++l;</span><br><span class="line">        <span class="keyword">if</span>(sum[i]-sum[q[l]]&gt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">double</span> l=<span class="number">-1e4</span>,r=<span class="number">1e4</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">1e-5</span>)<span class="comment">//实数二分</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="http://poj.org/problem?id=3122" >POJ3122<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">double</span> a[<span class="number">100000</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;<span class="comment">//能切的PIE总数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=(<span class="type">int</span>)(a[i]/mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;=m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        m++;</span><br><span class="line">        <span class="type">double</span> maxp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">            a[i]=PI*r*r;</span><br><span class="line">            <span class="keyword">if</span>(maxp&lt;a[i]) maxp=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> l=<span class="number">0</span>,r=maxp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line">            <span class="keyword">else</span> r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>,l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P1083" >P1083<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+117</span>;</span><br><span class="line"><span class="type">int</span> r[N],d[N],s[N],t[N],pre[N],ne[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=mid;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[s[i]]+=d[i];</span><br><span class="line">        pre[t[i]<span class="number">+1</span>]-=d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ne[i]=ne[i<span class="number">-1</span>]+pre[i];<span class="comment">//利用差分数组求当天要租的教室</span></span><br><span class="line">        <span class="keyword">if</span>(ne[i]&gt;r[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;r[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;d[i],&amp;s[i],&amp;t[i]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(m))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=m;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)<span class="comment">//等于后不用判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid;<span class="comment">//注意细节</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-1\n%lld&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P2678" >P2678<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L,N,M;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> stone[<span class="number">500005</span>];</span><br><span class="line"><span class="type">int</span> s[<span class="number">100000005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> size=<span class="number">0</span>,take=<span class="number">0</span>;</span><br><span class="line">	s[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(stone[i]-s[size]&lt;x)</span><br><span class="line">		&#123;</span><br><span class="line">			take++;</span><br><span class="line">			<span class="keyword">continue</span>;<span class="comment">//去掉 </span></span><br><span class="line">		&#125;</span><br><span class="line">		s[++size]=stone[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(L-s[size]&lt;x)</span><br><span class="line">	&#123;</span><br><span class="line">		size--;</span><br><span class="line">		take++;        </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> take&lt;=M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;L,&amp;N,&amp;M);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;stone[i]);</span><br><span class="line">	<span class="type">int</span> left=<span class="number">0</span>,right=L<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">while</span>(left<span class="number">+1</span>&lt;right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">f</span>(mid)==<span class="number">1</span>)</span><br><span class="line">			left=mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			right=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=left;<span class="comment">//***</span></span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P1314" >P1314<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">1e12</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,maxn=<span class="number">-1</span>,sum;</span><br><span class="line"><span class="type">int</span> w[N],v[N],l[N],r[N];</span><br><span class="line"><span class="type">int</span> ren[N],rev[N],y;<span class="comment">//数量前缀和，价值前缀和，y</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(ren,<span class="number">0</span>,<span class="built_in">sizeof</span>(ren));</span><br><span class="line">    <span class="built_in">memset</span>(rev,<span class="number">0</span>,<span class="built_in">sizeof</span>(rev));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&gt;=mid) ren[i]=ren[i<span class="number">-1</span>]<span class="number">+1</span>,rev[i]=rev[i<span class="number">-1</span>]+v[i];</span><br><span class="line">        <span class="keyword">else</span> ren[i]=ren[i<span class="number">-1</span>],rev[i]=rev[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        y+=(ren[r[i]]-ren[l[i]<span class="number">-1</span>])*(rev[r[i]]-rev[l[i]<span class="number">-1</span>]);</span><br><span class="line">    sum=<span class="built_in">llabs</span>(y-s);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;s) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;w[i],&amp;v[i]);</span><br><span class="line">        maxn=<span class="built_in">max</span>(maxn,w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l[i],&amp;r[i]);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=maxn;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(m)) l=m<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;ans) ans=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h1 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h1><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P3382" >P3382<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-6</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        s=s*x+a[i];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> l,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lf%lf&quot;</span>,&amp;n,&amp;l,&amp;r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">0</span>;i--) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> k=(r-l)/<span class="number">3.0</span>;</span><br><span class="line">        <span class="type">double</span> m1=l+k;</span><br><span class="line">        <span class="type">double</span> m2=r-k;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">f</span>(m1)&gt;<span class="built_in">f</span>(m2)) r=m2;</span><br><span class="line">        <span class="keyword">else</span> l=m1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.5f\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P3745" >P3745<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n,m,t[N],b[N];</span><br><span class="line">ll A,B,C,ans;</span><br><span class="line"><span class="function">ll <span class="title">calc1</span><span class="params">(<span class="type">int</span> p)</span><span class="comment">//将最晚公布成绩的时间调整到p所产生的不愉快度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,y=<span class="number">0</span>;<span class="comment">//x代表能提前改完卷子的[总提前天数和]但是由于不愉快度只由最后改完卷子的那一天决定，所以可以将提前改完的天数延后而使推迟改完的天数提前</span></span><br><span class="line">    <span class="comment">//y代表推迟改完卷子的[总推迟天数和]，意味着可以选择用x来填补y，使整体平均，使最晚那一天尽可能靠前</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&lt;p) x+=p-b[i];</span><br><span class="line">        <span class="keyword">else</span> y+=b[i]-p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(A&lt;B)<span class="comment">//如果操作A（交换互补）的代价更低，那就能交换即交换，不能交换再新添人手</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(x,y)*A+(y-<span class="built_in">min</span>(x,y))*B;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> y*B;<span class="comment">//不如直接添人手代价更低</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc2</span><span class="params">(<span class="type">int</span> p)</span><span class="comment">//所有同学的在最后一天产生的不愉快总和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]&lt;p) sum+=(p-t[i])*C;<span class="comment">//推迟的天数*C</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;A&gt;&gt;B&gt;&gt;C&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b+m<span class="number">+1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(t<span class="number">+1</span>,t+n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">if</span>(C&gt;=<span class="number">1e16</span>)<span class="comment">//全部补充老师也比让学生不满意更优，那就调老师让学生满意</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">calc1</span>(t[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="number">1e16</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=N;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">2</span>)<span class="comment">//三分得到最小值所在的天的序号的区间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m1=l+(r-l)/<span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> m2=r-(r-l)/<span class="number">3</span>;</span><br><span class="line">        ll c1=<span class="built_in">calc1</span>(m1)+<span class="built_in">calc2</span>(m1);</span><br><span class="line">        ll c2=<span class="built_in">calc1</span>(m2)+<span class="built_in">calc2</span>(m2);</span><br><span class="line">        <span class="keyword">if</span>(c1&lt;=c2) r=m2;</span><br><span class="line">        <span class="keyword">else</span> l=m1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)<span class="comment">//枚举</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll x=<span class="built_in">calc1</span>(i)+<span class="built_in">calc2</span>(i);</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<hr>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P1883" >P1883<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><del>咕咕咕</del></p>
<h1 id="倍增与ST"><a href="#倍增与ST" class="headerlink" title="倍增与ST"></a>倍增与ST</h1><p><strong>超级快的速度：</strong>$O(log_2n)$</p>
<blockquote>
<p>原理与二分法相对，不多赘述。</p>
</blockquote>
<h2 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h2><p>利用二进制的“特性”，可以将一个数展开得到我们想要的“倍增形式”。</p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><a class="link"   href="https://www.luogu.com.cn/problem/P4155" >P4155<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>这道题有道思路相仿的题目可以先做一下：<a class="link"   href="https://www.luogu.com.cn/problem/P1803" >P1803<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><strong>对于本题：</strong></p>
<ol>
<li>断环为链。</li>
<li>贪心：选择一个区间，下一个区间的左端点必须<strong>小于等于</strong>这个区间的右端点，其中满足条件的下一个区间的右端点最大为最优。</li>
<li>倍增：快速查询走$2^i$步所能到达的最优的区间，避免暴力枚举。</li>
</ol>
<p>定义<code>go[s][i]</code> 表示从第s个区间出发，走$2^i$个最优区间所到达的区间（战士的范围）。</p>
<p>所以首先需要预处理出<code>go[][]</code>。</p>
<p><em>复杂度：</em>$nlog_2n$</p>
<p><strong>递推式：</strong><code>go[s][i]=go[go[s][i-1]][i-1]</code></p>
<p><em>总复杂度：</em>$2nlog_2n$</p>
<p><strong>code：</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e5</span><span class="number">+1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yum</span>&#123;</span><br><span class="line">    <span class="type">int</span> id,l,r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> yum x) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l&lt;x.l;<span class="comment">//以左端点最小的为第一个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;w[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n2;<span class="comment">//断环为链后的链长</span></span><br><span class="line"><span class="type">int</span> go[N][<span class="number">20</span>],res[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nxt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n2;i++)<span class="comment">//贪心求每个区间的下一个区间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(nxt&lt;=n2&amp;&amp;w[nxt].l&lt;=w[i].r)</span><br><span class="line">            nxt++;</span><br><span class="line">        go[i][<span class="number">0</span>]=nxt<span class="number">-1</span>;<span class="comment">//因为结束循环时多加了1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)</span><br><span class="line">            go[j][i]=go[go[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//从x出发</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=w[x].l+m,cur=x,ans=<span class="number">1</span>;<span class="comment">//len为以x为起点最远能走到的位置，ans为初始的起点战士</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">log2</span>(N);i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos=go[cur][i];</span><br><span class="line">        <span class="keyword">if</span>(pos&amp;&amp;w[pos].r&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=<span class="number">1</span>&lt;&lt;i;<span class="comment">//区间数（即战士数）</span></span><br><span class="line">            cur=pos;<span class="comment">//跳到这个区间</span></span><br><span class="line">        &#125;</span><br><span class="line">        res[w[x].id]=ans<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        w[i].id=i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[i].l,&amp;w[i].r);</span><br><span class="line">        <span class="keyword">if</span>(w[i].r&lt;w[i].l) w[i].r+=m;<span class="comment">//若右端点比左端点小，则说明这段区间包含需要断环的点，那就断，使得这段区间在链上可以正常表示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line">    n2=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n2++;</span><br><span class="line">        w[n2]=w[i];</span><br><span class="line">        w[n2].l=w[i].l+m;<span class="comment">//复制一份</span></span><br><span class="line">        w[n2].r=w[i].r+m;<span class="comment">//复制是为了对于8~2--&gt;8~12的这种超出区间的递推的正确性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">get</span>(i);<span class="comment">//计算以每名战士为起点的最少人数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="ST"><a href="#ST" class="headerlink" title="ST"></a>ST</h2><blockquote>
<p>ST算法基于倍增原理，适用于求解静态空间的区间最值查询（RMQ）。</p>
</blockquote>
<p><strong>RMQ问题</strong>：给定长度为n的静态数列，做m次查询，每次给定一段区间<code>[L,R]</code>，求这段区间中的最值。</p>
<p>以最小值为例：</p>
<p>若一个大区间能被两个小区间覆盖，那么大区间的最值等于两个小区间的最值的最值（重合不影响）。</p>
<p>于是得到基本思路：</p>
<ol>
<li>将序列拆分为若干个小区间，并预处理小区间的最值。</li>
<li>对任意区间进行最值查询，只需要找到覆盖它的两个小区间，由两个小区间的最值得出。</li>
</ol>
<p>定义<code>dp[s][k]=min(dp[s][k-1],dp[s+(1&lt;&lt;(k-1))][k-1])</code>，</p>
<p>代表从$s$开始的$2^k$的区间最值为从s开始的$2^{k-1}$区间和从$s+2^{k-1}$开始的$2^{k-1}$区间的最值。</p>
<p>递推关系实际是一个<code>DP</code>的过程，复杂度$nlogn$。</p>
<hr>
<p>区间<code>[L,R]</code>的长度为<code>len=R-l+1</code>，两个小区间的长度都为x，使得$x\le{len}$并且$2x\ge{len}$，这样可以保证覆盖。</p>
<p>于是令$x&#x3D;2^k$，$k&#x3D;log_2(x)$，由于k是向下取整的，于是能满足$x\le{len}$并且$2x\ge{len}$的条件。</p>
<p>当然也可以写作$k&#x3D;(int)(log(double(R-L+1))&#x2F;log(2.0))$（利用换底公式）。</p>
<p>如果嫌库函数慢的话也可以自己写log函数。</p>
<p><strong>ST:</strong></p>
<p>$$<br>nlogn-(\sum^{logn}_{i&#x3D;1}2^i)<br>$$</p>
<hr>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P2251" >P2251<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Set*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment">set&lt;pair&lt;int,int&gt; &gt; S;</span></span><br><span class="line"><span class="comment">int n ,m,a[100005]; </span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	cin&gt;&gt;n&gt;&gt;m;</span></span><br><span class="line"><span class="comment">	for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		scanf(&quot;%d&quot;,&amp;a[i]);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		S.insert(make_pair(a[i],i));</span></span><br><span class="line"><span class="comment">		if(i&gt;=m) </span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			if(i&gt;m)</span></span><br><span class="line"><span class="comment">				S.erase(make_pair(a[i-m],i-m));</span></span><br><span class="line"><span class="comment">			printf(&quot;%d\n&quot;,(*S.begin()).first);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment"> 	&#125;</span></span><br><span class="line"><span class="comment"> 	return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> st[<span class="number">100005</span>][<span class="number">23</span>];</span><br><span class="line"><span class="type">int</span> LOG2[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG2[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) LOG2[i]=LOG2[i&gt;&gt;<span class="number">1</span>]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        st[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j+(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>&lt;=n;j++)</span><br><span class="line">            st[j][i]=<span class="built_in">min</span>(st[j][i<span class="number">-1</span>],st[j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))][i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qe</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=LOG2[r-l<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)<span class="number">+1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-m<span class="number">+1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">qe</span>(i,i+m<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面注释的做法是用<code>set</code>维护了一个长度为<code>m</code>的序列，利用<code>set</code>自动排序的机制和定值删除的功能实现，<code>pair</code>是为了防止重复。</p>
<p>然后删头去尾，每次输出第一个就是最小的。</p>
<p><code>st</code>做法没啥好说的。</p>
<hr>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P1816" >P1816<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> a[N],st[N][<span class="number">23</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        st[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j+(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>&lt;=m;j++)</span><br><span class="line">            st[j][i]=<span class="built_in">min</span>(st[j][i<span class="number">-1</span>],st[j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))][i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qe</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=(<span class="type">int</span>)<span class="built_in">log2</span>(r-l<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)<span class="number">+1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">qe</span>(l,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>板子题，没啥好说的。</p>
<hr>
<p>关于ST的一些理解：</p>
<p><code>st[i][j]</code>代表以$i$为起点，长度为$2^j$的区间中的最值大小（包含$i$这个端点）</p>
<p><code>st[j][i]=min(st[j][i-1],st[j+(1&lt;&lt;(i-1))][i-1]);</code></p>
<p>所以预处理的时候这个是直接加上区间长度。</p>
<p><code>min(st[l][k],st[r-(1&lt;&lt;k)+1][k]);</code></p>
<p>而访问的时候要减去长度再加一。</p>
<hr>
<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><blockquote>
<p><code>sum[i]=sum[i-1]+a[i]</code></p>
</blockquote>
<p><code>sum[i]</code>即元素a在$[0,i]$的区间和，这样就可以快速进行区间求和了。</p>
<p><code>sum[l~r]=sum[r]-sum[l-1]</code></p>
<h2 id="二阶前缀和"><a href="#二阶前缀和" class="headerlink" title="二阶前缀和"></a>二阶前缀和</h2><p>设：</p>
<ul>
<li>$A$ 是原数组</li>
<li>$B$ 是 $A$ 的前缀和，即 $B_x&#x3D;\sum_{i&#x3D;1}^xA_i$</li>
<li>$C$ 是 $B$ 的前缀和，即 $C_x&#x3D;\sum_{i&#x3D;1}^xB_i$</li>
</ul>
<p>对于 $A_i\leftarrow A_i+1$ 这一操作，$B_i\sim B_{x}$ 都会加一，即 $C_{x}\leftarrow C_{x}+(x - i + 1)\times1$</p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P4868" >练习<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; (-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL a[N];</span><br><span class="line">LL B[N], C[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addB</span><span class="params">(<span class="type">int</span> x, LL v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        B[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addC</span><span class="params">(<span class="type">int</span> x, LL v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        C[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">queryB</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        res += B[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">queryC</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        res += C[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">addB</span>(x, v);</span><br><span class="line">    <span class="built_in">addC</span>(x, <span class="number">1ll</span> * x * v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queryB</span>(x) * (x + <span class="number">1</span>) - <span class="built_in">queryC</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">update</span>(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;Query&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;Modify&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;v);</span><br><span class="line">            <span class="built_in">update</span>(x, v - a[x]);</span><br><span class="line">            a[x] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="三阶前缀和"><a href="#三阶前缀和" class="headerlink" title="三阶前缀和"></a>三阶前缀和</h2><p>设：</p>
<ul>
<li>$A$ 是原数组</li>
<li>$B$ 是 $A$ 的前缀和，即 $B_x&#x3D;\sum_{i&#x3D;1}^xA_i$</li>
<li>$C$ 是 $B$ 的前缀和，即 $C_x&#x3D;\sum_{i&#x3D;1}^xB_i$</li>
<li>$D$ 是 $C$ 的前缀和，即 $D_x&#x3D;\sum_{i&#x3D;1}^xC_i$</li>
</ul>
<p>对于 $A_i\leftarrow A_i+1$ 这一操作，$C_{j}$ 会变成 $C_{j}+(j - i + 1)\times1$</p>
<p>即 $D_x$ 会变成 $D_x+1+2+\dots+(x-i+1)$，即 $D_x+\frac{(x-i+1)\times(x-i+2)}{2}$</p>
<p>$$<br>C_x&#x3D;\sum_{i&#x3D;1}^xB_i&#x3D;\sum_{i&#x3D;1}^x(x-i+1)\times{A_i}<br>$$</p>
<p>$$<br>D_x&#x3D;\sum_{i&#x3D;1}^{x} \dfrac{(i^2-3i)A_i-2xiA_i+(x^2+3x+2)A_i}{2}<br>$$</p>
<p>也可以这样写：</p>
<p>$$<br>D_x&#x3D;\sum_{i &#x3D; 1}^{x}\dfrac{i^2A_i-(2x+3i)A_i+(x^2+3x+2)A_i}{2}<br>$$</p>
<p>维护 $i^2A_i,iA_i,Ai$ 即可。</p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/AT_abc256_f" >练习<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; (-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inv = <span class="number">499122177</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line">LL A[N];</span><br><span class="line">LL B[N], C[N], D[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addB</span><span class="params">(<span class="type">int</span> x, LL v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        B[i] = (B[i] + v) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addC</span><span class="params">(<span class="type">int</span> x, LL v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        C[i] = (C[i] + v) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addD</span><span class="params">(<span class="type">int</span> x, LL v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        D[i] = (D[i] + v) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(LL x, LL v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">addB</span>(x, v);</span><br><span class="line">    <span class="built_in">addC</span>(x, <span class="number">1ll</span> * v * x % MOD);</span><br><span class="line">    <span class="built_in">addD</span>(x, ((<span class="number">1ll</span> * x * x - <span class="number">3ll</span> * x) % MOD + MOD % MOD) * <span class="number">1ll</span> * v % MOD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">queryB</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        res = (res + B[i]) % MOD;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">queryC</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        res = (res + C[i]) % MOD;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">queryD</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        res = (res + D[i]) % MOD;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">queryD</span>(x) - <span class="number">1ll</span> * x * <span class="number">2</span> % MOD * <span class="built_in">queryC</span>(x) % MOD + </span><br><span class="line">           (<span class="number">1ll</span> * x * x + <span class="number">1ll</span> * <span class="number">3</span> * x + <span class="number">2</span>) % MOD * <span class="built_in">queryB</span>(x) % MOD) % MOD + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;A[i]);</span><br><span class="line">        <span class="built_in">update</span>(i, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        LL x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="built_in">update</span>(x, (y - A[x] + MOD) % MOD);</span><br><span class="line">            A[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="number">1ll</span> * <span class="built_in">query</span>(x) * inv) % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>与此类似的还有一题~</p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P8313" >P8313<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.cnblogs.com/lnwhl/p/16640878.html" >题解<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; (-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL ans;</span><br><span class="line"><span class="type">int</span> a[N], S[N];</span><br><span class="line">LL C[N &lt;&lt; <span class="number">1</span>], D[N &lt;&lt; <span class="number">1</span>], E[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; loc[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, LL v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= <span class="number">2</span> * n + <span class="number">1</span>; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">	&#123;</span><br><span class="line">		C[i] += v;</span><br><span class="line">		D[i] += <span class="number">1ll</span> * v * x;</span><br><span class="line">		E[i] += <span class="number">1ll</span> * v * x * x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">		res += <span class="number">1ll</span> * C[i] * (<span class="number">1ll</span> * x * x + <span class="number">3ll</span> * x + <span class="number">2</span>) - <span class="number">1ll</span> * D[i] * (<span class="number">2</span> * x + <span class="number">3</span>) + E[i];</span><br><span class="line">	res &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">lower_bound</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), x) - num.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">		num.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">	num.<span class="built_in">erase</span>(<span class="built_in">unique</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>()), num.<span class="built_in">end</span>());</span><br><span class="line">	<span class="type">int</span> cnt = (<span class="type">int</span>)num.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 离散化</span></span><br><span class="line">		a[i] = <span class="built_in">find</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		loc[a[i]].<span class="built_in">emplace_back</span>(i); <span class="comment">// 记录每种菜品出现的位置</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// for (int i = 1; i &lt;= cnt; i++)</span></span><br><span class="line">	<span class="comment">// &#123;</span></span><br><span class="line">	<span class="comment">// 	for (int j = 1; j &lt;= n; j++)</span></span><br><span class="line">	<span class="comment">// 		S[j] = S[j - 1] + (a[j] == i);</span></span><br><span class="line">	<span class="comment">// 	add(n + 1, 1); // l = 0 时，B = 0 出现了 1 次</span></span><br><span class="line">	<span class="comment">// 	for (int j = 1; j &lt;= n; j++)</span></span><br><span class="line">	<span class="comment">// 	&#123;</span></span><br><span class="line">	<span class="comment">// 		ans += query(S[j] * 2 - j + n + 1 - 1);</span></span><br><span class="line">	<span class="comment">// 		add(S[j] * 2 - j + n + 1, 1);</span></span><br><span class="line">	<span class="comment">// 	&#125;</span></span><br><span class="line">	<span class="comment">// 	add(n + 1, -1);</span></span><br><span class="line">	<span class="comment">// 	for (int j = 1; j &lt;= n; j++)</span></span><br><span class="line">	<span class="comment">// 		add(S[j] * 2 - j + n + 1, -1);</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		loc[i].<span class="built_in">push_back</span>(n + <span class="number">1</span>); <span class="comment">// 处理最后一段区间</span></span><br><span class="line">		<span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)loc[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> s = <span class="number">2</span> * j - last + n + <span class="number">1</span>; <span class="comment">// 等差序列的开头</span></span><br><span class="line">			<span class="type">int</span> t = <span class="number">2</span> * j - loc[i][j] + <span class="number">1</span> + n + <span class="number">1</span>; <span class="comment">// 等差序列的末尾</span></span><br><span class="line">			ans += <span class="built_in">query</span>(s - <span class="number">1</span>) - (t &gt;= <span class="number">2</span> ? <span class="built_in">query</span>(t - <span class="number">2</span>) : <span class="number">0</span>); <span class="comment">// 查询三阶前缀和</span></span><br><span class="line">			<span class="built_in">add</span>(t, <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">add</span>(s + <span class="number">1</span>, <span class="number">-1</span>); <span class="comment">// 公差为一的等差序列下标连续，[s,t] 区间加</span></span><br><span class="line">			last = loc[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		last = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)loc[i].<span class="built_in">size</span>(); j++) <span class="comment">// 重置树状数组</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> s = <span class="number">2</span> * j - last + n + <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> t = <span class="number">2</span> * j - loc[i][j] + <span class="number">1</span> + n + <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">add</span>(t, <span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">add</span>(s + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">			last = loc[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><blockquote>
<p>差分是前缀和的逆运算，它将区间修改转化为端点修改。</p>
</blockquote>
<h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p>定义差分数组<code>D[]</code>，<code>D[i]=a[i]-a[i-1]</code>。</p>
<p><strong>查询：</strong></p>
<p>$$<br>a[k]&#x3D;\sum^{k}_{i&#x3D;1}D[i]<br>$$</p>
<p>也就是对差分数组求前缀和。</p>
<p><strong>区间修改：</strong></p>
<p>将区间$[l,r]$的每个元素都加$d$，</p>
<p>只需要：</p>
<p><code>D[l]+=d,D[r+1]-=d</code></p>
<p>这样就可以保证：</p>
<ol>
<li>$1\le{x}&lt;l$，$a[x]$不变。</li>
<li>$l\le{x}\le{r}$，$a[x]$增加$d$。</li>
<li>$r&lt;x\le{n}$，$a[x]$不变。</li>
</ol>
<p>$n$个数$m$次区间修改+一次查询复杂度：$O(mn)\to{O(m+n)}$</p>
<p><em>差分对于单点查询不是很高效，这时候就需要线段树或者树状数组了。</em></p>
<hr>
<h3 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h3><p><a class="link"   href="https://acm.hdu.edu.cn/showproblem.php?pid=1556" >HDU1556<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> D[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(D,<span class="number">0</span>,<span class="built_in">sizeof</span>(D));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l,r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            D[l]++,D[r<span class="number">+1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            D[i]=D[i<span class="number">-1</span>]+D[i];</span><br><span class="line">            <span class="keyword">if</span>(i!=n) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,D[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,D[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><blockquote>
<p>点扩展为面</p>
</blockquote>
<p>差分数组的前缀和：</p>
<p>$a[i][j]$代表点$(1,1)$到点$(i,j)$的矩形的面积（所有元素之和）；</p>
<p>差分：</p>
<p><code>D[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]</code></p>
<p>a就是大矩形，D就是大矩形中的小矩形。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307121530704.webp"
                     
                ></p>
<p><strong>区间修改</strong></p>
<p>将点$(x_1,y_1),(x_2,y_2)$围成的一段区间中每个元素都加上$d$，需要：</p>
<ul>
<li><code>D[x1][y1]+=d</code></li>
<li><code>D[x1][y2+1]-=d</code></li>
<li><code>D[x2+1][y1]-=d</code></li>
<li><code>D[x2+1][y2+1]+=d//被减了两次的地方需要加回来一次</code></li>
</ul>
<p>处理的时候可以直接把$D$数组当成$a$来更新，以此节省空间，因为是从前往后更新，后面的值需要前面的值，前面的值不需要后面的值，所以互不影响。</p>
<h3 id="习题：-1"><a href="#习题：-1" class="headerlink" title="习题："></a>习题：</h3><p><a class="link"   href="https://www.luogu.com.cn/problem/P3397" >P3397<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> D[<span class="number">5005</span>][<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        D[x1][y1]+=<span class="number">1</span>;</span><br><span class="line">        D[x1][y2<span class="number">+1</span>]-=<span class="number">1</span>;</span><br><span class="line">        D[x2<span class="number">+1</span>][y1]-=<span class="number">1</span>;</span><br><span class="line">        D[x2<span class="number">+1</span>][y2<span class="number">+1</span>]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            D[i][j]+=D[i<span class="number">-1</span>][j]+D[i][j<span class="number">-1</span>]-D[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,D[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中，计算前缀和可以这样替换：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        D[i][j<span class="number">+1</span>]+=D[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        D[i<span class="number">+1</span>][j]+=D[i][j];</span><br></pre></td></tr></table></figure></div>

<p>即横向纵向分别处理前缀和。</p>
<p>也可以这样写：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        D[i][j]+=D[i][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        D[i][j]+=D[i<span class="number">-1</span>][j];</span><br></pre></td></tr></table></figure></div>

<p>二维前缀和的应用：</p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P2280" >P2280<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5001</span>;<span class="comment">//坐标范围：1~5001</span></span><br><span class="line"><span class="type">int</span> n,m,ans=<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> sum[<span class="number">5007</span>][<span class="number">5007</span>];<span class="comment">//防越界</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;v);</span><br><span class="line">        sum[++x][++y]+=v;<span class="comment">//将坐标范围由0~5000改为1~5001</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)<span class="comment">//二位前缀和，坐标范围内都需要处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;N;j++)</span><br><span class="line">            sum[i][j<span class="number">+1</span>]+=sum[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">            sum[i<span class="number">+1</span>][j]+=sum[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&lt;=N;i++)<span class="comment">//对于坐标范围内地毯式搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> p=sum[i][j]-sum[i-m][j]-sum[i][j-m]+sum[i-m][j-m];</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,p);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="二阶差分"><a href="#二阶差分" class="headerlink" title="二阶差分"></a>二阶差分</h2><p><a class="link"   href="https://white.fallingsakura.top/3298283925/" >这是一个链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p>很多时候我们并不关心元素的绝对大小，我们关心它们的相对大小，那么就可以对它们进行离散化处理。</p>
<p>离散化的具体步骤：</p>
<ol>
<li>排序</li>
<li>编号</li>
<li>归位</li>
</ol>
<p><strong>代码：</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span>&#123;</span><br><span class="line">    <span class="type">int</span> val,id;</span><br><span class="line">&#125;olda[N];</span><br><span class="line"><span class="type">int</span> newa[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(data x,data y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.val&lt;y.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;olda[i].val);</span><br><span class="line">        olda[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(olda<span class="number">+1</span>,olda<span class="number">+1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        newa[olda[i].id]=i;</span><br><span class="line">        <span class="keyword">if</span>(olda[i].val==olda[i<span class="number">-1</span>].val)</span><br><span class="line">            newa[olda[i].id]=newa[olda[i<span class="number">-1</span>].id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,newa[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>也可以不预处理出来，通过库函数排序、判重，用的时候二分查找即可。</p>
<p>这是<strong>保序</strong>的写法，也就是映射后元素之间大小关系不变。</p>
<p>若是不需要保序，那么 <code>map</code> 或者<em>哈希表</em>就都可以做，好写很多。</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><em>常见排序算法：</em></p>
<ul>
<li>选择</li>
<li>插入</li>
<li>冒泡</li>
<li>归并</li>
<li>快排</li>
<li>堆排</li>
<li>计数</li>
<li>基数</li>
<li>桶排</li>
<li><del>sort()</del></li>
</ul>
<h2 id="桶排"><a href="#桶排" class="headerlink" title="桶排"></a>桶排</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">arr_sort</span><span class="params">(<span class="type">int</span> *arr,<span class="type">int</span> n)</span> <span class="comment">// 数组地址，长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; maxValue)</span><br><span class="line">        &#123;</span><br><span class="line">            maxValue = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bucketCnt = <span class="number">10</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; buckets[bucketCnt];</span><br><span class="line">    <span class="type">int</span> bucketSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(maxValue)</span><br><span class="line">    &#123;</span><br><span class="line">        maxValue /= <span class="number">10</span>;</span><br><span class="line">        bucketSize *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bucketSize /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> idx = arr[i] / bucketSize;</span><br><span class="line">        buckets[idx].<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="built_in">int</span>(buckets[idx].<span class="built_in">size</span>())<span class="number">-1</span>; j &gt; <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[idx][j] &lt; buckets[idx][j<span class="number">-1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(buckets[idx][j], buckets[idx][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; bucketCnt; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">int</span>(buckets[i].<span class="built_in">size</span>()); ++j)</span><br><span class="line">            arr[k++] = buckets[i][j];</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">ArrSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxv;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        maxv = <span class="built_in">max</span>(maxv,arr[i]);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bcnt = <span class="number">10</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; buc[bcnt];</span><br><span class="line">    <span class="type">int</span> bsize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(maxv)</span><br><span class="line">    &#123;</span><br><span class="line">        maxv /= <span class="number">10</span>;</span><br><span class="line">        bsize *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bsize /= <span class="number">10</span>; <span class="comment">// 按照最大值的值域分为十份</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> idx = arr[i] / bsize; <span class="comment">// 先把元素丢到桶里</span></span><br><span class="line">        buc[idx].<span class="built_in">emplace_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="built_in">int</span>(buc[idx].<span class="built_in">size</span>())<span class="number">-1</span>; j &gt; <span class="number">0</span>; --j) <span class="comment">// 从新加入的位置开始遍历</span></span><br><span class="line">            <span class="keyword">if</span>(buc[idx][j] &lt; buc[idx][j<span class="number">-1</span>]) <span class="built_in">swap</span>(buc[idx][j], buc[idx][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">1</span>; i &lt; bcnt; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">int</span>(buc[i].<span class="built_in">size</span>()); ++j)</span><br><span class="line">            arr[k++] = buc[i][j];</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span>* a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*n<span class="number">+4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    a = <span class="built_in">ArrSort</span>(a,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 10 2093 293 281 3940</span></span><br></pre></td></tr></table></figure></div>

<p>先分桶，这里按照十个来分。</p>
<p>然后把元素丢到它对应的桶内，然后对桶内进行排序，这里使用插入排序。</p>
<p>然后按顺序合并即可。</p>
<h1 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h1><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p><code>next_permutation()</code>函数，该函数内前两个参数为左开右闭的一个排列区间的指针（如<code>s.begin(),s.end()</code>），返回值为<code>bool</code>类型，表示有无下一个排列，排列后的结果会返回原序列中并覆盖。</p>
<h1 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h1><blockquote>
<p>分块是一种高效的思想，常用来处理区间问题。</p>
</blockquote>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    st[i] = n / sq * (i - <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// st[i]表示i号块的第一个元素的下标</span></span><br><span class="line">    ed[i] = n / sq * i; <span class="comment">// ed[i]表示i号块的最后一个元素的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>sqrt 代表分的块的个数，每个块的长度不一定为 sqrt，例如$n&#x3D;12$。</p>
<p>但是序列长度不一定是完全平方数，所以我们把最后一小块归入到原来的最后一块中块。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">ed[sq]=n;</span><br></pre></td></tr></table></figure></div>

<p>然后就是为每个元素确定它所属于的块：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = st[i]; j &lt;= ed[i]; ++j)</span><br><span class="line">        bel[j] = i; <span class="comment">// 表示j号元素归属于i块</span></span><br></pre></td></tr></table></figure></div>

<p>处理每个块的大小：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; ++i)</span><br><span class="line">    size[i] = ed[i] - st[i] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><blockquote>
<p>线段树能做的，为什么我分块不行？</p>
</blockquote>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P3372" >P3372 【模板】线段树 1<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+8</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">block</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> st,ed,sum,add;</span><br><span class="line">&#125;e[N&gt;&gt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> n,m,bel[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sq=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sq;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        e[i].st=n/sq*(i<span class="number">-1</span>)<span class="number">+1</span>;</span><br><span class="line">        e[i].ed=n/sq*i;</span><br><span class="line">    &#125;</span><br><span class="line">    e[sq].ed=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sq;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=e[i].st;j&lt;=e[i].ed;j++)</span><br><span class="line">            bel[j]=i,e[i].sum+=a[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bel[l]==bel[r])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i]+=x;</span><br><span class="line">            e[bel[l]].sum+=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=e[bel[l]].ed;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]+=x;</span><br><span class="line">        e[bel[l]].sum+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=e[bel[r]].st;i&lt;=r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]+=x;</span><br><span class="line">        e[bel[r]].sum+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=bel[l]<span class="number">+1</span>;i&lt;bel[r];i++)</span><br><span class="line">        e[i].add+=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bel[l]==bel[r])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">            s+=a[i]+e[bel[l]].add;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=e[bel[l]].ed;i++)</span><br><span class="line">        s+=a[i]+e[bel[i]].add;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=e[bel[r]].st;i&lt;=r;i++)</span><br><span class="line">        s+=a[i]+e[bel[r]].add;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=bel[l]<span class="number">+1</span>;i&lt;bel[r];i++)</span><br><span class="line">        s+=e[i].sum+e[i].add*(e[i].ed-e[i].st<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,x,y,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;k);</span><br><span class="line">            <span class="built_in">modify</span>(x,y,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>嗯，比线段树好看不少，代码也简洁，思维难度也不高。</p>
<p>不过它们都有区间标记这个小技巧。</p>
<h2 id="分块方式"><a href="#分块方式" class="headerlink" title="分块方式"></a>分块方式</h2><p><strong>第一种：</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    st[i] = n / sq * (i - <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// st[i]表示i号块的第一个元素的下标</span></span><br><span class="line">    ed[i] = n / sq * i; <span class="comment">// ed[i]表示i号块的最后一个元素的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里的 sq 为块的数量，根据块的数量来均摊块的长度，特别地，最后一个不完整的块将被归并到原来的最后的块中。</p>
<p>小优化：由于是 $\sqrt{n}$ 个块，因此可以开 $\frac{n}{2}$ 空间就足够。</p>
<p><strong>第二种：</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    id[i] = (i - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">    s[id[i]] += a[i];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>这个的 len 为块的长度，根据长度来决定块的个数。</p>
<hr>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/3023808606.html</url>
    <content><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">string str1;   <span class="comment">//默认构造函数</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;  <span class="comment">//传入string或者c_str</span></span><br><span class="line"><span class="function">string <span class="title">str3</span><span class="params">(<span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;  <span class="comment">//4个字符a构建成string</span></span><br><span class="line"><span class="function">string <span class="title">str4</span><span class="params">(str2, <span class="number">1</span>)</span></span>;  <span class="comment">//从str2的位置1开始构造</span></span><br><span class="line"><span class="function">string <span class="title">str5</span><span class="params">(str<span class="number">2.</span>begin(), str<span class="number">2.</span>end())</span></span>;  <span class="comment">//从str2的迭代器开始构造</span></span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl &lt;&lt; str3 &lt;&lt; endl&lt;&lt; str4 &lt;&lt; endl&lt;&lt;str5&lt;&lt;endl;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">aaaa</span><br><span class="line">bc</span><br><span class="line">abc</span><br></pre></td></tr></table></figure></div>

<h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">+=</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;str1&quot;</span>)</span></span>;</span><br><span class="line">str<span class="number">1.</span><span class="built_in">append</span>(<span class="string">&quot;123&quot;</span>);  <span class="comment">//直接添加字符串至尾部</span></span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">str<span class="number">1.</span><span class="built_in">append</span>(<span class="string">&quot;1230&quot;</span>, <span class="number">2</span>); <span class="comment">//从参数字符串起始位置开始添加2个字符到str1</span></span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;str2&quot;</span>)</span></span>;</span><br><span class="line">str<span class="number">1.</span><span class="built_in">append</span>(str2, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">//把str2的区间[0,1)的字符添加至str1</span></span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl &lt;&lt; str1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">str1123</span><br><span class="line">str112312</span><br><span class="line">str2</span><br><span class="line">str112312s</span><br></pre></td></tr></table></figure></div>

<h2 id="Push-Back"><a href="#Push-Back" class="headerlink" title="Push_Back"></a>Push_Back</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">a.<span class="built_in">puah_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;string1&quot;</span>)</span></span>;</span><br><span class="line">str<span class="number">1.</span><span class="built_in">erase</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">//删除指定区间</span></span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">str<span class="number">1.</span><span class="built_in">erase</span>(<span class="number">2</span>);  <span class="comment">//指定删除的起始位置，直至末尾</span></span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">tring1</span><br><span class="line">tr</span><br></pre></td></tr></table></figure></div>

<h2 id="弹出"><a href="#弹出" class="headerlink" title="弹出"></a>弹出</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">str.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure></div>

<h2 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">str.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure></div>

<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">str.<span class="built_in">find</span>(<span class="string">&quot;tata&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;string1string1&quot;</span>)</span></span>;</span><br><span class="line">string temp = str<span class="number">1.</span><span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//指定区间的字串</span></span><br><span class="line">cout &lt;&lt; temp &lt;&lt; endl;</span><br><span class="line">string temp2 = str<span class="number">1.</span><span class="built_in">substr</span>(<span class="number">1</span>);  <span class="comment">//从指定位置开始切割至尾部</span></span><br><span class="line">cout &lt;&lt; temp2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">tr</span><br><span class="line">tring1string1</span><br></pre></td></tr></table></figure></div>

<h2 id="数字转换"><a href="#数字转换" class="headerlink" title="数字转换"></a>数字转换</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;124&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">stoi</span>(str1) &lt;&lt; endl; <span class="comment">//转为整数</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">stof</span>(<span class="built_in">string</span>(<span class="string">&quot;124.3&quot;</span>)) &lt;&lt; endl;<span class="comment">//转为浮点型</span></span><br><span class="line">string str = <span class="built_in">to_string</span>(<span class="number">124</span>); <span class="comment">//数字转为字符串</span></span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str = <span class="built_in">to_string</span>(<span class="number">13.4</span>);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div>

<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h2><p>比较两个字符串。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> op[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcmp</span>(op, <span class="string">&quot;osne&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>相等，返回值为 0</p>
<p>前者大于后者，返回值为正数</p>
<p>前者小于后者，返回值为负数</p>
<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><blockquote>
<p>推荐阅读：<a class="link"   href="https://zhuanlan.zhihu.com/p/105629613" >算法学习笔记(13): KMP算法<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<p>KMP 是一种字符串匹配算法，它可以在一个字符串(S)中找出所有另一个字符串(T)的出现。</p>
<p>如果是暴力匹配的话，遇到不匹配的一个字符，就得把T字符串相对S向右移动一位，同时将T指针归零，S指针与T对齐进行重新匹配，如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202308121137853.webp"
                      alt="image.png"
                ></p>
<p>但是这样极端情况下复杂度会达到 $O(nm)$，是无法接受的，于是 KMP 算法应运而生，它可以将已经匹配的部分进行重复利用，而不是像暴力那样傻傻的清零。</p>
<p>KMP 算法中定义了一个 $pmt$ 数组，$pmt_i$ 代表字符串的前 $i+1$ 位（其实就是 $S_{0\sim{i}}$，因为字符串下标是从 0 开始的）<strong>的 Border 长度</strong>。</p>
<p>Border 为一个字符串<strong>前缀与后缀最长匹配的部分</strong>，例如 $\text{abacaba}$，它的 Border 就是 $\text{aba}$，长度为 3。</p>
<p>所以每次匹配失败之后就可以把T串已经匹配的部分变为它的 Border，假如T串当前匹配到下标为$i$，那么就相当于把T串向右平移了 $i-strlen(Border_i)+1$ 位，这样就可以利用之前已经匹配的部分继续匹配而无需归零。</p>
<p>注意 Border 的长度不超过自身字符串的长度。</p>
<p>代码实现大概是这样的：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j&amp;&amp;s[i]!=t[j]) j=pmt[j<span class="number">-1</span>];<span class="comment">//不断向前跳，如果没有的话，最后会跳到0</span></span><br><span class="line">    <span class="keyword">if</span> (s[i]==t[j]) j++;<span class="comment">//当前位匹配</span></span><br><span class="line">    <span class="keyword">if</span> (j==t.<span class="built_in">length</span>())<span class="comment">//已经完全匹配了一次，利用已匹配的部分去找下个完全匹配</span></span><br><span class="line">        j=pmt[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>举个例子，$S&#x3D;\text{ABCABACABCAB},T&#x3D;\text{ABCAB}$，先预处理出 $T$  对应的 $pmt$：</p>
<table>
<thead>
<tr>
<th align="center">$pmt$</th>
<th align="center">$Border$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2</td>
</tr>
</tbody></table>
<p>然后进行匹配，设 $i$ 为 $S$ 的指针，$j$ 为 $T$ 的指针，那么当 $i&#x3D;j&#x3D;4$ 的之后第一次匹配完成，这时候 $i&#x3D;4,j&#x3D;5,j&#x3D;pmt_{j-1}&#x3D;2$，然后 $i&#x3D;5$，就可以把 $AB$ 这个前缀给利用起来了，注意 $j$ 始终是待匹配项，要比已经匹配的多 $1$，而当 $j&#x3D;length_t$ 的时候，说明前 $j$ 个都已经匹配完了，现在在看下一个字符，所以是要跳回到 $pmt_{j-1}$，其中因为字符串从 $0$ 开始存在不少细节，请自行理解。</p>
<p>那么 $pmt$ 怎么求呢？</p>
<p>相当于拿自己和自己进行匹配，代码如下。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;t.<span class="built_in">length</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;t[i]!=t[j]) j=pmt[j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span> (t[i]==t[j]) j++;</span><br><span class="line">    pmt[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当然也有另一种写法，是存最长 Border 的右端点下标，记为 $nxt_i$，与存长度类似，拿例题举例：</p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P3435" >P3435<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> a[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> nxt[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="built_in">memset</span>(nxt,<span class="number">-1</span>,<span class="built_in">sizeof</span>(nxt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">-1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">-1</span>&amp;&amp;a[i]!=a[j<span class="number">+1</span>]) j=nxt[j];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[j<span class="number">+1</span>]) j++;</span><br><span class="line">        nxt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(nxt[j]&gt;<span class="number">-1</span>) j=nxt[j];</span><br><span class="line">        <span class="keyword">if</span>(nxt[i]&gt;<span class="number">-1</span>) nxt[i]=j;</span><br><span class="line">        ans+=i-j;</span><br><span class="line">        j=i<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> a[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> pmt[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;a[i]!=a[j]) j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[j]) j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(pmt[j<span class="number">-1</span>]) j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(pmt[i]) pmt[i]=j;</span><br><span class="line">        ans+=i-j<span class="number">+1</span>;</span><br><span class="line">        j=i<span class="number">+2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这道题解法就是对每个前缀找出它的最小 Border 的长度，然后拿当前前缀长度减去这个最小 Border 的长度，再把每个前缀的答案加起来就是最后的答案，细节见代码，有助于加深对 KMP 两种写法的理解。</p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P2375" >P2375动物园<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> a[N];</span><br><span class="line"><span class="type">int</span> nxt[N],num[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a<span class="number">+1</span>);</span><br><span class="line">        ans=<span class="number">1</span>;</span><br><span class="line">        num[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">strlen</span>(a<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=l;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&amp;&amp;a[i]!=a[j<span class="number">+1</span>]) j=nxt[j];</span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[j<span class="number">+1</span>]) j++;</span><br><span class="line">            nxt[i]=j;</span><br><span class="line">            num[i]=num[j]<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=l;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&amp;&amp;a[i]!=a[j<span class="number">+1</span>]) j=nxt[j];</span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[j<span class="number">+1</span>]) j++;</span><br><span class="line">            <span class="keyword">while</span>((j&lt;&lt;<span class="number">1</span>)&gt;i) j=nxt[j];</span><br><span class="line">            ans=ans*(num[j]<span class="number">+1</span>)%mod;</span><br><span class="line">            <span class="comment">// printf(&quot;%d\n&quot;,num[j]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=l;i++) printf(&quot;%d\n&quot;,num[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>先把所有的后缀数量和都求出来，这个可以通过递推关系求出，即$sum_i&#x3D;sum_{nxt_i}+1$。</p>
<p>然后再匹配处理一次，匹配的过程中的时候对于每一个$j$，一旦超过当前字符串长度的一半，就往前跳直到长度小于字符串的一半并累加答案。</p>
<h1 id="EXKMP-Z"><a href="#EXKMP-Z" class="headerlink" title="EXKMP(Z)"></a>EXKMP(Z)</h1><blockquote>
<p>Z 算法又被叫做扩展 KMP 算法，其核心是 Z 函数。<br><a class="link"   href="https://zhuanlan.zhihu.com/p/403256847" >图片来源<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<p>$Z_i$定义为字符串与$i$位置到字符串末尾与整个字符串的最长公共前缀的长度，即处理每一个后缀与原字符串的 LCP（最长公共前缀）。</p>
<p>贴一张图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202308141535579.webp"
                      alt="image.png"
                ></p>
<p>特别地，令$Z_0&#x3D;0$。</p>
<p>假设$Z_i\ne0$，定义区间$[i,i+Z_i-1]$为一个$\text{Z-Box}$，那么$Z-Box$一定是这个字符串的一个前缀。</p>
<p>我们从左向右枚举$i$，并维护右端点最大的 $Z-Box$ 和它对应的左端点，这里保证$l\le{i}$。</p>
<p>那么就有以下三种情况：</p>
<ul>
<li>$i&gt;r$，这说明我当前的$Z-Box$左端点都比之前的右端点要大，所以没有什么可以利用的，就只能暴力往后枚举出当前的 $Z-Box$ 并维护信息。</li>
<li>$i\le{r}$，那么就可以对已经求出的 $lcp$ 进行利用，见下图解释：</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307302329248.webp"
                      alt="image.png"
                ></p>
<p>黑色为原序列，我现在要求每一个后缀与原序列的 lcp，即最大公共前缀。</p>
<p>比如我现在要求粉色点的 lcp，</p>
<p>但是发现这个点在当前最大lcp的右端点的范围内（红色线），即我们知道了灰色与黑色的 lcp，而灰色与蓝色的粉色部分又相同，于是蓝色和黑色的粉色部分也相同。</p>
<p>而对于粉色部分，我们已经知道了绿色与的 lcp，绿色&lt;粉色，相同位置的绿色&#x3D;粉色，于是绿色的 lcp 就可以被粉色点继承；假如绿色&gt;粉色，但是超出部分在蓝色部分中不一定相同，因此最多能继承到粉色的边界处，因此绿色的 lcp的右端点下标要与粉色右端点下标取$\min$后继承。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> z[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    z[<span class="number">0</span>]=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(z[i-l]&lt;r-i<span class="number">+1</span>)<span class="comment">//当前已经相同的部分比已知lcp要大</span></span><br><span class="line">            z[i]=z[i-l];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            z[i]=<span class="built_in">max</span>(r-i<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span>(i+z[i]&lt;n&amp;&amp;s[z[i]]==s[i+z[i]]) z[i]++;</span><br><span class="line">            l=i,r=i+z[i]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意 $l,r$ 的定义，他们的初始值要比初始变量少 1。</p>
<p>这个过程中，$r$ 是单调不减的，每次内层循环都会使 $r$ 加一，所以时间复杂度为$O(n)$。</p>
<h1 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h1><blockquote>
<p>一种解决回文串问题的算法</p>
</blockquote>
<p>回文串分为奇回文串和偶回文串，而偶回文串不存在固定的回文中心，因此就要进行一些处理，在字符间加上一些其他字符，比如<code>#</code>或者<code>$</code>。</p>
<p>奇回文串$\text{abcba}&#x3D;\text{$a$b$c$b$a$}$</p>
<p>这样对于一个偶回文串$\text{abccba}$，就可以处理为$\text{$a$b$c$c$b$a$}$，这样就可以用奇回文串的处理方法来处理偶回文串了。</p>
<p>设数组 $d_i$ 为以 $s_i$ 为中心的奇回文串的数量，长度分别为 $1,3,\dots,2d_i-1$，Manacher 就可以 $O(n)$ 处理出这个数组。</p>
<p>而以 $i$ 为中心的最长回文串的长度就为 $d_i-1$。</p>
<p>Manacher 的思想与 Z 算法很像，都是维护了一个最远的右端点，不过在 Manacher 里维护的是右端点最大的奇回文串，</p>
<p>当枚举到一个 $i$ 时，我们进行分类讨论：</p>
<ul>
<li>$i&gt;r$，那就暴力计算$d_i$，并维护$l,r$。</li>
<li>$i\le{r}$，那么就可以找这个$r$所在回文串的回文中心，这样就可以找到它的对称点，设这个对称点为 $j$，如果以 $j$ 为回文中心的回文串左端点大于 $l$，那么说明 $d_j$ 是被当前这个回文串完全包含的了，而对称位置对应相等，因此可以直接继承，$d_i&#x3D;d_j$。<ul>
<li>如果以 $j$ 为回文中心的回文串左端点小于等于 $l$，那么只能知道 $i$ 的回文串右端点至少为 $j-l+1$或者 $r-i+1$，剩余部分可以暴力解决。</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> d[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">-1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=l+r-i;<span class="comment">//对称点</span></span><br><span class="line">        <span class="type">int</span> dj=j&gt;=<span class="number">0</span>?d[j]:<span class="number">0</span>;<span class="comment">//不能越界</span></span><br><span class="line">        d[i]=<span class="built_in">max</span>(<span class="built_in">min</span>(dj,r-i<span class="number">+1</span>),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(j-dj&lt;l)<span class="comment">//j-dj+1&lt;=l</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i-d[i]&gt;=<span class="number">0</span>&amp;&amp;i+d[i]&lt;n&amp;&amp;s[i-d[i]]==s[i+d[i]]) d[i]++;</span><br><span class="line">            l=i-d[i]<span class="number">+1</span>,r=i+d[i]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了使自己本身也能被算上，所以初始 $r$ 为-1。</p>
<p>这个过程中，$r$ 是单调不减的，每次内层循环都会使 $r$ 加一，所以时间复杂度为$O(n)$。</p>
<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><p>字典树，可以理解为 $n$ 叉树，$n$ 取决于字符的种类。</p>
<p>模板：</p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P8306#submit" >P8306<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> t,cnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> nxt[N][<span class="number">80</span>];</span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line"><span class="type">char</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// memset(nxt,0,sizeof(nxt));</span></span><br><span class="line">    <span class="comment">// memset(val,0,sizeof(val));</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        val[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">77</span>;j++)</span><br><span class="line">            nxt[i][j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[cur][c-<span class="string">&#x27;0&#x27;</span>]) nxt[cur][c-<span class="string">&#x27;0&#x27;</span>]=++cnt;</span><br><span class="line">        cur=nxt[cur][c-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        val[cur]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[cur][c-<span class="string">&#x27;0&#x27;</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cur=nxt[cur][c-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val[cur];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n,q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string s;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">            s=a;</span><br><span class="line">            <span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string s;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">            s=a;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">init</span>(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例题：</p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P2580" >P2580<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,cnt,q;</span><br><span class="line"><span class="type">char</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> nxt[<span class="number">1000005</span>][<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(nxt,<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt));</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[cur][c-<span class="string">&#x27;a&#x27;</span>]) nxt[cur][c-<span class="string">&#x27;a&#x27;</span>]=++cnt;</span><br><span class="line">        cur=nxt[cur][c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[cur][c-<span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cur=nxt[cur][c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        vis[cur]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(vis[nxt[cur][i]]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(vis[cur]&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">        string s=a;</span><br><span class="line">        <span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">        string s=a;</span><br><span class="line">        <span class="type">int</span> op=<span class="built_in">query</span>(s);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;WRONG\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;REPEAT\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;OK\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="可持久化-Trie-树"><a href="#可持久化-Trie-树" class="headerlink" title="可持久化 Trie 树"></a>可持久化 Trie 树</h2><p>对于属于修改的但是已有节点，复制粘贴。</p>
<p>对于不属于修改但是原来有的节点，直接连接（相当于复制粘贴的时候直接把属性复制了过来）。</p>
<p>对于属于修改的新节点，新建一个节点。</p>
<p>都是对于上一个版本的操作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310042006238.webp"
                      alt="image.png"
                ></p>
<p>每次先得到上一个版本，然后开一个新的节点，把根节点先克隆过来。</p>
<p>然后遍历每个节点，如果有就复制粘贴，没有就新建。</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/258/" >AcWing256<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>怎么判断左界？</p>
<p>记录一下每个节点的子树里的下标最大值即可。</p>
<p>怎么判断右界？看第 $r$ 个版本即可，可持久化。</p>
<p>前缀和处理：</p>
<p>$ans&#x3D;s_N\oplus{s_{p - 1}}\oplus x$</p>
<p>于是我们在 $l\sim r$ 中贪心地找到这样一个 $p - 1$ 即可，也就是在 $l-1\sim r-1$ 中找一个 $p$，使得他们的异或值最大。</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>对拍</title>
    <url>/835730ca.html</url>
    <content><![CDATA[<h1 id="对拍"><a href="#对拍" class="headerlink" title="对拍"></a>对拍</h1><p>参考：<a class="link"   href="https://www.cnblogs.com/EdisonBa/p/13509379.html" >参考文章1<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> <a class="link"   href="https://www.cnblogs.com/EdisonBa/p/17589796.html" >参考文章2<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/timeb.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Rand</span><span class="params">(ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = INT_MAX;</span><br><span class="line">    <span class="keyword">return</span> ans * <span class="built_in">rand</span>() % mod + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_timeb</span> T;</span><br><span class="line">    _ftime(&amp;T);</span><br><span class="line">    <span class="built_in">srand</span>(T.millitm); <span class="comment">// T.millitm 为毫秒级随机数的种子</span></span><br><span class="line">    <span class="function">mt19937 <span class="title">rd</span><span class="params">(T.millitm)</span></span>; </span><br><span class="line">    ofstream file;</span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">&quot;a.in&quot;</span>);</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">rd</span>(), b = <span class="built_in">rd</span>();</span><br><span class="line">    file &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b;</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>或者：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/timeb.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Rand</span><span class="params">(ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = INT_MAX;</span><br><span class="line">    <span class="keyword">return</span> ans * <span class="built_in">rand</span>() % mod + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_timeb</span> T;</span><br><span class="line">    _ftime(&amp;T);</span><br><span class="line">    <span class="built_in">srand</span>(T.millitm);</span><br><span class="line">    <span class="function">mt19937 <span class="title">rd</span><span class="params">(T.millitm)</span></span>;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">rd</span>(), b = <span class="built_in">rd</span>();</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="待测"><a href="#待测" class="headerlink" title="待测"></a>待测</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.ans&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="对拍-1"><a href="#对拍-1" class="headerlink" title="对拍"></a>对拍</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ok = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cd E:/CodeProgram/CPP/Makers/Test/&amp;g++ std.cpp -o std.exe&amp;g++ baoli.cpp -o baoli.exe&amp;g++ make.cpp -o make.exe&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;cd E:/CodeProgram/CPP/Makers/Test/&amp;make.exe&amp;baoli.exe&quot;</span>);</span><br><span class="line">        <span class="type">double</span> begin = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;cd E:/CodeProgram/CPP/Makers/Test/&amp;std.exe&quot;</span>);</span><br><span class="line">        <span class="type">double</span> end = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="type">double</span> t = end - begin;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">system</span>(<span class="string">&quot;cd E:/CodeProgram/CPP/Makers/Test/&amp;fc a.out a.ans&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;测试点 #%d Wrong Answer\n&quot;</span>,i);</span><br><span class="line">            fstream file;</span><br><span class="line">            <span class="type">int</span> a, b ;</span><br><span class="line">            file.<span class="built_in">open</span>(<span class="string">&quot;E:/CodeProgram/CPP/Makers/Test/a.in&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(file.<span class="built_in">good</span>() &amp;&amp; file.<span class="built_in">is_open</span>())</span><br><span class="line">                file &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入：%d %d\n\n&quot;</span>, a, b);</span><br><span class="line">            file.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t &gt; <span class="number">1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;测试点 #%d Time Limited Exeeded 用时 %.1fms\n\n&quot;</span>, i, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;测试点 #%d Accepted 用时 %1.lfms\n\n&quot;</span>, i, t);</span><br><span class="line">            ok++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------------------------\n\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">double</span> res = <span class="number">100.0</span> * ok / n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共 %d 组测试数据，AC 数据 %d 组，得分：%.1lf。\n&quot;</span>, n, ok, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>易错&amp;问题</title>
    <url>/d00d621a.html</url>
    <content><![CDATA[<h1 id="不知道放哪里的知识点"><a href="#不知道放哪里的知识点" class="headerlink" title="不知道放哪里的知识点"></a>不知道放哪里的知识点</h1><blockquote>
<p><font color=#3198C7 size=5>一个难忘的夜晚。</font></p>
</blockquote>
<ol>
<li><code>getchar()</code>若在读入时使用，在之前和之后一定要把多余的空格换行符用<strong>while</strong>读取完，因为你不知道<strong>可爱的出题人</strong>会在数据里给你塞一堆你看不见的奇奇怪怪的符号！</li>
<li>类似于八皇后问题，如果网格图中只走对角线的话，如果是左下对角线，那么横纵坐标之和不变，如果是右下对角线，那么横纵坐标之差不变，扩展出去，其实就是奇偶性不变，如果要标记的话，作差要记得加上 $n$ 放置负数下标。</li>
<li><code>\</code>在<code>cpp</code>中属于转义字符，若要使用需要这么写：<code>\\</code>。</li>
<li>无向图不要被题目$m$的范围所迷惑，因为是建双向边，因此要开两倍空间！</li>
<li>Tarjan求割边的时候不能在输入时确定父子关系，因为会导致一个点哪也取不了（都是它的父亲怎么走），所以要在遍历的时候再标记它在树上真正的父亲。</li>
<li>对于取模的问题，一定要时时刻刻想着取模，<strong>加法要取模，乘法要取模</strong>！</li>
<li>如果你在计算时没有加入<code>1ll*</code>的话，那么你的函数传参就要是<code>long long</code>，例如<code>void eval(node &amp;t,ll add,ll mul)</code></li>
<li>倍增求LCA<strong>一定</strong>要记得把零号节点的深度初始化为-1，防止跳到0号节点，因为不存在的<strong>零号节点的深度和根节点深度一样，默认都是零</strong>，或者其它的解决办法就是把根节点深度从1开始算。</li>
<li>MLE想想有没有可能是递归爆栈。</li>
<li>最长不上升连续子序列的数量等于该序列最长上升子序列的长度。</li>
<li>树状数组和线段树查询最长上升子序列时初始返回变量要设成0！！！避免进入不了循环而返回-1，或者判断不让0进入查询。</li>
<li>滚动数组优化每次更新之前记得把当前这维<code>memset</code>为初始值！</li>
<li>不一定是左边打不到右边右边就一定打不到左边，注意双向判断。</li>
<li>树形DP时要先合并两子树信息再合并两子树大小，防止枚举过量。</li>
<li>预处理次幂的时候一定不要忘记<strong>零次幂</strong>！！！！</li>
<li><code>long long</code> 下进行 <code>memset</code> 此时的 <code>0x3f</code> 不再是 <code>0x3f3f3f3f</code>，而是 <code>0x3f3f3f3f3f3f3f3f</code>。</li>
<li>非递归快速幂的临时变量一定要开 <code>long long</code></li>
<li>递推逆元时，用多少就预处理多少，不然会导致大于 $p$ 的部分阶乘的逆元全都为 0，然后倒着往前推的时候导致所有阶乘的逆元都为 0，导致求出的答案也全是 0.</li>
<li><strong>数组类型</strong>一定不要写错！！！！！！为此ＤＥＢＵＧ 了一小时。</li>
<li>求 gcd 的函数返回值一定不要忘了函数名，已经错了两次了。</li>
<li>SB UVA 有着极其严格的格式要求，不要被卡格式了哦~</li>
<li>模二意义下的加法相当于异或。</li>
<li>使用 <code>if</code> 时，cpu 会在空闲时间进行分支预测，提前预处理部分指令，当结果为 <code>false</code> 时，预处理结果作废清除，反而会降低效率，所以 <code>if(q[i + 1] != q[i] + 1) tot++;</code> 会比 <code>tot += (q[i + 1] != q[i] + 1);</code> 要慢，尤其是在数量级较大的时候（比如搜索）影响很大，值得注意。</li>
<li>写树的时候尽量不要用单点修改来建树，最好有一个建树的函数，否则可能写可持久化的时候会寄掉。</li>
<li>比赛时，空间复杂度一律为 O(能开多大开多大)</li>
<li>不要把可能用到的变量当作 <code>while</code> 的终止条件，比如 <code>while(n--)</code>，因为后面可能会用到这些变量。</li>
<li>对于<a class="link"   href="https://www.luogu.com.cn/discuss/705534" >线段树的区间加法<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>：修改叶子节点之前一定要下传标记，这样保证了叶子节点的信息始终是正确的，这样再次修改完叶子节点后上传得到的根节点的信息也是正确的，否则根节点就会上传时被覆盖为错误的信息。</li>
<li><a class="link"   href="https://www.luogu.com.cn/discuss/706148" >线段树区间覆盖最大值问题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>树链剖分注意考虑重边以及自环，以及你加的虚拟源点，会影响数据结构的右界。</li>
<li><code>lower_bound</code> 返回的是大于等于某数的最小的下标，那么 <code>lower_bound - 1</code> 就是小于某数的最大下标；同理，<code>upper_bound</code> 返回的是大于某数的最小的下标，那么 <code>upper_bound - 1</code> 就是小于等于某数的最大的下标。</li>
<li><code>while(x--)</code> 后，<code>x</code> 的值为 -1，先判断为 0 退出循环，然后再执行 <code>--</code>。</li>
<li><del>数位</del> 各种 DP 一定不要忘了初始化 <code>f</code> 数组为 -1.</li>
<li><code>0b</code> 前缀表示二进制，<code>0x</code> 前缀表示十六进制。</li>
<li><code>string</code> 不要用 <code>&#39;L&#39; + s</code> 拼接，这样复杂度是 $O(n)$ 的，如果要在前面插入，可以用 <code>s += &#39;L&#39;</code>，然后 <code>reverse</code> 一下。</li>
<li>有符号变量溢出属于未定义行为，而无符号变量溢出不属于，它自然溢出相当于对上界取模。</li>
<li>不要使用 <code>lock</code> 当变量名。</li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li>01BFS 为什么可以优化复杂度啊。 没有这种说法，01BFS是只有边权0和1的情况下对堆的一个优化，双端队列优化SPFA属于是玄学优化，任何SPFA都可以被卡成$O(nm)$。</li>
<li>SPFA 什么情况下一个点会进队两次，出现了环吗？个人认为至少有弱连通环，比如一个点先被一条短点的路径遍历到了，然后又被一条长一点的路径遍历到了，这样就更新了两次。</li>
<li>Tarjan什么时候要判断自环和重边啊。</li>
<li>为什么线性筛法时某个数一定是被它最小的质因子筛掉的。</li>
<li>通过 <code>search: #Q</code> 看一些问题。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309012216670.webp"
                     
                ></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Q&amp;A</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue Note</title>
    <url>/9f08e17f.html</url>
    <content><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><blockquote>
<p><a class="link"   href="https://cn.vuejs.org/" >Vue.js 中文文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><blockquote>
<p>什么是 API ？</p>
<p>API（<strong>Application Programming Interface</strong>，应用程序接口）是一组定义和协议，用于构建和集成软件应用程序。API 允许不同软件系统之间进行通信和数据交换。通过使用 API，开发者可以利用现有的<strong>功能</strong>，而无需从头开始编写代码。</p>
</blockquote>
<h3 id="选项式-API"><a href="#选项式-API" class="headerlink" title="选项式 API"></a>选项式 API</h3><p>选项API是Vue 2中使用的传统方法，通过在组件对象中定义各种选项来组织组件逻辑，如<code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code>等。</p>
<p>示例：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">doubleCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="title function_">count</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Count changed from <span class="subst">$&#123;oldValue&#125;</span> to <span class="subst">$&#123;newValue&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h3><p>组合式API是Vue 3中引入的新特性，提供了一种更灵活的方式来组织和复用组件逻辑。通过使用<code>setup</code>函数和组合函数（Composition Functions），可以将逻辑分块，便于复用和测试。</p>
<p>示例：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      count.<span class="property">value</span>++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> doubleCount = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(count, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Count changed from <span class="subst">$&#123;oldValue&#125;</span> to <span class="subst">$&#123;newValue&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      increment,</span><br><span class="line">      doubleCount</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>响应式（reactivity）是指系统能够自动监测数据的变化并做出相应的反应。例如，当数据变化时，Vue 会自动重新渲染相关的 DOM 元素，以确保用户界面始终与数据保持同步。这种能力是 Vue 的核心特性之一，使得开发过程更加简洁和高效。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;scirpt setup&gt;</span><br><span class="line">// JS</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">// HTML</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">// CSS</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></div>

<p>每一个 <code>.vue</code> 文件是一个组件，不同的组件拼接成一个网页应用。</p>
<p>里面有三部分，分别是我们熟悉的 <code>HTML CSS JS</code>。</p>
<p>在之前的写法中，我们需要告诉 Vue 这是个组件以及定义组件逻辑的地方，如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">	setup() &#123;</span><br><span class="line">	//</span><br><span class="line">	//</span><br><span class="line">	//</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p><code>setup</code> 用于初始化组件的逻辑、状态、数据，返回值将给模板使用。</p>
<p>但在 Vue3 中，我们有更方便的定义数据和方法的方式：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>这样的写法就方便许多。</p>
<p>当我们想在某一个 <code>.vue</code> 文件中导入其它组件时，这样写：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;name&#125; form &#x27;&#123;path&#125;&#x27;</span><br></pre></td></tr></table></figure></div>

<p><code>&#123;name&#125;</code> 是组件的名字，可以任意取，<code>&#39;&#123;path&#125;&#39;</code> 是一个字符串，代表组件所在路径。</p>
<p>使用时，在 <code>&lt;template&gt;</code> 中使用 <code>&lt;&#123;name&#125;&gt;&lt;/&#123;name&#125;&gt;</code> 即可，像是你自定义了一个新的 HTML 标签。</p>
<p>当我们只想给 CSS 添加到当前组件时，可以给 <code>&lt;style&gt;</code> 添加一个属性 <code>scoped</code>。</p>
<h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><p>在 <code>script</code> 中，创建变量需要先引入 <code>ref/reactive</code> API。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; ref, reactive &#125; from &#x27;vue&#x27;</span><br></pre></td></tr></table></figure></div>

<p>然后创建变量：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const str = ref()</span><br></pre></td></tr></table></figure></div>

<p><code>ref()</code> 内是变量值，可以是字符串、数组、数字、对象等等。</p>
<p>返回的是一个带有 <code>value</code> 属性的对象。</p>
<p>在 <code>script</code> 内访问变量值时，需要使用 <code>var.value</code>，而在 <code>template</code> 中访问变量值时，只需要 <code>var</code>，比如一个标题可以是 <code>&lt;h2&gt;&#123;&#123; str &#125;&#125;&lt;/h2&gt;</code>。这样标题的内容就可以随着变量的变化而变化。</p>
<p><code>ref</code> 创建的是单一的<strong>值</strong>，而 <code>reactive</code> 创建的是更为复杂的深度响应式<strong>对象</strong>，里面有很多键值对。</p>
<p>而由于返回的是一个对象，所以哪怕这个变量在定义时为 <code>const</code>，你依然可以修改它的 <code>value</code>。</p>
<p>如果想要创建一个常量的话，可以使用 <code>ref(Object.freeze(&#123;value&#125;))</code></p>
<p>也可以使用 <code>computed</code> API，它可以用于创建一个计算属性，计算属性的值会自动缓存，只有它里面的变量发生变化时才会重新计算，那么我们只需要让里面没有变量就可以实现返回一个常量。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const computeValue = computed(() =&gt; &#x27;This is a computed constant&#x27;);</span><br></pre></td></tr></table></figure></div>

<h2 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; watch &#125; from &#x27;vue&#x27;;</span><br></pre></td></tr></table></figure></div>

<p><code>watch()</code> 是一个方法，第一个参数是监听的变量，第二个参数是执行的函数。</p>
<p>当这个变量的值发生变化时，函数就会执行一次。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch(object, add(oldValue, newValue), &#123; &#125;)</span><br></pre></td></tr></table></figure></div>

<p>同时这个执行的函数可以传入两个参数，一个是监听得到的新值，另一个是旧值。</p>
<p>监听的可以是普通响应式变量（ref），也可以是计算属性（computed），也可以是一个 <code>getter</code> 函数用于监听复杂的表达式，也可以监听多个值，打包成一个数组即可。</p>
<p>当监听的元素为一个对象时，修改对象中的某一个值，并不会触发监听函数。</p>
<p>如果想监听对象中的值，可以再加入一个参数<strong>选项对象</strong>：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch(object, add(oldValue, newValue), &#123; deep: true &#125;)</span><br></pre></td></tr></table></figure></div>

<p>一个对象 <code>&#123; deep: true &#125;</code>，此为深度监听。</p>
<p>选项对象还有的属性是：</p>
<ul>
<li><code>immediate</code>：在监听器初始化时就会执行一次回调函数，默认为 <code>false</code></li>
<li><code>flush</code>：执行回调函数的时机，可以是如下值：<ul>
<li><code>&quot;pre&quot;</code>：在视图更新之前调用（默认值）。</li>
<li><code>&quot;post&quot;</code>：在视图更新之后调用。</li>
<li><code>&quot;sync&quot;</code>：同步执行回调。</li>
</ul>
</li>
</ul>
<h2 id="defineProps"><a href="#defineProps" class="headerlink" title="defineProps"></a>defineProps</h2><p><code>defineProps</code> 是一个函数，用于声明当前组件接收的 props。它返回一个包含所有 props 的对象，可以在组件的逻辑中使用。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; defineProps &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const props = defineProps([&#x27;name&#x27;]);</span><br></pre></td></tr></table></figure></div>

<p>函数的参数是一个字符串数组，里面的字符串就是可以接收的 props，可以让<strong>父组件</strong>（调用组件的组件）通过属性将属性值传递给<strong>子组件</strong>（被调用的组件）的 props 中。</p>
<p>也可以接收一个对象，对象里可以详细配置 prop 的默认值，类型和验证等其它选项。</p>
<p>子组件调用这个值，通过 <code>&#123;&#123; props.name &#125;&#125;</code> 即可。</p>
<p>举例：</p>
<ul>
<li>子组件：</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">...</span><br><span class="line">const props = defineProps([&#x27;text&#x27;]);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;h2&gt;&#123;&#123; props.text &#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>父组件：</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Mybutton text=&quot;Title&quot;&gt;&lt;/Mybutton&gt;</span><br></pre></td></tr></table></figure></div>

<p>这样，父组件的数据就传递到子组件中了。</p>
<h2 id="defineEmits"><a href="#defineEmits" class="headerlink" title="defineEmits"></a>defineEmits</h2><p>在 Vue 3 中，<code>defineEmits</code> 是一个组合式 API，用于在组件中定义可以触发的事件。其参数是一个<strong>数组</strong>，包含了<strong>该组件可以触发的事件名称</strong>，返回值是一个函数，用于触发事件。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const emit = defineEmits([&#x27;ok&#x27;]);</span><br></pre></td></tr></table></figure></div>

<p>而 <code>emit</code> 函数的第一个参数表示触发的事件（这个事件必须是<strong>可触发</strong>的），后续参数表示传递给事件处理函数的数据。</p>
<p>此时，就可以通过子组件中的一个定义的事件，向父组件中传递相应的数据。</p>
<ul>
<li>子组件：</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; defineProps, defineEmits &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const props = defineProps([&#x27;text&#x27;]);</span><br><span class="line"></span><br><span class="line">const emit = defineEmits([&#x27;ok&#x27;]);</span><br><span class="line"></span><br><span class="line">function send() &#123;</span><br><span class="line">  emit(&#x27;ok&#x27;, &#x27;hello&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click=&quot;send&quot; class=&quot;button&quot;&gt;&#123;&#123; props.text &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.button &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  border-radius: 10px;</span><br><span class="line">  line-height: 50px;</span><br><span class="line">  background-color: aliceblue;</span><br><span class="line">  text-align: center;</span><br><span class="line">  margin: 100px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>父组件：</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import Mybutton from &#x27;...&#x27;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">function fn(str) &#123;</span><br><span class="line">	console.log(str); //将输出 str</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;Mybutton @ok=&quot;fn&quot;&gt;&lt;/Mybutton&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<p>这样，当点击父组件中引用的子组件（按钮）时，就会触发子组件中的 <code>send()</code> 函数，从而触发 <code>ok</code> 事件，并像父组件中的 <code>function</code> 函数传递了 <code>hello</code> 的参数。</p>
<p>也可以直接使用 <code>this.$emit(&#39;name&#39;, args)</code> 调用，会触发 <code>name</code> 事件，然后在父组件中监听 <code>name</code> 事件即可，这样就不用预定义 <code>emit</code> 了。</p>
<p>这样，父组件的数据就传递到子组件中了。</p>
<h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><p>插槽，用于子组件中占位，父组件可向其中传入内容。</p>
<p>与 <code>props</code> 不同，插槽传入的是具体的内容，而不是数据。</p>
<p>子组件：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;slot name=&quot;haha&quot; :msg=&quot;message&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></div>

<p>父组件：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template #haha=&quot;&#123; msg &#125;&quot;&gt;</span><br><span class="line">	&lt;h1&gt;HaHa&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>


<p>这样就可以把父组件中的标题放入子组件中的 <code>slot</code>，同时子组件将属性 <code>msg</code> 传给父组件，父组件可以通过 <code>v-slot:name</code> 的方式找到命名插槽，也可以简写为 <code>#name</code>，后面加上等号可以接收一个子组件的 <code>slotProps</code> 对象，然后采用 ES6 里对象结构的语法就可以直接得到 <code>message</code> 的值。（注意变量名&#x2F;键名要一样才能解构）。</p>
<p>其中父组件的 <code>template</code> 可以用子组件标签名代替。</p>
<h2 id="Vue-指令"><a href="#Vue-指令" class="headerlink" title="Vue 指令"></a>Vue 指令</h2><p>在 Vue.js 中，以 <code>v-</code> 开头的属性是 Vue 指令（directives）。指令是特殊的标记，添加在元素上的属性，用于在 DOM 上做特定的操作。</p>
<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>动态绑定，在需要绑定的元素属性前加上 <code>v-bind:</code> 即可，属性值改为变量。</p>
<p>简写为 <code>:</code></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :class=&quot;str&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></div>

<p>这样的绑定是单向的，Vue 中的数据变动会导致 DOM 中的数据变动，但 DOM 属性变动不会导致 Vue 中的数据变动。</p>
<p>也可以绑定一个对象，这样就不需要 <code>key</code> 值，把对象中的每个键作为 <code>key</code>。</p>
<hr>
<p>动态绑定 css 属性时，情况有些不同。</p>
<p>传入的是一个对象，属性名是样式名，而 css 中很多样式名中含有 <code>-</code>，但对象的属性名是不可以包含 <code>-</code> 的，所以需要用驼峰命名法来规避。</p>
<p>动态绑定类时也可以传入一个对象，属性是对象名，属性值是布尔值。</p>
<p>通过传入对象的方式绑定 class 或 css 时，<strong>属性是常量</strong>，属性值是变量。</p>
<p>如 <code>:class=&quot;&#123; classname1: true, classname2: false, ... &#125;&quot;</code></p>
<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>监听某个时间并执行相应的函数。</p>
<p>在事件前添加 <code>v-on:</code> 即可，例如：<code>v-on:click</code>。</p>
<p>可以简写为 <code>@click</code>。</p>
<ul>
<li><code>.prevent</code> 事件修饰符，可以阻止默认事件行为，可以组织表单提交后页面刷新，也可以点击链接后阻止导航。</li>
</ul>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>在 <code>input</code> 标签中添加属性 <code>v-model=“var&quot;</code></p>
<p>变量值与输入框内的值便是<strong>双向绑定</strong>的。</p>
<p>即修改其中一个必然会影响另一个值。</p>
<p>不仅仅文本输入框可以进行双向绑定，<code>checkbox</code> 也可以，需要将绑定的值设为布尔类型。</p>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-for=&quot;(i, index) in list&quot; :key=&quot;index&quot;&gt;</span><br></pre></td></tr></table></figure></div>

<p>这里通过遍历 <code>list</code> 并且按照其中元素个数渲染多个 <code>div</code>，<code>i</code> 是形参，代表 <code>list</code> 中的值，<code>index</code> 表示数组下标。</p>
<p><code>:key</code> 作用是提供唯一标识，防止渲染错误。</p>
<p>因为所有的 <code>v-for</code> 都是通过 <code>key</code> 值来渲染元素的，默认为当前数组的下标，当有多个 <code>v-for</code> 时，<code>key</code> 可能相同，就会导致渲染出错误的结果。</p>
<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>控制一个元素是否显示，属性值为布尔值。</p>
<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p>与 <code>v-show</code> 用法相同，区别在于，如果元素不显示，不会创建这个元素，而 <code>v-show</code> 只是单纯利用 CSS 将元素进行隐藏。</p>
<h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><p>与 <code>v-if</code> 相同，分支逻辑。</p>
<h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><p>与 <code>v-if</code> 相同，分支逻辑。</p>
<h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h2><p>Vue 路由，通过它我们可以避免像静态页面一样通过大量的发送请求得到不同的页面文件来实现<strong>单或多页面 APP</strong>。</p>
<p>与多页面静态网页 APP 相比，Vue 实现的多页面 APP 区别在哪里？</p>
<ul>
<li>HTML 多页面：<ul>
<li>每次更换页面都需要重新加载整个页面文件。</li>
<li>不同的页面对应着不同的页面文件。</li>
</ul>
</li>
<li>Vue 实现多页面：<ul>
<li>每次更换页面只需要请求需要的组件。（或者初始加载时一次性请求所有可能用到的组件，这样切换很快但初始加载很慢，所以用到懒加载技术实现按需加载）</li>
<li>只有一个页面文件，通过修改 <code>url</code> 修改不同组件的呈现。</li>
</ul>
</li>
</ul>
<p><strong>流程</strong>：</p>
<pre class="mermaid">flowchart LR;
    1["制定路由规则(index.js)"]-->2["使用规则(main.js)"] & 3["创建组件(views.vue)"]-->4["渲染路由" router-view];</pre>

<p>注意：</p>
<ul>
<li><code>a</code> 标签会产生新的请求，所以要使用 <code>router-link</code>。</li>
<li>JS 里属性名不可以包含 <code>-</code>，所以使用驼峰命名代替。</li>
</ul>
<h3 id="export-import"><a href="#export-import" class="headerlink" title="export &amp; import"></a>export &amp; import</h3><ol>
<li>Default Export</li>
</ol>
<p>每个模块可以有且最多一个的默认导出值。</p>
<p>默认导出在导入时，可以随意命名，并且可以不需要花括号。</p>
<ol start="2">
<li>Named Export</li>
</ol>
<p>可以导出多个值。</p>
<p>在导入时，只能使用这个变量的名字，且必须使用花括号包裹。</p>
<h1 id="Vue-项目"><a href="#Vue-项目" class="headerlink" title="Vue 项目"></a>Vue 项目</h1><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>页面本身是一个根组件。</p>
<p>不同的区域是不同的组件。</p>
<h2 id="创建-Vue"><a href="#创建-Vue" class="headerlink" title="创建 Vue"></a>创建 Vue</h2><h3 id="CDN-创建"><a href="#CDN-创建" class="headerlink" title="CDN 创建"></a>CDN 创建</h3><p>推荐小白先使用这个，因为 CLI 方式生成的结构比较复杂，令人费解。</p>
<p>将 <code>&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;</code> 引入至 HTML 的 <code>head</code> 标签后便可使用。</p>
<p>创建一个 Vue APP：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;&#125;).mount(&#x27;#app&#x27;);</span><br></pre></td></tr></table></figure></div>

<p>代表创建一个 APP，条件是一个对象，挂载在 DOM 中的 <code>#app</code> 节点上。</p>
<h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>命令行 <code>cd</code> 至目标目录，输入 <code>npm create vue@latest</code>。</p>
<h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p>安装依赖：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></div>

<p>本地运行（基于 <a class="link"   href="https://vitejs.dev/" >Vite<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure></div>

<h2 id="打包和发布"><a href="#打包和发布" class="headerlink" title="打包和发布"></a>打包和发布</h2><p>使用 <code>npm run build</code> 来构建项目，你会得到一个 <code>dist</code> 文件夹，里面就装有你打包好的文件，注意这里面的 <code>index.html</code> 文件所引入的 CSS 和 JS 路径均为绝对路径，要<strong>改为相对路径</strong>否则网页在云端预览时将会是一片空白，因为网页内容由 JS 生成。</p>
<p>如何发布？</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>然后去 Github 创建一个仓库。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin ...</span><br><span class="line">git push -u origin ...</span><br></pre></td></tr></table></figure></div>

<p>具体看 Github 创建仓库后下面的提示。</p>
<p>（这里的 <code>-u</code> 是指设置上游分支，即默认分支，设置好后以后只需要使用 <code>git push</code> 和 <code>git pull</code> 即可，不需要加上 <code>origin ...</code>）</p>
<p>然后这只是把项目的源代码上传上去了，但我想让这个项目跑起来。</p>
<p>然而上传的文件并没有 <code>dist</code> 目录，这是因为它被 <code>.gitignore</code> 文件给忽略了，我们可以使用 <code>gh-pages</code> 插件将项目文件上传到 <code>gh-pages</code> 分支。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install gh-pages --save-dev</span><br></pre></td></tr></table></figure></div>

<p>在根目录的 <code>package.json</code> 文件中添加相应命令以及你的 <code>homepage</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;your-vue-project&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;homepage&quot;</span>: <span class="string">&quot;https://yourusername.github.io/your-repo-name&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build&quot;</span>,</span><br><span class="line">    <span class="string">&quot;deploy&quot;</span>: <span class="string">&quot;gh-pages -d dist&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    // 项目依赖</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;gh-pages&quot;</span>: <span class="string">&quot;^3.2.3&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里 <code>gh-pages -d dist</code> 就是上传 <code>dist</code> 目录，然后去 Github 开启 Github Pages 并把分支改为 <code>gh-pages</code> 即可。</p>
<h2 id="Vue-实例"><a href="#Vue-实例" class="headerlink" title="Vue 实例"></a>Vue 实例</h2><p><code>createApp</code> 传入的参数是一个根组件，可以是一个 Vue 组件也可以是一个 Javascript 对象。</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>计算属性，当里面的值所依赖的值发生变化时会重新计算。</p>
<p>它的值是一个对象。</p>
<p>在 Vue3 中，<code>computed()</code> 接收一个函数，返回值作为计算属性值，函数中的变量就是依赖。</p>
<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>一个函数，返回的是一个对象，里面包含着需要用到的数据。</p>
<p>将作为 Vue 实例的一个属性，在这个对象内访问 data 中的值时需要 <code>this.</code>。</p>
<p>属性名和属性值相同时可以只写属性名。（ES6）</p>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p>一个对象，里面可以定义各种方法，相当于方法版的 data。</p>
<h3 id="components"><a href="#components" class="headerlink" title="components"></a>components</h3><p>一个对象，用于注册子组件，里面包含着需要注册的子组件，需要提前 <code>import</code>。</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>一个对象，可以在子组件的导出对象中定义 <code>props</code>，这个对象的属性代表父组件中可以传递给子组件的属性，属性值为这个属性所接收的值类型。</p>
<p>示例：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">	<span class="attr">title</span>: <span class="title class_">String</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="title class_">Number</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h3><p>使用 <code>export</code> 关键字进行导出，可以导出任何值。</p>
<p>可以使用 <code>export default</code> 关键字导出一个默认的值。</p>
<p>在另一个文件内使用 <code>import &#123;name1, name2&#125; from &#39;././...&#39;</code> 导入。</p>
<p>同时需要在 HTML 文件中的 <code>script</code> 标签加入 <code>type=&quot;module&quot;</code>。</p>
]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>板子汇总</title>
    <url>/61811bf3.html</url>
    <content><![CDATA[<blockquote>
<p>乱序，想到什么可以补充。</p>
</blockquote>
<h1 id="Tarjan-求强连通分量"><a href="#Tarjan-求强连通分量" class="headerlink" title="Tarjan 求强连通分量"></a>Tarjan 求强连通分量</h1><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+7</span>;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g_2[N];</span><br><span class="line"><span class="comment">//cscc代表强连通分量的数量，scc代表每个点所属的强连通分量的编号，ins代表是否在栈中</span></span><br><span class="line"><span class="type">int</span> dfsn[N],low[N],ins[N],scc[N],deep,cscc,n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[p]=dfsn[p]=++deep;</span><br><span class="line">    ins[p]=<span class="number">1</span>;</span><br><span class="line">    s.<span class="built_in">push</span>(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;q:g[p])<span class="comment">//遍历出边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfsn[q])<span class="comment">//未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(q);</span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[p],low[q]);</span><br><span class="line">        &#125;<span class="comment">//访问过且q可达p，因为栈中元素强连通</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ins[q]) low[p]=<span class="built_in">min</span>(low[p],dfsn[q]);<span class="comment">//注意这里为什么是dfsn[q]而不是low[q]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[p]==dfsn[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">        cscc++;</span><br><span class="line">        <span class="keyword">while</span>(top!=p)</span><br><span class="line">        &#123;</span><br><span class="line">            top=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            ins[top]=<span class="number">0</span>;</span><br><span class="line">            scc[top]=cscc;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//原图不一定是强连通图，因此每个节点都要看一遍</span></span><br><span class="line">        <span class="keyword">if</span>(!dfsn[i])<span class="comment">//未访问过</span></span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[i])<span class="comment">//以i为起点的出边</span></span><br><span class="line">            <span class="keyword">if</span>(scc[i]!=scc[j])<span class="comment">//如果不是一个强连通分量，那就可以把两个强连通分量当作两个点连接起来</span></span><br><span class="line">                g_2[scc[i]].<span class="built_in">push_back</span>(scc[j]);<span class="comment">//j是i的出边，即j的强连通分量是i的强连通分量的出边</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="缩点"><a href="#缩点" class="headerlink" title="缩点"></a>缩点</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P3387" >P3387 【模板】缩点<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">7</span>, M = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cscc, depth, ans;</span><br><span class="line"><span class="type">int</span> dfsn[N], low[N], scc[N], w[N], rd[N], dist[N], val[N];</span><br><span class="line"><span class="type">bool</span> ins[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[p] = dfsn[p] = ++depth;</span><br><span class="line">    ins[p] = <span class="literal">true</span>;</span><br><span class="line">    s.<span class="built_in">push</span>(p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;q : g[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfsn[q])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(q);</span><br><span class="line">            low[p] = <span class="built_in">min</span>(low[p], low[q]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ins[q]) low[p] = <span class="built_in">min</span>(low[p], dfsn[q]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfsn[p] == low[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">        cscc++;</span><br><span class="line">        <span class="keyword">while</span> (top != p)</span><br><span class="line">        &#123;</span><br><span class="line">            top = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            val[cscc] += w[top];</span><br><span class="line">            scc[top] = cscc;</span><br><span class="line">            ins[top] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cscc; i++)</span><br><span class="line">        <span class="keyword">if</span> (!rd[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            dist[i] = val[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; v : G[u])</span><br><span class="line">        &#123;</span><br><span class="line">            dist[v] = <span class="built_in">max</span>(dist[v], dist[u] + val[v]);</span><br><span class="line">            rd[v]--;</span><br><span class="line">            <span class="keyword">if</span> (!rd[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cscc; i++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dist[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        g[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfsn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j : g[i])</span><br><span class="line">            <span class="keyword">if</span> (scc[i] != scc[j])</span><br><span class="line">            &#123;</span><br><span class="line">                G[scc[i]].<span class="built_in">emplace_back</span>(scc[j]);</span><br><span class="line">                rd[scc[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="Tarjan-求割点-割边"><a href="#Tarjan-求割点-割边" class="headerlink" title="Tarjan 求割点&#x2F;割边"></a>Tarjan 求割点&#x2F;割边</h1><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+7</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> dfsn[N],low[N],fa[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; point;</span><br><span class="line"><span class="comment">/*割点*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p,<span class="type">bool</span> root=<span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    low[p]=dfsn[p]=++cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;q:e[p])<span class="comment">//枚举p的出边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfsn[q])<span class="comment">//这个点没访问过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(q,<span class="literal">false</span>);<span class="comment">//递归，并且这个点不是根</span></span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[p],low[q]);<span class="comment">//更新父节点的low值</span></span><br><span class="line">            tot+=(low[q]&gt;=dfsn[p]);<span class="comment">//子节点的low值比父节点的dfs序还要大，那就把需要p的子树个数加一</span></span><br><span class="line">            <span class="comment">//需要p的子树是指删去p后子树无法与外界联系</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//访问过，那就对low值取min</span></span><br><span class="line">        &#123;</span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[p],dfsn[q]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot&gt;root)<span class="comment">//是根那就要大于1，否则就要大于0</span></span><br><span class="line">        point.<span class="built_in">push_back</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; bridges;</span><br><span class="line"><span class="comment">/*割边*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan_0</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[p]=dfsn[p]=++cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;q:e[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfsn[q])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[q]=p;</span><br><span class="line">            <span class="built_in">tarjan_0</span>(q);</span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[p],low[q]);</span><br><span class="line">            <span class="keyword">if</span>(low[q]&gt;dfsn[p]) bridges.<span class="built_in">emplace_back</span>(p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fa[p]!=q) low[p]=<span class="built_in">min</span>(low[p],dfsn[q]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Tarjan-求点双连通分量"><a href="#Tarjan-求点双连通分量" class="headerlink" title="Tarjan 求点双连通分量"></a>Tarjan 求点双连通分量</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e6</span><span class="number">+100</span>;</span><br><span class="line"><span class="type">int</span> n,m,edcnt,cnt,cdcc;</span><br><span class="line"><span class="type">int</span> fir[N],low[N],dfsn[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dcc[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; point;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p,<span class="type">bool</span> root=<span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    dfsn[p]=low[p]=++cnt;</span><br><span class="line">    s.<span class="built_in">push</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(root&amp;&amp;fir[p]==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dcc[++cdcc].<span class="built_in">push_back</span>(p);<span class="comment">//孤立点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[p];i;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfsn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v,<span class="literal">false</span>);</span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[v],low[p]);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&gt;=dfsn[p])</span><br><span class="line">            &#123;</span><br><span class="line">                tot++;</span><br><span class="line">                <span class="keyword">if</span>(tot&gt;root) point.<span class="built_in">push_back</span>(p);</span><br><span class="line">                cdcc++;</span><br><span class="line">                <span class="type">int</span> top;</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    top=s.<span class="built_in">top</span>();</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    dcc[cdcc].<span class="built_in">push_back</span>(top);</span><br><span class="line">                &#125; <span class="keyword">while</span> (top!=v);</span><br><span class="line">                dcc[cdcc].<span class="built_in">push_back</span>(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[p]=<span class="built_in">min</span>(low[p],dfsn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfsn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cdcc);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cdcc;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(<span class="type">int</span>)dcc[i].<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;j:dcc[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,j);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Tarjan-求边双连通分量"><a href="#Tarjan-求边双连通分量" class="headerlink" title="Tarjan 求边双连通分量"></a>Tarjan 求边双连通分量</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> fir[N],low[N],dfsn[N];</span><br><span class="line"><span class="type">int</span> n,m,edcnt=<span class="number">1</span>,cnt,cdcc;</span><br><span class="line"><span class="type">bool</span> bridge[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dcc[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[p]=dfsn[p]=++cnt;</span><br><span class="line">    s.<span class="built_in">push</span>(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[p];i;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfsn[q])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(q,i);</span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[p],low[q]);</span><br><span class="line">            <span class="keyword">if</span>(dfsn[p]&lt;low[q]) bridge[i]=bridge[i^<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i!=(f^<span class="number">1</span>)) low[p]=<span class="built_in">min</span>(low[p],dfsn[q]);<span class="comment">//不是反向边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfsn[p]==low[p])</span><br><span class="line">    &#123;</span><br><span class="line">        cdcc++;</span><br><span class="line">        <span class="type">int</span> top;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            top=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            dcc[cdcc].<span class="built_in">push_back</span>(top);</span><br><span class="line">        &#125; <span class="keyword">while</span> (top!=p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfsn[i]) <span class="built_in">tarjan</span>(i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cdcc);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cdcc;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(<span class="type">int</span>)dcc[i].<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;j:dcc[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,j);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中利用了异或的性质，偶数加一奇数减一，令初始cnt为1使得边的编号从2开始，这样就可以通过异或1轻松知道反向边的编号了。</p>
<h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10000007</span></span><br><span class="line"><span class="type">int</span> n,dist[maxn],m,first[maxn];</span><br><span class="line"><span class="type">int</span> s[maxn],e[maxn],d[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;s[i],&amp;e[i],&amp;d[i]);<span class="comment">//起点，终点，长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//起点距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//最多n-1条边,最多松弛n-1次，因为如果倒着来的话，所有点的dist都未知，每次只能更新一个点（一点点往后推），因此每轮会至少松弛一个点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)<span class="comment">//枚举边</span></span><br><span class="line">        &#123;</span><br><span class="line">            dist[e[j]]=<span class="built_in">min</span>(dist[e[j]],dist[s[j]]+d[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><blockquote>
<p>Bellman-Ford的队列优化</p>
</blockquote>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="type">int</span> first[maxn],dist[maxn];</span><br><span class="line"><span class="type">bool</span> inque[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> e,next;</span><br><span class="line">    <span class="type">int</span> d;<span class="comment">//长度</span></span><br><span class="line">&#125;ed[maxn];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    ed[cnt].next=first[u];</span><br><span class="line">    ed[cnt].e=v;</span><br><span class="line">    ed[cnt].d=w;</span><br><span class="line">    first[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    inque[s]=<span class="literal">true</span>;<span class="comment">//这里不写也可以，因为第一次取出的一定是首点</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);<span class="comment">//一开始只知道s的最短路</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        inque[now]=<span class="literal">false</span>;<span class="comment">//记录当前点在不在队列里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=first[now];i;i=ed[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> e=ed[i].e;</span><br><span class="line">            <span class="type">int</span> d=dist[now]+ed[i].d;</span><br><span class="line">            <span class="keyword">if</span>(d&lt;dist[e])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[e]=d;<span class="comment">//如果e变短了，那么也可以用它去更新其他点的最短路</span></span><br><span class="line">                <span class="keyword">if</span>(!inque[e])</span><br><span class="line">                &#123;</span><br><span class="line">                    inque[e]=<span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="判断负环"><a href="#判断负环" class="headerlink" title="判断负环"></a>判断负环</h3><blockquote>
<p>可以记录每个点到起点经过的边数，边数不超过n-1；也可以记录每个点的入队次数，这个次数不能超过n-1。</p>
</blockquote>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="type">int</span> first[maxn],dist[maxn],times[maxn];</span><br><span class="line"><span class="type">bool</span> inque[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> e,next;</span><br><span class="line">    <span class="type">int</span> d;<span class="comment">//长度</span></span><br><span class="line">&#125;ed[maxn];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    ed[cnt].next=first[u];</span><br><span class="line">    ed[cnt].e=v;</span><br><span class="line">    ed[cnt].d=w;</span><br><span class="line">    first[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(times,<span class="number">0</span>,<span class="built_in">sizeof</span>(times));</span><br><span class="line">    <span class="built_in">memset</span>(inque,<span class="number">0</span>,<span class="built_in">sizeof</span>(inque));</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    times[s]=<span class="number">1</span>;</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);<span class="comment">//一开始只知道s的最短路</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        inque[now]=<span class="literal">false</span>;<span class="comment">//记录当前点在不在队列里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=first[now];i;i=ed[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> e=ed[i].e;</span><br><span class="line">            <span class="type">int</span> d=dist[now]+ed[i].d;</span><br><span class="line">            <span class="keyword">if</span>(d&lt;dist[e])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[e]=d;<span class="comment">//如果e变短了，那么也可以用它去更新其他点的最短路</span></span><br><span class="line">                <span class="keyword">if</span>(!inque[e])</span><br><span class="line">                &#123;</span><br><span class="line">                    inque[e]=<span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(e);</span><br><span class="line">                    times[e]++;<span class="comment">//记录入队次数</span></span><br><span class="line">                    <span class="keyword">if</span>(times[e]&gt;n)<span class="comment">//因为有0号点</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//存在负环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add_edge</span>(a,b,c);</span><br><span class="line">                <span class="built_in">add_edge</span>(b,a,c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">add_edge</span>(a,b,c);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">spfa</span>(<span class="number">1</span>))</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">memset</span>(first,<span class="number">0</span>,<span class="built_in">sizeof</span>(first));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P4779" >P4779 【模板】单源最短路径（标准版）)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="type">int</span> dist[maxn],first[maxn];</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">bool</span> righ[maxn];<span class="comment">//这个点有没有放到右边去</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">    <span class="type">int</span> p,d;<span class="comment">//原点到p的最短距离为d</span></span><br><span class="line">    <span class="built_in">point</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">point</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;p=a;d=b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)<span class="comment">//STL默认大根堆，上面是大的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.d&gt;b.d;<span class="comment">//小根堆</span></span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;point&gt; heap;</span><br><span class="line"><span class="comment">//松弛操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> e,next;</span><br><span class="line">    <span class="type">int</span> d;<span class="comment">//长度</span></span><br><span class="line">&#125;ed[maxn];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    ed[cnt].next=first[u];</span><br><span class="line">    ed[cnt].e=v;</span><br><span class="line">    ed[cnt].d=w;</span><br><span class="line">    first[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));<span class="comment">//全部都赋值为最大值</span></span><br><span class="line">    dist[s]=<span class="number">0</span>;<span class="comment">//s到s</span></span><br><span class="line">    heap.<span class="built_in">push</span>(<span class="built_in">point</span>(s,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//可以无变量名</span></span><br><span class="line">    <span class="keyword">while</span>(!heap.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        point now=heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(righ[now.p]) <span class="keyword">continue</span>;<span class="comment">//判断要写在这里，不能直接判断堆顶，因为可能pop之后堆就空了导致RE</span></span><br><span class="line">        <span class="type">int</span> p=now.p;</span><br><span class="line">        <span class="comment">// int d=now.d;//未加堆优化版，找到目前dist最小的点</span></span><br><span class="line">        <span class="comment">// int p=-1;//代表还没选任何点</span></span><br><span class="line">        <span class="comment">// for(int j=1;j&lt;=n;j++)//循环后就找到了在左边最短路最小的点</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     if(!righ[j]&amp;&amp;(p==-1||dist[p]&gt;dist[j]))//righ[]代表有没有放到右边去</span></span><br><span class="line">        <span class="comment">//         p=j;</span></span><br><span class="line">        righ[p]=<span class="number">1</span>;<span class="comment">//放到右边，枚举出边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=first[p];j; j=ed[j].next)<span class="comment">//ed[j].e即为p的下一个点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> e=ed[j].e;</span><br><span class="line">            <span class="type">int</span> d=dist[p]+ed[j].d;</span><br><span class="line">            <span class="keyword">if</span>(dist[e]&gt;d)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[e]=d;</span><br><span class="line">                <span class="keyword">if</span>(!righ[e]) heap.<span class="built_in">push</span>(<span class="built_in">point</span>(e,d));<span class="comment">//没访问过并且松弛过的点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="built_in">add_edge</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[i]==<span class="number">1061109567</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">2147483647</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Floyed"><a href="#Floyed" class="headerlink" title="Floyed"></a>Floyed</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			dist[i][j]=<span class="built_in">max</span>(dist[i][j],dist[i][k]+dist[k][j]);</span><br></pre></td></tr></table></figure></div>

<h2 id="Johnson"><a href="#Johnson" class="headerlink" title="Johnson"></a>Johnson</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">6e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, edcnt;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> s[N],t[N],d[N];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, val, nxt;</span><br><span class="line">&#125;e[(M &lt;&lt; <span class="number">1</span>) + N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id,len;</span><br><span class="line">    <span class="built_in">point</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">point</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">id</span>(a),<span class="built_in">len</span>(b)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> point &amp;x)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> len &gt; x.len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].nxt = fir[u];</span><br><span class="line">    e[edcnt].to = v;</span><br><span class="line">    e[edcnt].val = w;</span><br><span class="line">    fir[u] = edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;point&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">point</span>(s,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        point now = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[now.id]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[now.id] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = fir[now.id]; i; i = e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            <span class="type">int</span> d = dist[now.id] + e[i].val;</span><br><span class="line">            <span class="keyword">if</span>(d &lt; dist[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = d;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(<span class="built_in">point</span>(v,dist[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;s[i],&amp;t[i],&amp;d[i]);</span><br><span class="line">    <span class="type">int</span> tot = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s[++tot] = <span class="number">0</span>;</span><br><span class="line">        t[tot] = i;</span><br><span class="line">        d[tot] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">// 多加了一个源点，所以最多松弛 n 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n + m; ++j) <span class="comment">// n+m条边</span></span><br><span class="line">            h[t[j]] = <span class="built_in">min</span>(h[t[j]], h[s[j]] + d[j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n + m; ++j)</span><br><span class="line">        <span class="keyword">if</span>(h[t[j]] &gt; h[s[j]] + d[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">Add</span>(s[i], t[i], d[i] + h[s[i]] - h[t[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Dijkstra</span>(i);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            ans += j * (dist[j] == <span class="number">0x3f3f3f3f</span> ? <span class="number">1e9</span> : dist[j] - h[i] + h[j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="倍增求-LCA"><a href="#倍增求-LCA" class="headerlink" title="倍增求 LCA"></a>倍增求 LCA</h1><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="type">int</span> dist[maxn],first[maxn],f[maxn][<span class="number">20</span>],depth[maxn],g[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> e,next;</span><br><span class="line">    <span class="type">int</span> d;<span class="comment">//长度</span></span><br><span class="line">&#125;ed[maxn];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    ed[cnt].next=first[u];</span><br><span class="line">    ed[cnt].e=v;</span><br><span class="line">    ed[cnt].d=w;</span><br><span class="line">    first[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now)</span><span class="comment">//从根节点开始dfs//预处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=first[now];i;i=ed[i].next)</span><br><span class="line">        <span class="keyword">if</span>(ed[i].e!=f[now][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> p=ed[i].e;</span><br><span class="line">            depth[p]=depth[now]<span class="number">+1</span>;</span><br><span class="line">            f[p][<span class="number">0</span>]=now;</span><br><span class="line">            g[p][<span class="number">0</span>]=ed[i].d;<span class="comment">//代表从p向上走……步（这里指一步）所经过的最短距离为这条边的边权</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=<span class="number">18</span>;x++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[p][x]=f[f[p][x<span class="number">-1</span>]][x<span class="number">-1</span>];</span><br><span class="line">                g[p][x]=<span class="built_in">min</span>(g[p][x<span class="number">-1</span>],g[f[p][x<span class="number">-1</span>]][x<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.调整深度2.一起跳</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_lca</span><span class="params">(<span class="type">int</span> p1,<span class="type">int</span> p2)</span><span class="comment">//魔改后是求边权最小值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	depth[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 防止跳到零号点</span></span><br><span class="line">    <span class="keyword">if</span>(depth[p1]&lt;depth[p2]) <span class="built_in">swap</span>(p1,p2);<span class="comment">//保证p1较深</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">18</span>;x&gt;=<span class="number">0</span>;x--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=f[p1][x];</span><br><span class="line">        <span class="keyword">if</span>(depth[p]&gt;=depth[p2])</span><br><span class="line">        &#123;</span><br><span class="line">            p1=p;<span class="comment">//完成后p1p2深度就一致了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p1==p2) <span class="keyword">return</span> p1;<span class="comment">//防止p1，p2在同一点上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">18</span>;x&gt;=<span class="number">0</span>;x--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[p1][x]!=f[p2][x])</span><br><span class="line">        &#123;</span><br><span class="line">            p1=f[p1][x],p2=f[p2][x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[p1][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="DFS-序求-LCA"><a href="#DFS-序求-LCA" class="headerlink" title="DFS 序求 LCA"></a>DFS 序求 LCA</h1><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> idx, n, m, root, cnt;</span><br><span class="line"><span class="type">int</span> dfsn[N], st[<span class="number">25</span>][N], fir[N];</span><br><span class="line"><span class="type">int</span> Log2[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">&#125;e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Log2[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        Log2[i] = Log2[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfsn[x] &lt; dfsn[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].nxt = fir[u];</span><br><span class="line">    fir[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfsn[u] = ++idx;</span><br><span class="line">    st[<span class="number">0</span>][idx] = fa; <span class="comment">// 以 idx 为起点长度为 (1 &lt;&lt; i) 的区间内 dfsn 最小的点的父亲</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = fir[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> (dfsn[x] &gt; dfsn[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="type">int</span> d = Log2[dfsn[y] - dfsn[x]]; <span class="comment">// +1 -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(st[d][dfsn[x] + <span class="number">1</span>], st[d][dfsn[y] - (<span class="number">1</span> &lt;&lt; d) + <span class="number">1</span>]); <span class="comment">// [dfsn_u + 1, dfsn_v]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, u, v; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Log2[n]; i++) <span class="comment">// Log2[i] 下取整</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; j++)</span><br><span class="line">            st[i][j] = <span class="built_in">get</span>(st[i - <span class="number">1</span>][j], st[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lca</span>(u, v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dat</span>&#123;</span><br><span class="line">    <span class="type">int</span> val,id;</span><br><span class="line">&#125;olda[N];</span><br><span class="line"><span class="type">int</span> newa[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(dat x,dat y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.val&lt;y.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;olda[i].val);</span><br><span class="line">        olda[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(olda<span class="number">+1</span>,olda<span class="number">+1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        newa[olda[i].id]=i;</span><br><span class="line">        <span class="keyword">if</span>(olda[i].val==olda[i<span class="number">-1</span>].val)</span><br><span class="line">            newa[olda[i].id]=newa[olda[i<span class="number">-1</span>].id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,newa[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">520</span>],b[<span class="number">520</span>],c[<span class="number">520</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string A,B;</span><br><span class="line">    cin&gt;&gt;A&gt;&gt;B;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">max</span>(A.<span class="built_in">length</span>(),B.<span class="built_in">length</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">length</span>()<span class="number">-1</span>,j=<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--,j++)</span><br><span class="line">        a[j]=A[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=B.<span class="built_in">length</span>()<span class="number">-1</span>,j=<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--,j++)</span><br><span class="line">        b[j]=B[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i]+=a[i]+b[i];</span><br><span class="line">        c[i<span class="number">+1</span>]=c[i]/<span class="number">10</span>;</span><br><span class="line">        c[i]%=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c[len<span class="number">+1</span>])</span><br><span class="line">        len++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10200</span>],b[<span class="number">10200</span>],c[<span class="number">10200</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string A,B;</span><br><span class="line">    cin&gt;&gt;A&gt;&gt;B;</span><br><span class="line">    <span class="type">int</span> lena=A.<span class="built_in">length</span>(),lenb=B.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lena<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        a[lena-i]=A[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lenb<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        b[lenb-i]=B[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lenb;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i+j<span class="number">-1</span>]+=a[i]*b[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len=lena+lenb;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i<span class="number">+1</span>]+=c[i]/<span class="number">10</span>;</span><br><span class="line">        c[i]%=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!c[len])</span><br><span class="line">        len--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">max</span>(<span class="number">1</span>,len);i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> s[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=l,j=r,flag=a[(l+r)/<span class="number">2</span>],tmp;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i]&lt;flag) i++;</span><br><span class="line">        <span class="keyword">while</span>(a[j]&gt;flag) j--;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i],a[j]);</span><br><span class="line">            <span class="comment">// tmp=a[i];</span></span><br><span class="line">            <span class="comment">// a[i]=a[j];</span></span><br><span class="line">            <span class="comment">// a[j]=tmp;</span></span><br><span class="line">            i++,j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(i&lt;=j);</span><br><span class="line">    <span class="keyword">if</span>(l&lt;j)</span><br><span class="line">        <span class="built_in">qsort</span>(a,l,j);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;r)</span><br><span class="line">        <span class="built_in">qsort</span>(a,i,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line">    <span class="built_in">qsort</span>(s,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[N],nex[N],cnt;</span><br><span class="line"><span class="type">int</span> que[N],d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//他是从0~m-1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt]=b;<span class="comment">//end</span></span><br><span class="line">    nex[cnt]=h[a];</span><br><span class="line">    h[a]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh=<span class="number">1</span>,tt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n;l++)</span><br><span class="line">        <span class="keyword">if</span>(!d[l])</span><br><span class="line">            que[++tt]=l;</span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t=que[hh++];<span class="comment">//取出队首</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=nex[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j=e[i];</span><br><span class="line">                d[j]--;</span><br><span class="line">                <span class="keyword">if</span>(d[j]==<span class="number">0</span>)</span><br><span class="line">                    que[++tt]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> tt==n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">topsort</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,que[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="Kruscal"><a href="#Kruscal" class="headerlink" title="Kruscal"></a>Kruscal</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> u,v,w;<span class="comment">//u-----w------&gt;v</span></span><br><span class="line">&#125;eg[<span class="number">1000005</span>]; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt,ans,tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	eg[++cnt].u=u;</span><br><span class="line">	eg[cnt].v=v;</span><br><span class="line">	eg[cnt].w=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruscal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(eg<span class="number">+1</span>,eg+m<span class="number">+1</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> rootu=<span class="built_in">find</span>(eg[i].u);</span><br><span class="line">		<span class="type">int</span> rootv=<span class="built_in">find</span>(eg[i].v);</span><br><span class="line">		<span class="keyword">if</span>(rootu!=rootv)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=eg[i].w;</span><br><span class="line">			tot++;</span><br><span class="line">			fa[rootu]=rootv;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;eg[i].u,&amp;eg[i].v,&amp;eg[i].w);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="type">int</span> dist[maxn],first[maxn];</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">bool</span> righ[maxn];<span class="comment">//这个点有没有放到右边去</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">    <span class="type">int</span> p,d;<span class="comment">//原点到p的最短距离为d</span></span><br><span class="line">    <span class="built_in">point</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">point</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;p=a;d=b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)<span class="comment">//STL默认大根堆，上面是大的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.d&gt;b.d;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;point&gt; heap;</span><br><span class="line"><span class="comment">//松弛操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> e,next;</span><br><span class="line">    <span class="type">int</span> d;<span class="comment">//长度</span></span><br><span class="line">&#125;ed[maxn];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    ed[cnt].next=first[u];</span><br><span class="line">    ed[cnt].e=v;</span><br><span class="line">    ed[cnt].d=w;</span><br><span class="line">    first[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));<span class="comment">//全部都赋值为最大值</span></span><br><span class="line">    dist[s]=<span class="number">0</span>;<span class="comment">//s到s</span></span><br><span class="line">    heap.<span class="built_in">push</span>(<span class="built_in">point</span>(s,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!heap.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        point now=heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> p=now.p;</span><br><span class="line">        <span class="keyword">if</span>(righ[p]) <span class="keyword">continue</span>;</span><br><span class="line">        righ[p]=<span class="number">1</span>;<span class="comment">//放到右边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=first[p];j;j=ed[j].next)<span class="comment">//ed[j].e即为p的下一个点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> e=ed[j].e;</span><br><span class="line">            <span class="type">int</span> d=ed[j].d;</span><br><span class="line">            <span class="keyword">if</span>(dist[e]&gt;d)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[e]=d;</span><br><span class="line">                <span class="keyword">if</span>(!righ[e]) heap.<span class="built_in">push</span>(<span class="built_in">point</span>(e,d));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="built_in">add_edge</span>(u,v,w);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h1><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+8</span>;</span><br><span class="line"><span class="type">int</span> q,a[N],cnt[N],l=<span class="number">1</span>,r=<span class="number">0</span>,now=<span class="number">0</span>,belong[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(query a, query b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (belong[a.l]^belong[b.l])?belong[a.l]&lt;belong[b.l]:((belong[a.l]&amp;<span class="number">1</span>)?a.r&lt;b.r:a.r&gt;b.r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!cnt[a[pos]]) ++now;</span><br><span class="line">    ++cnt[a[pos]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    --cnt[a[pos]];</span><br><span class="line">    <span class="keyword">if</span>(!cnt[a[pos]]) --now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ql,qr;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;qr,&amp;ql);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;ql) <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span>(l&gt;ql) <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span>(r&lt;qr) <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;qr) <span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="快读"><a href="#快读" class="headerlink" title="快读"></a>快读</h1><h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">1</span>; </span><br><span class="line">	<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) y=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="double"><a href="#double" class="headerlink" title="double"></a>double</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> x=<span class="number">0</span>,y=<span class="number">1</span>,w=<span class="number">1</span>;</span><br><span class="line">	<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) y=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		c=<span class="built_in">getchar</span>()</span><br><span class="line">		<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			w=w/<span class="number">10.0</span>;</span><br><span class="line">			x+=(c-<span class="string">&#x27;0&#x27;</span>)*w;</span><br><span class="line">			c=<span class="built_in">getchar</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll add,sum;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//上传</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//下放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node &amp;root=tr[u],&amp;left=tr[u&lt;&lt;<span class="number">1</span>],&amp;righ=tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.add)</span><br><span class="line">    &#123;</span><br><span class="line">        left.add+=root.add;</span><br><span class="line">        left.sum+=<span class="number">1ll</span>*(left.r-left.l<span class="number">+1</span>)*root.add;</span><br><span class="line">        righ.add+=root.add;</span><br><span class="line">        righ.sum+=<span class="number">1ll</span>*(righ.r-righ.l<span class="number">+1</span>)*root.add;</span><br><span class="line">        root.add=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//从u开始递归，建l~r的树，一般为build(1,1,n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l=l,tr[u].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum=a[r];</span><br><span class="line">        tr[u].add=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span><span class="comment">//从u开始递归，查询区间，加上d</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum+=<span class="number">1ll</span>*(tr[u].r-tr[u].l<span class="number">+1</span>)*d;</span><br><span class="line">        tr[u].add+=d;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,d);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,d);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//从u开始递归，查询l，r之间的区间和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) sum+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) sum+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL sum, add, mul;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = (tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum) % q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(Node &amp;t, LL add, LL mul)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t.sum = (t.sum * mul % q + (t.r - t.l + <span class="number">1</span>) * add % q);</span><br><span class="line">    t.add = (t.add * mul % q + add) % q;</span><br><span class="line">    t.mul = t.mul * mul % q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    tr[u].add = <span class="number">0</span>;</span><br><span class="line">    tr[u].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l = l, tr[u].r = r, tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum = a[r];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> add, <span class="type">int</span> mul)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">eval</span>(tr[u], add, mul);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, add, mul);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, add, mul);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) sum = (sum + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r)) % q;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) sum = (sum + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r)) % q;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, l, r, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, <span class="number">0</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, k, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="可持久化"><a href="#可持久化" class="headerlink" title="可持久化"></a>可持久化</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt;</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> root[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">&#125;tr[<span class="number">23</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u = ++idx;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].key = a[r];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(tr[u].l, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(tr[u].r, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;u, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u = ++idx;</span><br><span class="line">    tr[u] = tr[p];</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].key = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(tr[u].l, tr[p].l, l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(tr[u].r, tr[p].r, mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> tr[u].key;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(tr[u].l, l, mid, x);</span><br><span class="line">    <span class="keyword">if</span>(x &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(tr[u].r, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(root[<span class="number">0</span>], <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, last, loc, val;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;last, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;loc, &amp;val);</span><br><span class="line">            <span class="built_in">modify</span>(root[++cnt], root[last], <span class="number">1</span>, n, loc, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(root[last], <span class="number">1</span>, n, val));</span><br><span class="line">            root[++cnt] = root[last];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h1><h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, root, idx;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, key, val;</span><br><span class="line">    <span class="type">int</span> cnt, siz;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_node</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[++idx].key = key;</span><br><span class="line">    tr[idx].val = <span class="built_in">rand</span>();</span><br><span class="line">    tr[idx].cnt = tr[idx].siz = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].siz = tr[tr[p].l].siz + tr[tr[p].r].siz + tr[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    root = <span class="built_in">get_node</span>(-INF);</span><br><span class="line">    tr[root].r = <span class="built_in">get_node</span>(INF);</span><br><span class="line">    <span class="built_in">pushup</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zig</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = tr[p].l;</span><br><span class="line">    tr[p].l = tr[q].r;</span><br><span class="line">    tr[q].r = p;</span><br><span class="line">    p = q;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[p].r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zag</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = tr[p].r;</span><br><span class="line">    tr[p].r = tr[q].l;</span><br><span class="line">    tr[q].l = p;</span><br><span class="line">    p = q;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[p].l);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p = <span class="built_in">get_node</span>(key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].key == key) tr[p].cnt++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].key &gt; key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(tr[p].l, key);</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[p].l].val &gt; tr[p].val) <span class="built_in">zig</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(tr[p].r, key);</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[p].r].val &gt; tr[p].val) <span class="built_in">zag</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].key == key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].cnt &gt; <span class="number">1</span>) tr[p].cnt--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].l || tr[p].r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">zig</span>(p);</span><br><span class="line">                <span class="built_in">remove</span>(tr[p].r, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">zag</span>(p);</span><br><span class="line">                <span class="built_in">remove</span>(tr[p].l, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].key &gt; key) <span class="built_in">remove</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">remove</span>(tr[p].r, key);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_rank</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].key == key) <span class="keyword">return</span> tr[tr[p].l].siz + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].key &gt; key) <span class="keyword">return</span> <span class="built_in">get_rank</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> tr[tr[p].l].siz + tr[p].cnt + <span class="built_in">get_rank</span>(tr[p].r, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_key</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> rank)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span>(tr[tr[p].l].siz &gt;= rank) <span class="keyword">return</span> <span class="built_in">get_key</span>(tr[p].l, rank);</span><br><span class="line">    <span class="keyword">if</span>(tr[tr[p].l].siz + tr[p].cnt &gt;= rank) <span class="keyword">return</span> tr[p].key;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_key</span>(tr[p].r, rank - tr[tr[p].l].siz - tr[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_prev</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].key &gt;= key) <span class="keyword">return</span> <span class="built_in">get_prev</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(tr[p].key, <span class="built_in">get_prev</span>(tr[p].r, key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_next</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].key &lt;= key) <span class="keyword">return</span> <span class="built_in">get_next</span>(tr[p].r, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(tr[p].key, <span class="built_in">get_next</span>(tr[p].l, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="keyword">switch</span>(op)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">                <span class="built_in">insert</span>(root, x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">remove</span>(root, x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_rank</span>(root, x) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_key</span>(root, x + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_prev</span>(root, x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_next</span>(root, x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> nxt[N];</span><br><span class="line"><span class="type">int</span> la,lb;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;lb;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;b[i]!=b[j]) j=nxt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(b[i]==b[j]) j++;</span><br><span class="line">        nxt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;la;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;a[i]!=b[j]) j=nxt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==b[j]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j==lb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i-j<span class="number">+2</span>);</span><br><span class="line">            j=nxt[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,a,b);</span><br><span class="line">    la=<span class="built_in">strlen</span>(a);</span><br><span class="line">    lb=<span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="built_in">calc</span>();</span><br><span class="line">    <span class="built_in">kmp</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lb;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,nxt[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> z[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    z[<span class="number">0</span>]=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(z[i-l]&lt;r-i<span class="number">+1</span>)<span class="comment">//当前已经相同的部分比已知lcp要大</span></span><br><span class="line">            z[i]=z[i-l];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            z[i]=<span class="built_in">max</span>(r-i<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span>(i+z[i]&lt;n&amp;&amp;s[z[i]]==s[i+z[i]]) z[i]++;</span><br><span class="line">            l=i,r=i+z[i]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> d[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">-1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=l+r-i;<span class="comment">//对称点</span></span><br><span class="line">        <span class="type">int</span> dj=j&gt;=<span class="number">0</span>?d[j]:<span class="number">0</span>;<span class="comment">//不能越界</span></span><br><span class="line">        d[i]=<span class="built_in">max</span>(<span class="built_in">min</span>(dj,r-i<span class="number">+1</span>),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(j-dj&lt;l)<span class="comment">//j-dj+1&lt;=l</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i-d[i]&gt;=<span class="number">0</span>&amp;&amp;i+d[i]&lt;n&amp;&amp;s[i-d[i]]==s[i+d[i]]) d[i]++;</span><br><span class="line">            l=i-d[i]<span class="number">+1</span>,r=i+d[i]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>非递归：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">        x = x * x;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>递归：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> z = <span class="built_in">ksm</span>(x, (y &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    z = z * z;</span><br><span class="line">    <span class="keyword">if</span>(y &amp; <span class="number">1</span>) z = z * x;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="素性测试"><a href="#素性测试" class="headerlink" title="素性测试"></a>素性测试</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> prime[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">ll <span class="title">Ksm</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) res = res * x % p;</span><br><span class="line">        x = x * x % p;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Miller_Rubbin</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d = n - <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!(d &amp; <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        d &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">Ksm</span>(a, d, n);</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        x = <span class="number">1ll</span> * x * x % n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">Miller_Rubbin</span>(x, prime[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Check</span>(t) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Form</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索</title>
    <url>/fb242f20.html</url>
    <content><![CDATA[<h1 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS&amp;BFS"></a>DFS&amp;BFS</h1><blockquote>
<p>广度优先搜索与深度优先搜索，这里不多赘述。</p>
</blockquote>
<p><strong>时间：</strong> 差不多，都高于$O(n+m)$</p>
<p><strong>空间：</strong> BFS 空间消耗远大于 DFS，对于一个满二叉树，每出队一个节点，就会入队两个节点，在第 $k$ 层时将会消耗 $2^k$ 的空间，512MB 的空间最多只能到 29 层。</p>
<p>总结：DFS 适合找任意可行解，BFS 适合找全局最优解。</p>
<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h2><blockquote>
<p>宽搜：queue<br>深搜：stack</p>
</blockquote>
<p>一般解决遍历&#x2F;连通性问题，DFS&#x2F;BFS 都可以做。</p>
<p>深搜只能知道是否连通，但不保证最短距离。</p>
<p>而深搜的码量比较少。</p>
<p><a class="link"   href="https://www.acwing.com/activity/content/problem/content/1480/" >AcWing1112<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="type">int</span> xa, ya, xb, yb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g[x][y] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(x == xb &amp;&amp; y == yb) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Dfs</span>(a, b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; g[i];</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">        cin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Dfs</span>(xa, ya)) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/activity/content/problem/content/1481/" >A1113<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    st[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(g[a][b] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">        cnt += <span class="built_in">DFS</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; m &gt;&gt; n, n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            cin &gt;&gt; g[i];</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">DFS</span>(x, y) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="搜索顺序"><a href="#搜索顺序" class="headerlink" title="搜索顺序"></a>搜索顺序</h2><p>尽可能地减少分支。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310022038275.webp"
                      alt="image.png"
                ></p>
<p><a class="link"   href="https://www.acwing.com/problem/content/1118/" >AcWing1116<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum == n * m)</span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st[x][y]) <span class="keyword">return</span>;</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;=m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(a, b, sum + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    st[x][y] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(x, y, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/description/1119/" >AcWing1117<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string word[N];</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> used[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(string dragon, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>((<span class="type">int</span>)dragon.<span class="built_in">size</span>(), ans);</span><br><span class="line">    used[last]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(g[last][i] &amp;&amp; used[i] &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">DFS</span>(dragon + word[i].<span class="built_in">substr</span>(g[last][i]), i);</span><br><span class="line">    used[last]--;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; dragon &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; word[i];</span><br><span class="line">    <span class="type">char</span> start;</span><br><span class="line">    cin &gt;&gt; start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            string a = word[i], b = word[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt; <span class="built_in">min</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()); ++k)</span><br><span class="line">                <span class="keyword">if</span>(a.<span class="built_in">substr</span>(a.<span class="built_in">size</span>() - k, k) == b.<span class="built_in">substr</span>(<span class="number">0</span>, k))</span><br><span class="line">                &#123;</span><br><span class="line">                    g[i][j] = k;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(word[i][<span class="number">0</span>] == start)</span><br><span class="line">            <span class="built_in">DFS</span>(word[i], i);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/1120/" >P1118<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以放的时候就没有必要加</span></span><br><span class="line"><span class="comment">// 因为假如新加一个组最后得到了最优解，完全可以放到上一组也使得最优解成立</span></span><br><span class="line"><span class="comment">// 所以就依次加，加满为止，并且不考虑顺序，那么就要按照组合的顺序搜索。</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> group[N][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> ans = N;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> group[], <span class="type">int</span> gc, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; gc; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">gcd</span>(p[group[j]], p[i]) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> g, <span class="type">int</span> gc, <span class="type">int</span> tc, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tc == n)</span><br><span class="line">        ans = g;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i] &amp;&amp; <span class="built_in">check</span>(group[g], gc, i))</span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            group[g][gc] = i;</span><br><span class="line">            <span class="built_in">DFS</span>(g, gc + <span class="number">1</span>, tc + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">DFS</span>(g + <span class="number">1</span>, <span class="number">0</span>, tc, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; p[i];</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 先搜第一组，组内目前有0个元素，一共搜了0个元素， 从0下标开始搜</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>不管什么搜索，都可以对应出一个搜索树，如果中间可以判断这个子树一定不合法，那么就没必要接着往下搜了。</p>
<ol>
<li>优化搜索顺序</li>
</ol>
<p>大部分情况下，我们应该先搜索分支较少的节点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310030551562.webp"
                      alt="image.png"
                ></p>
<ol start="2">
<li>排除等效冗余</li>
</ol>
<p>不搜索重复的状态，不考虑顺序的话就采用组合的方法来搜索。</p>
<ol start="3">
<li>可行性剪枝</li>
</ol>
<p>搜到一半发现不合法了。</p>
<ol start="4">
<li>最优性剪枝</li>
</ol>
<p>当搜着发现一定不是最优解，那么就不继续搜了</p>
<ol start="5">
<li>记忆化搜索</li>
</ol>
<p>其实就是 DP</p>
<hr>
<p><a class="link"   href="https://www.acwing.com/problem/content/167/" >AcWing165<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">int</span> ans = N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        <span class="keyword">if</span>(sum[i] + w[u] &lt;= m)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i] += w[u];</span><br><span class="line">            <span class="built_in">DFS</span>(u + <span class="number">1</span>, k);</span><br><span class="line">            sum[i] -= w[u];</span><br><span class="line">        &#125;</span><br><span class="line">    sum[k] = w[u];</span><br><span class="line">    <span class="built_in">DFS</span>(u + <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">    sum[k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每递归一层，就可以放一个小猫，所以放到第 n 层的时候就放完了</span></span><br><span class="line"><span class="comment">// 对于任何一个方案都可以被枚举到</span></span><br><span class="line"><span class="comment">// 对于一个比较轻的猫，和一个重的，重的可以使选择数减少，所以要从大到小排序</span></span><br><span class="line"><span class="comment">// 超载了要砍掉</span></span><br><span class="line"><span class="comment">// 超过了当前最优答案，砍掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">sort</span>(w, w + n);</span><br><span class="line">    <span class="built_in">reverse</span>(w, w + n);</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 当前小猫的下标，当前用了几辆车</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/168/" >AcWing166<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/168/" >AcWing166<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x) &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随意选择空格子，枚举空格子和它上面可以填的数字</span></span><br><span class="line"><span class="comment">// 填完的时候就搜完了</span></span><br><span class="line"><span class="comment">// 优化搜索顺序： 选择哪个空格子？优先选择可以填的数较少的格子</span></span><br><span class="line"><span class="comment">// 可行性剪枝</span></span><br><span class="line"><span class="comment">// 位运算：状态压缩，来表示每一行的状态</span></span><br><span class="line"><span class="comment">// lowbit 快速找最后一个1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">9</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="type">int</span> ones[M], mp[M];</span><br><span class="line"><span class="type">int</span> row[N], col[N], cell[<span class="number">3</span>][<span class="number">3</span>]; <span class="comment">// 分别代表这一行/这一列/这一个九宫格里还可以填哪些数，状态压缩</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        row[i] = col[i] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>; <span class="comment">// 一开始每一行每一列的每一个位置都可以放</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">            cell[i][j] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>; <span class="comment">// 每一个九宫格的每一个位置都可以放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> row[x] &amp; col[y] &amp; cell[x / <span class="number">3</span>][y / <span class="number">3</span>];<span class="comment">//哪些数能填，与一下</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> t, <span class="type">bool</span> is_set)</span> <span class="comment">//修改/清空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is_set) str[x * N + y] = <span class="string">&#x27;1&#x27;</span> + t;</span><br><span class="line">    <span class="keyword">else</span> str[x * N + y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">    <span class="keyword">if</span>(!is_set) v = -v;</span><br><span class="line">    row[x] -= v; <span class="comment">// t可以用的位置被占据</span></span><br><span class="line">    col[y] -= v;</span><br><span class="line">    cell[x / <span class="number">3</span>][y / <span class="number">3</span>] -= v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!cnt) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> minv = <span class="number">10</span>; <span class="comment">// 最多有九个分支，取最小值，初始值设为10</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i * N + j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> state = <span class="built_in">get</span>(i, j); <span class="comment">// 得到这个状态有多少个1</span></span><br><span class="line">                <span class="keyword">if</span>(ones[state] &lt; minv)</span><br><span class="line">                &#123;</span><br><span class="line">                    minv = ones[state];</span><br><span class="line">                    x = i, y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> state = <span class="built_in">get</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = state; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = mp[<span class="built_in">lowbit</span>(i)];</span><br><span class="line">        <span class="built_in">draw</span>(x, y, t, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">DFS</span>(cnt - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">draw</span>(x, y, t, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) mp[<span class="number">1</span> &lt;&lt; i] = i; <span class="comment">// 每个状态对应着第几个位置被选</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">            ones[i] += i &gt;&gt; j &amp; <span class="number">1</span>; <span class="comment">// 这个状态有多少个1</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str), str[<span class="number">0</span>] != <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 有多少空位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; ++j, ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(str[k] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> t = str[k] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    <span class="built_in">draw</span>(i, j, t, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">DFS</span>(cnt);</span><br><span class="line">        <span class="built_in">puts</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/description/169/" >AcWing167<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N], sum, length;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u * length == sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(s == length) <span class="keyword">return</span> <span class="built_in">DFS</span>(u + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 剪枝 3-1 按照组合方式枚举</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(s + w[i] &gt; length) <span class="keyword">continue</span>;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">DFS</span>(u, s + w[i], i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        st[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 剪枝 3-3 这根要拼的木棒第一个木棍就不行没必要看</span></span><br><span class="line">        <span class="keyword">if</span>(!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 剪枝 3-4 这根要拼的木棒最后一个木棍不行也没必要看</span></span><br><span class="line">        <span class="keyword">if</span>(s + w[i] == length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="comment">// 剪枝 3-2 相同长度的不行的没必要重复看</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; w[j] == w[i]) j++;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; w[i];</span><br><span class="line">            sum += w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(w, w + n);</span><br><span class="line">        <span class="built_in">reverse</span>(w, w + n); <span class="comment">// 剪枝2 从大到小枚举，减少分支</span></span><br><span class="line">        length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前拼的这根木棒的编号，当前拼的这根木棒的长度，从第几根木棍开始拼</span></span><br><span class="line">            <span class="keyword">if</span>(sum % length == <span class="number">0</span> &amp;&amp; <span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) <span class="comment">// 剪枝1 只有能整除才是合法的</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; length &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="迭代加深"><a href="#迭代加深" class="headerlink" title="迭代加深"></a>迭代加深</h2><p>搜索树可能会比较深，但合法方案在一个比较浅的位置。</p>
<p>那么我们可以一层一层地搜，不断增大搜索区，有点像 BFS。</p>
<p>宽搜空间是指数级别的，而迭代加深的复杂度是线性的。</p>
<p>其实就是按照 BFS 方式扩展，按照 DFS 的方式搜索。</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/172/" >AcWing170<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>比如这道题，最大可以到达 100 层，但是最快 7 层就可以到达，所以没必要搜那么多，就可以用迭代加深来做。</p>
<p>剪枝：</p>
<ol>
<li>优先枚举较大的数。</li>
<li>排除等效冗余，枚举下一个数的时候，可以枚举之前两个数的和。判断一下每个数有没有被枚举过。</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u &gt; depth)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> st[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(path[u - <span class="number">1</span>] == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = u - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt;=<span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = path[i] + path[j];</span><br><span class="line">            <span class="keyword">if</span>(s &gt; n || s &lt;= path[u - <span class="number">1</span>] || st[s]) <span class="keyword">continue</span>;</span><br><span class="line">            st[s] = <span class="literal">true</span>;</span><br><span class="line">            path[u] = s;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">DFS</span>(u + <span class="number">1</span>, depth)) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">DFS</span>(<span class="number">1</span>, depth)) depth++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; ++i)</span><br><span class="line">            cout &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="双向DFS"><a href="#双向DFS" class="headerlink" title="双向DFS"></a>双向DFS</h2><p>与双向 BFS 原理相同。</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/173/" >AcWing171<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>这个题不能用背包写，因为体积很大。</p>
<p>那就爆搜，以此枚举每个物品选或者不选，那就是 $2^{46}$，想想优化。</p>
<p>先看看前一半物品能凑出来的重量有哪些。</p>
<p>那么就是 $2^{23}$ 可以排序+判重。</p>
<p>然后再枚举后一半的物品选&#x2F;不选，</p>
<p>那就看下后面有没有 $s + l \le w$</p>
<p>那如何找到一个小于等于某个数的最大值呢？二分。</p>
<p>$2^{\frac{N}{2}}+2^{\frac{N}{2}}\times{\frac{N}{2}}$，其实就是先爆搜出前一半，然后把它存下来，再爆搜后一半，用到前一半的时候直接查就可以了，相当于空间换时间。</p>
<p>由于第二部分需要用到二分，所以一开始可以多预处理一些，降低总体时间复杂度。</p>
<p>枚举顺序：先枚举大的数。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310031557311.webp"
                      alt="image.png|400"
                ></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">46</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="type">int</span> weights[<span class="number">1</span> &lt;&lt; <span class="number">25</span>], cnt = <span class="number">1</span>; <span class="comment">// weights[0] = 0</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == k)</span><br><span class="line">    &#123;</span><br><span class="line">        weights[cnt++] = s;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS1</span>(u + <span class="number">1</span>, s);</span><br><span class="line">    <span class="keyword">if</span>((ll)s + w[u] &lt;= m) <span class="built_in">DFS1</span>(u + <span class="number">1</span>, s + w[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(weights[mid] &lt;= m - s) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, weights[l] + s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS2</span>(u + <span class="number">1</span>, s);</span><br><span class="line">    <span class="keyword">if</span>((ll)s + w[u] &lt;= m) <span class="built_in">DFS2</span>(u + <span class="number">1</span>, s + w[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">sort</span>(w, w + n);</span><br><span class="line">    <span class="built_in">reverse</span>(w, w + n);</span><br><span class="line">    k = n / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">DFS1</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(weights, weights + cnt);</span><br><span class="line">    cnt = <span class="built_in">unique</span>(weights, weights + cnt) - weights;</span><br><span class="line">    <span class="built_in">DFS2</span>(k, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="IDA-Star"><a href="#IDA-Star" class="headerlink" title="IDA-Star"></a>IDA-Star</h2><blockquote>
<p>一般配合迭代加深来做</p>
</blockquote>
<p>有一个层数上限，在每个节点的位置，都要预估一下最少需要多少步才能得到我想要的答案。</p>
<p>如果一定在层数上限之外的话，那么就要扩大范围，这也相当于迭代加深的一个剪枝。</p>
<p>只需要保证<strong>估价函数小于等于真实值</strong>即可，那么正确性就是很显然的。</p>
<p>而且不需要优先队列，所以码量比较小。</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/182/" >AcWing180<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>对于一段长度为 $i$ 的区间，一共有 $n - i + 1$ 种选择，然后剩下 $n - i$ 本书，还剩下 $n - i$ 个空裆，所以一共有 $(n-i+1)\times(n-i)$ 种选择，</p>
<p>于是一共有 $\sum_{i &#x3D; 1}^n(n-i+1)\times(n-i)$ 种选择。</p>
<p>这里面是有重复的，比如相对位移是等效的。</p>
<p>所以要除以二。</p>
<p>$\frac{1\times2+2\times3+\dots+n\times(n+1)}{2}&#x3D;\frac{n\times(n-1)\times(n-2)}{3 \times2}$</p>
<p>也就是每次有 560 种选择，一共最多选四次，所以理论复杂度为 $560^4$，如果用双向广搜&#x2F;双向深搜也可以过。</p>
<p>最少排多少次？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310040505446.webp"
                      alt="image.png"
                ></p>
<p>每次会更改 3 个后继，统计一下序列中所有需要被更改的后继，那么最小更改次数就是 $\lceil\frac{tot}{3}\rceil$ 可以作为估价函数。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310040555098.webp"
                      alt="image.png"
                ></p>
<p>#Q 为什么这样会TLE？？？</p>
<p>因为判断条件应该先判断深度再去 DFS。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> w[<span class="number">5</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; n; ++i)</span><br><span class="line">        <span class="comment">// tot += (q[i + 1] != q[i] + 1);</span></span><br><span class="line">        <span class="keyword">if</span>(q[i + <span class="number">1</span>] != q[i] + <span class="number">1</span>) tot++;</span><br><span class="line">    <span class="keyword">return</span> (tot + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> max_depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth + <span class="built_in">f</span>() &gt; max_depth) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>; l + i - <span class="number">1</span> &lt; n; l++)</span><br><span class="line">    <span class="comment">// for(int l = 0; l &lt; n; l++)</span></span><br><span class="line">    <span class="comment">//     for(int r = l; r &lt; n; r++)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r = l + i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = r + <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(w[depth], q, <span class="built_in">sizeof</span>(q));</span><br><span class="line">                <span class="type">int</span> y = l;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> x = r + <span class="number">1</span>; x &lt;= k; x++, y++)</span><br><span class="line">                    q[y] = w[depth][x];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> x = l; x &lt;= r; x++, y++)</span><br><span class="line">                    q[y] = w[depth][x];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">DFS</span>(depth + <span class="number">1</span>, max_depth)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(q, w[depth], <span class="built_in">sizeof</span>(w[depth]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(depth &lt; <span class="number">5</span> &amp;&amp; !<span class="built_in">DFS</span>(<span class="number">0</span>, depth)) depth++; <span class="comment">// 判断顺序不要错了！</span></span><br><span class="line">        <span class="keyword">if</span>(depth &gt;= <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;5 or more&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/183/" >AcWing181<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>把中间的八个格子变成同一个数，输出最短的一个操作序列（字典序最小）；</p>
<p>并且输出最后变成了什么数字。</p>
<p>按照字典序枚举去爆搜就可以得到字典序最小的操作。</p>
<p>可能的操作深度会很深，但是最终答案不会很深，很适合迭代加深。</p>
<p>估价函数：</p>
<p>对于中间八个格子每次把一个格子拉出去，再拉进来，相当于每次只能改变一个格子的值。</p>
<p>然后每次统计一下中间八个格子里出现最多的数，用 8 减去它就是估价，也就是最少需要操作的次数。</p>
<p>对于操作，可以人工打一个表，对每一个操作的序列写出来。</p>
<p>小优化：如果上一次拉了一下，这次不能是反向操作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310040616980.webp"
                      alt="image.png"
                ></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> op[<span class="number">8</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">22</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">23</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>&#125;,</span><br><span class="line">    &#123;<span class="number">23</span>, <span class="number">21</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">22</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> opposite[] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> center[] = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>&#125;;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> path[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// static?</span></span><br><span class="line">    <span class="type">int</span> sum[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) sum[q[center[i]]]++;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) s = <span class="built_in">max</span>(sum[i], s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span> - s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = q[op[x][<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) q[op[x][i]] = q[op[x][i + <span class="number">1</span>]];</span><br><span class="line">    q[op[x][<span class="number">6</span>]] = t;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> max_depth, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth + <span class="built_in">f</span>() &gt; max_depth) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(last != opposite[i]) <span class="comment">// 防止第一次-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">operate</span>(i);</span><br><span class="line">            path[depth] = i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">DFS</span>(depth + <span class="number">1</span>, max_depth, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">operate</span>(opposite[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; q[<span class="number">0</span>], q[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) cin &gt;&gt; q[i];</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">DFS</span>(<span class="number">0</span>, depth, <span class="number">-1</span>)) depth++;</span><br><span class="line">        <span class="keyword">if</span>(!depth) <span class="built_in">printf</span>(<span class="string">&quot;No moves needed&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, path[i] + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>, q[<span class="number">6</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><blockquote>
<p>分为最短距离（走迷宫）和最小步数两类问题</p>
</blockquote>
<ul>
<li>可以解决求最小的问题。</li>
<li>基于迭代，不会爆栈。</li>
</ul>
<p><strong>最短距离：</strong></p>
<p>在一个二维矩阵中从某个点走到另一个点的最短距离，所有边权相同。</p>
<p><strong>最小步数：</strong></p>
<p>移动地图，使得地图从原来的变成另一种地图所需要的最小步数，每个状态是一个点，状态的转移对应边权为1，也就是求从一个状态转移到另一个状态所需要的最小代价。</p>
<h2 id="Flood-Fill"><a href="#Flood-Fill" class="headerlink" title="Flood Fill"></a>Flood Fill</h2><blockquote>
<p>顾名思义，洪水填充</p>
</blockquote>
<p>每次选择一个新加的格子，看看周围是否有可以扩展的格子。</p>
<p>可以在线性时间内找到某个点所在的连通块。</p>
<p>例题：</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/description/1099/" >AcWing1097<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>统计连通块的数量。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = t.x - <span class="number">1</span>; i &lt;= t.x + <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = t.y - <span class="number">1</span>; j &lt;= t.y + <span class="number">1</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == t.x &amp;&amp; j == t.y) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; n - <span class="number">1</span> || j &lt; <span class="number">0</span> || j &gt; m - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;.&#x27;</span> || vis[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;W&#x27;</span> &amp;&amp; !vis[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Bfs</span>(i, j);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.acwing.com/problem/content/1100/" >AcWing1098<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>统计连通块的数量及大小。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, dy[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        area++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nx = t.x + dx[i], ny = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">1</span> || nx &gt; n || ny &lt; <span class="number">0</span> || ny &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((g[t.x][t.y] &gt;&gt; i) &amp; <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// 当前位置是墙</span></span><br><span class="line">            q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">            vis[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[i][j]);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                area = <span class="built_in">max</span>(area, <span class="built_in">Bfs</span>(i, j));</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>, cnt, area);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.acwing.com/problem/content/1108/" >AcWing1106<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>一个连通块周围没有比它低的，它就是山峰；</p>
<p>周围没有比它高的，它就是山谷。</p>
<p>求山峰山谷的数量。</p>
<p>统计每个连通块，统计的时候判断它和周围格子的关系</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N][N];</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">bool</span> &amp;has_higher, <span class="type">bool</span> &amp;has_lower)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>  i = t.x - <span class="number">1</span>; i &lt;= t.x + <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = t.y - <span class="number">1</span>; j &lt;= t.y + <span class="number">1</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; n || j &lt; <span class="number">1</span> || j &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(h[i][j] != h[t.x][t.y])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(h[i][j] &gt; h[t.x][t.y]) has_higher = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> has_lower = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!vis[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                    vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i][j]);</span><br><span class="line">    <span class="type">int</span> peak = <span class="number">0</span>, valley = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">bool</span> has_higher = <span class="literal">false</span>, has_lower = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">Bfs</span>(i, j, has_higher, has_lower);</span><br><span class="line">            <span class="keyword">if</span>(!has_higher) peak++;</span><br><span class="line">            <span class="keyword">if</span>(!has_lower) valley++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, peak, valley);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="最短路模型"><a href="#最短路模型" class="headerlink" title="最短路模型"></a>最短路模型</h2><p>所有边权都相同，那么就有个性质，由宽搜第一次搜到的就是最短的路。</p>
<p>小证明，给一个边权为 1 的图：</p>
<ol>
<li>两段性：队列中相邻的两个位置到起点的最短距离最多差一。</li>
<li>单调性：前面都是比较小的一段，后面都是比较大的一段。<ol>
<li>初始：就一个点，到起点距离为 0 。</li>
<li>假设当前满足，取出一个 x ，然后把它扩展出的没有走过的点都放到队尾，这样一个队列仍然满足性质。</li>
</ol>
</li>
</ol>
<p>类比一下堆优化的 Dijkstra 算法，当队列不空时，每次选出堆顶，枚举它能到的边，然后更新一遍，出队时一定是最小值。</p>
<p>习题：</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/1078/" >AcWing1076<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>求左上角到右下角的最短路径。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line">PII pre[N][N];</span><br><span class="line">PII ans[N * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="built_in">sizeof</span>(pre));</span><br><span class="line">    pre[x][y] = &#123;n, n&#125;; <span class="comment">// 标记下被遍历过了</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nx = t.x + dx[i];</span><br><span class="line">            <span class="type">int</span> ny = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">1</span> || nx &gt; n || ny &lt; <span class="number">1</span> || ny &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(pre[nx][ny].x != <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 被遍历过了</span></span><br><span class="line">            q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">            pre[nx][ny] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[i][j]);</span><br><span class="line">    <span class="built_in">Bfs</span>(n, n);</span><br><span class="line">    <span class="function">PII <span class="title">end</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, end.x - <span class="number">1</span>, end.y - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(end.x == n &amp;&amp; end.y == n) <span class="keyword">break</span>;</span><br><span class="line">        end = pre[end.x][end.y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.acwing.com/problem/content/190/" >AcWing188<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>走路方式变成了中国象棋的马的步。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">155</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sx, sy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">                sx = i, sy = j;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;sx, sy&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nx = t.x + dx[i];</span><br><span class="line">            <span class="type">int</span> ny = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[nx][ny] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dist[nx][ny] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[nx][ny] == <span class="string">&#x27;H&#x27;</span>) <span class="keyword">return</span> dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">            dist[nx][ny] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Bfs</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.acwing.com/problem/content/1102/" >AcWing1100<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(n);</span><br><span class="line">    dist[n] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t == k) <span class="keyword">return</span> dist[k];</span><br><span class="line">        <span class="keyword">if</span>(t + <span class="number">1</span> &lt; N &amp;&amp; dist[t + <span class="number">1</span>] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[t + <span class="number">1</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; dist[t - <span class="number">1</span>] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[t - <span class="number">1</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t * <span class="number">2</span> &lt; N &amp;&amp; dist[t * <span class="number">2</span>] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[t * <span class="number">2</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int t;</span></span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">    <span class="comment">// while(t--)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Bfs</span>());</span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="多源BFS"><a href="#多源BFS" class="headerlink" title="多源BFS"></a>多源BFS</h2><p><a class="link"   href="https://www.acwing.com/problem/content/175/" >AcWing173<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>求每个点到所有 1 的距离的最小值。</p>
<p>分别输出这些最小值。</p>
<hr>
<p>朴素的做法：分别以每个 1 为起点遍历整张图，保留该点的距离最小值，复杂度为 $O(n^2)$ </p>
<p>按照最短路的思路，可以建一个虚拟源点，把它像每个 1 连接一条长度为 0 的边，然后跑最短路。</p>
<hr>
<p>BFS：</p>
<p>一开始把所有 1 的距离初始化为 0 并加到队列里，然后后面就和搜索一样了。</p>
<p>一个点第一次出队时一定是最小值，证明方法同上。</p>
<p>所以每个点只会被更新一次。</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/175/" >A173<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nx = t.x + dx[i];</span><br><span class="line">            <span class="type">int</span> ny = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dist[nx][ny] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dist[nx][ny] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">    <span class="built_in">BFS</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dist[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="最小步数模型"><a href="#最小步数模型" class="headerlink" title="最小步数模型"></a>最小步数模型</h2><blockquote>
<p>把某个东西从某个状态转移到另外某个状态需要的最少步数。</p>
</blockquote>
<p><a class="link"   href="https://www.acwing.com/problem/content/1109/" >A1107<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309171957729.webp"
                      alt="image.png"
                ></p>
<p>给定目标状态，计算最少操作次数以及操作过程，操作过程按照字典序最小输出。</p>
<p>一般字典序不是为了增加难度，而是为了好评，正常写一般就符合条件。</p>
<p><del>当然可以用康托展开来做。</del></p>
<p>存状态？哈希</p>
<p>用 unordered_map 来做哈希，它适合查询，而一般的 map 适合存储，详情可以看 <a class="link"   href="https://blog.csdn.net/zou_albert/article/details/106983268" >unordered_map<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>；</p>
<p>字典序问题扩展状态的时候按照 ABC 的顺序去扩展即可。</p>
<p>因为这样能保证第一次搜到的永远是字典序最小并且最优的。</p>
<p>code:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[<span class="number">2</span>][<span class="number">4</span>]; <span class="comment">// 矩阵</span></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; dist;</span><br><span class="line">unordered_map&lt;string, pair&lt;<span class="type">char</span>, string&gt; &gt; pre; <span class="comment">//上一步进行了什么操作，上一次是什么状态</span></span><br><span class="line">queue&lt;string&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(string state)</span> <span class="comment">// 放入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">        g[<span class="number">0</span>][i] = state[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>, j = <span class="number">4</span>; i &gt;= <span class="number">0</span>; --i, ++j)</span><br><span class="line">        g[<span class="number">1</span>][i] = state[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Get</span><span class="params">()</span> <span class="comment">// 取出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        res += g[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        res += g[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">move0</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Set</span>(state);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="built_in">swap</span>(g[<span class="number">0</span>][i], g[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">move1</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Set</span>(state);</span><br><span class="line">    <span class="type">char</span> v0 = g[<span class="number">0</span>][<span class="number">3</span>], v1 = g[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(g[<span class="number">0</span>][i], g[<span class="number">0</span>][i - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">swap</span>(g[<span class="number">1</span>][i], g[<span class="number">1</span>][i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = v0;</span><br><span class="line">    g[<span class="number">1</span>][<span class="number">0</span>] = v1;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">move2</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Set</span>(state);</span><br><span class="line">    <span class="type">char</span> v = g[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">1</span>] = g[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    g[<span class="number">1</span>][<span class="number">1</span>] = g[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    g[<span class="number">1</span>][<span class="number">2</span>] = g[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">2</span>] = v;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bfs</span><span class="params">(string start, string end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) <span class="keyword">return</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        string m[<span class="number">3</span>];</span><br><span class="line">        m[<span class="number">0</span>] = <span class="built_in">move0</span>(t);</span><br><span class="line">        m[<span class="number">1</span>] = <span class="built_in">move1</span>(t);</span><br><span class="line">        m[<span class="number">2</span>] = <span class="built_in">move2</span>(t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            string mt = m[i];</span><br><span class="line">            <span class="keyword">if</span>(dist.<span class="built_in">count</span>(mt) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[mt] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                pre[mt] = &#123;<span class="built_in">char</span>(i + <span class="string">&#x27;A&#x27;</span>), t&#125;; <span class="comment">// t串经过A/B/C操作转化得到mt</span></span><br><span class="line">                <span class="keyword">if</span>(mt == end) <span class="keyword">break</span>; <span class="comment">// 第一次找到即最短的</span></span><br><span class="line">                q.<span class="built_in">push</span>(mt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    string start, end;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        end += <span class="built_in">char</span>(x + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) start += <span class="built_in">char</span>(i + <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="built_in">Bfs</span>(start, end);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[end]);</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">while</span>(end != start)</span><br><span class="line">    &#123;</span><br><span class="line">        res += pre[end].first;</span><br><span class="line">        end = pre[end].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">size</span>()) cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="双端队列广搜"><a href="#双端队列广搜" class="headerlink" title="双端队列广搜"></a>双端队列广搜</h2><blockquote>
<p>01BFS</p>
</blockquote>
<p><a class="link"   href="https://www.acwing.com/problem/content/177/" >A175<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> e[<span class="number">550</span>][<span class="number">550</span>];</span><br><span class="line"><span class="type">int</span> dist[<span class="number">550</span>][<span class="number">550</span>];</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;<span class="comment">//左上，右上，左下，右下</span></span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">1</span>;</span><br><span class="line">	<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) y=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y,d;</span><br><span class="line">    <span class="built_in">point</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">point</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c):<span class="built_in">x</span>(a),<span class="built_in">y</span>(b),<span class="built_in">d</span>(c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//对于一个九宫格，以中间位置为参照，上下左右一定要和它不同，边权为0，否则为1.</span></span><br><span class="line"><span class="comment">//而四个角，则需要特殊处理，若为&#x27;\&#x27;，则左上角和右下角必须和它相同，若为&#x27;/&#x27;，则右上角和左下角必须相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//应按照点</span></span><br><span class="line"><span class="type">void</span> _01BFS()</span><br><span class="line">&#123;</span><br><span class="line">    deque&lt;point&gt; q;</span><br><span class="line">    q.<span class="built_in">push_front</span>(<span class="built_in">point</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    dist[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        point now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span>(now.x==n&amp;&amp;now.y==m) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nx=now.x+dx[i],ny=now.y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">0</span>||ny&lt;<span class="number">0</span>||nx&gt;n||ny&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="comment">//左上</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(e[now.x][now.y]==<span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(now.d&lt;dist[nx][ny])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dist[nx][ny]=now.d;</span><br><span class="line">                        q.<span class="built_in">push_front</span>(<span class="built_in">point</span>(nx,ny,dist[nx][ny]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//&#x27;/&#x27;</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(now.d<span class="number">+1</span>&lt;dist[nx][ny])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dist[nx][ny]=now.d<span class="number">+1</span>;</span><br><span class="line">                        q.<span class="built_in">push_back</span>(<span class="built_in">point</span>(nx,ny,dist[nx][ny]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)<span class="comment">//右上</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(e[now.x][now.y<span class="number">+1</span>]==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(now.d&lt;dist[nx][ny])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dist[nx][ny]=now.d;</span><br><span class="line">                        q.<span class="built_in">push_front</span>(<span class="built_in">point</span>(nx,ny,dist[nx][ny]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//&#x27;\&#x27;</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(now.d<span class="number">+1</span>&lt;dist[nx][ny])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dist[nx][ny]=now.d<span class="number">+1</span>;</span><br><span class="line">                        q.<span class="built_in">push_back</span>(<span class="built_in">point</span>(nx,ny,dist[nx][ny]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">2</span>)<span class="comment">//左下</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(e[now.x<span class="number">+1</span>][now.y]==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(now.d&lt;dist[nx][ny])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dist[nx][ny]=now.d;</span><br><span class="line">                        q.<span class="built_in">push_front</span>(<span class="built_in">point</span>(nx,ny,dist[nx][ny]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//&#x27;\&#x27;</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(now.d<span class="number">+1</span>&lt;dist[nx][ny])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dist[nx][ny]=now.d<span class="number">+1</span>;</span><br><span class="line">                        q.<span class="built_in">push_back</span>(<span class="built_in">point</span>(nx,ny,dist[nx][ny]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">3</span>)<span class="comment">//右下</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(e[now.x<span class="number">+1</span>][now.y<span class="number">+1</span>]==<span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(now.d&lt;dist[nx][ny])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dist[nx][ny]=now.d;</span><br><span class="line">                        q.<span class="built_in">push_front</span>(<span class="built_in">point</span>(nx,ny,dist[nx][ny]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//&#x27;/&#x27;</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(now.d<span class="number">+1</span>&lt;dist[nx][ny])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dist[nx][ny]=now.d<span class="number">+1</span>;</span><br><span class="line">                        q.<span class="built_in">push_back</span>(<span class="built_in">point</span>(nx,ny,dist[nx][ny]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,e[i]<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">if</span>((n+m)%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO SOLUTION&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">                dist[i][j]=<span class="number">0x7fffffff</span>;</span><br><span class="line">        _01BFS();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[n][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="双向广搜"><a href="#双向广搜" class="headerlink" title="双向广搜"></a>双向广搜</h2><p>状态较少的时候，其实就和普通 BFS 差不多，比如 <em>最短路模型</em> 或者 <em>洪水填充</em>。</p>
<p>但是状态变多的时候，就可能会超时，比如 <em>最小步数模型</em>。</p>
<p>在 BFS 中，每一层新加的点都是上一层的两倍，也就是说这是一个指数增加的过程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309230940131.webp"
                      alt="image.png"
                ></p>
<p>比如这样，就只需要搜红色面积内的点，大大节约了时间和空间。</p>
<p>小优化：每次选择元素较少的方向扩展。</p>
<hr>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P1032" >字串变换<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(queue&lt;string&gt; &amp;q, unordered_map&lt;string, <span class="type">int</span>&gt; &amp;da, unordered_map&lt;string, <span class="type">int</span>&gt; &amp;db, string a[], string b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string t = q.<span class="built_in">front</span>(); <span class="comment">// 扩展</span></span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)t.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.<span class="built_in">substr</span>(i, a[j].<span class="built_in">size</span>()) == a[j]) <span class="comment">// 找到可以变换的字串</span></span><br><span class="line">            &#123;</span><br><span class="line">                string state = t.<span class="built_in">substr</span>(<span class="number">0</span>, i) + b[j] + t.<span class="built_in">substr</span>(i + a[j].<span class="built_in">size</span>()); <span class="comment">// 拼接</span></span><br><span class="line">                <span class="keyword">if</span>(db.<span class="built_in">count</span>(state)) <span class="keyword">return</span> da[t] + <span class="number">1</span> + db[state]; <span class="comment">// 如果相遇了，那么就返回答案</span></span><br><span class="line">                <span class="keyword">if</span>(da.<span class="built_in">count</span>(state)) <span class="keyword">continue</span>; <span class="comment">// 如果找过了就不找了</span></span><br><span class="line">                da[state] = da[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(state); <span class="comment">//更新状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>; <span class="comment">// 无法相遇，即这种状态不合法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bfs</span><span class="params">(string A, string B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A == B) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    queue&lt;string&gt; qa, qb;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; da, db; <span class="comment">// 从 a/b 到这个串需要几步</span></span><br><span class="line">    qa.<span class="built_in">push</span>(A), da[A] = <span class="number">0</span>;</span><br><span class="line">    qb.<span class="built_in">push</span>(B), db[B] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(qa.<span class="built_in">size</span>() &amp;&amp; qb.<span class="built_in">size</span>()) <span class="comment">// 只要是连通的就一定能搜到</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">if</span>(qa.<span class="built_in">size</span>() &lt;= qb.<span class="built_in">size</span>()) t = <span class="built_in">extend</span>(qa, da, db, a, b); <span class="comment">// 更新 a // 往元素少的方向扩展</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="built_in">extend</span>(qb, db, da, b, a); <span class="comment">// 更新 b</span></span><br><span class="line">        <span class="keyword">if</span>(t &lt;= <span class="number">10</span>) <span class="keyword">return</span> t; <span class="comment">// 找到了合法的方案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>; <span class="comment">// 找不到合法的方案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string A, B;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a[n] &gt;&gt; b[n]) ++n;</span><br><span class="line">    <span class="type">int</span> step = <span class="built_in">Bfs</span>(A, B);</span><br><span class="line">    <span class="keyword">if</span>(step &gt; <span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">&quot;NO ANSWER!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, step);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="A-star"><a href="#A-star" class="headerlink" title="A-star"></a>A-star</h2><blockquote>
<p>一种结合了 Dijkstra 和贪心最优原则的一种搜索算法。</p>
</blockquote>
<p>应用场景：和双向广搜一样，都是求最短距离，但是状态空间<strong>非常庞大</strong>（步数小的时候直接 BFS 即可），直接搜会搜到非常多的状态，导致超时。</p>
<p>所以需要加上一个启发函数，作用是从起点开始搜，搜非常少的状态就可以求出起点到终点的最短路径。</p>
<ol>
<li>把 BFS 中的队列换为优先队列（小根堆）</li>
<li>每个状态（预测距离）存真实距离（起点走到当前点）加上估计距离（当前点到终点），也就是存到当前这条路径到终点的估计值，每次挑一个预测距离最小的点来扩展。</li>
<li>终点第一次出队时，循环结束。</li>
<li>满足<strong>估计距离小于等于真实距离</strong>，这样才可以满足<strong>出队的时候</strong>距离才是最小的。</li>
<li>满足有解，不然还会全搜一遍，还不如 BFS。</li>
<li>估价函数返回值 $\in{[0,d]}$，$d$ 为到终点的真实最短距离，越接近越好。</li>
</ol>
<p>反证法：假设终点第一次出队的时候不是最小值，即$dist(t)&gt;d$，队列中肯定存在最优解的某一个点，设为 $u$。</p>
<p>$$<br>d(u) + f(u) &lt;&#x3D; d(u) + g(u) &#x3D; d<br>$$<br>$$<br>\therefore d(t) + f(t) &#x3D; dist(t) &gt; d \ge d(u) + f(u)<br>$$</p>
<p>也就是假如队列里有最优解，那么它的估计距离一定是最小的，所以最优解一定最先出队，否则与优先队列规则，优先出 $f + d$ 小的元素矛盾。</p>
<p>所以出队的时候一定是最小值。</p>
<p>它只能保证终点出队的时候距离最小，但不能保证其他点出队的时候是最小值（算法竞赛-进阶指南的错误）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310020935436.webp"
                      alt="image.png"
                ></p>
<p>比如对于这样一个例子，这个交点它就不成立，并且每个点不一定只被扩展一次（除了终点）。</p>
<p>然后接着放下走把终点入队的时候，发现队列里有比这个情况小的预测距离，所以就会“拨乱反正”，重新走正确的路径，那么接着出队的时候，这条新路肯定已经被走完了，此时终点距离已经被更新成了最小值。</p>
<ul>
<li>BFS：每个状态只会入队一次，所以入队的时候进行判重。</li>
<li>Dijkstra：每个状态只会出队一次，所以可以出队的时候判重。</li>
<li>SPFA：每个状态在每个时刻最多在队列中出现一次，所以可以在入队的时候判重。</li>
<li>A-star：每个状态不一定只入队一次或出队一次，所以不能判重。</li>
</ul>
<p>估计距离一般用经典的估价函数，否则满足要求即可。</p>
<h3 id="八数码问题"><a href="#八数码问题" class="headerlink" title="八数码问题"></a>八数码问题</h3><p>把八个数字放到一个九宫格里，每次可以移动一个数字到空闲位置，现给定一个初始状态，求最小步数得到终止状态：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310020947510.webp"
                      alt="image.png|200"
                ></p>
<p>任意输出一种最小步数的方案即可。</p>
<p>有解的充要条件：序列的逆序对数量为偶数，如果为奇数，那么就一定无解。</p>
<p>有解的话，逆序对数量一定是偶数。如果是行内移动，那么逆序对数量不会变。</p>
<p>而往上&#x2F;下移动，相当于把它移动到某两个数的前面&#x2F;后面，也就是说只改变了两对逆序对。</p>
<p>也就是说每次移动不会改变逆序对数量的奇偶性，而末状态的逆序对数量为偶数（0），所以逆序对数量必须是奇数。</p>
<p>那么偶数一定是有解的，奇数一定是无解的。</p>
<p>估价函数：</p>
<p>每次移动只会改变某个数的一个位置，于是估价函数可以取当前状态的每一个数字和目标位置的曼哈顿距离之和。</p>
<p>因为不能直接过去，需要迂回一下，所以是满足<strong>估计距离小于等于实际距离</strong>这样一个条件的。</p>
<hr>
<p><a class="link"   href="https://www.acwing.com/problem/content/181/" >Acwing179<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, string&gt; PIS;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">ed</span><span class="params">(<span class="string">&quot;12345678x&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)state.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">if</span>(state[i] != <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = state[i] - <span class="string">&#x27;1&#x27;</span>; <span class="comment">// 这个数字在 ed 中的坐标</span></span><br><span class="line">            res += <span class="built_in">abs</span>(i / <span class="number">3</span> - t / <span class="number">3</span>) + <span class="built_in">abs</span>(i % <span class="number">3</span> - t % <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Bfs</span><span class="params">(string start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; dist;</span><br><span class="line">    unordered_map&lt;string, pair&lt;<span class="type">char</span>, string&gt; &gt; prev;</span><br><span class="line">    priority_queue&lt;PIS, vector&lt;PIS&gt;, greater&lt;PIS&gt; &gt; heap;</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="built_in">f</span>(start), start&#125;);</span><br><span class="line">    <span class="type">char</span> op[] = <span class="string">&quot;urdl&quot;</span>;</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        string state = t.y;</span><br><span class="line">        <span class="keyword">if</span>(state == ed) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> nx, ny;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(state[i] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nx = i / <span class="number">3</span>;</span><br><span class="line">                ny = i % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string source = state;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = nx + dx[i], b = ny + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt; <span class="number">2</span> || b &lt; <span class="number">0</span> || b &gt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            state = source;</span><br><span class="line">            <span class="built_in">swap</span>(state[nx * <span class="number">3</span> + ny], state[a * <span class="number">3</span> + b]);</span><br><span class="line">            <span class="keyword">if</span>(!dist.<span class="built_in">count</span>(state) || dist[state] &gt; dist[source] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[state] = dist[source] + <span class="number">1</span>;</span><br><span class="line">                prev[state] = &#123;op[i], source&#125;;</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[state] + <span class="built_in">f</span>(state), state&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">while</span>(ed != start)</span><br><span class="line">    &#123;</span><br><span class="line">        res += prev[ed].x;</span><br><span class="line">        ed = prev[ed].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string start, seq;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; c)</span><br><span class="line">    &#123;</span><br><span class="line">        start += c;</span><br><span class="line">        <span class="keyword">if</span>(c != <span class="string">&#x27;x&#x27;</span>) seq += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; <span class="number">8</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span>(seq[i] &gt; seq[j])</span><br><span class="line">                cnt++;</span><br><span class="line">    <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;unsolvable&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">Bfs</span>(start) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.luogu.com.cn/problem/P1379" >P1379<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second </span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, string&gt; PIS;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">ed</span><span class="params">(<span class="string">&quot;123804765&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> lox[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> loy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)state.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(state[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = state[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res += <span class="built_in">abs</span>(i / <span class="number">3</span> - lox[t]) + <span class="built_in">abs</span>(i % <span class="number">3</span> - loy[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bfs</span><span class="params">(string start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; dist;</span><br><span class="line">    unordered_map&lt;string, pair&lt;<span class="type">char</span>, string&gt; &gt; prev;</span><br><span class="line">    priority_queue&lt;PIS, vector&lt;PIS&gt;, greater&lt;PIS&gt; &gt; heap;</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="built_in">f</span>(start), start&#125;);</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        string state = t.y;</span><br><span class="line">        <span class="keyword">if</span>(state == ed) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> nx, ny;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(state[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nx = i / <span class="number">3</span>;</span><br><span class="line">                ny = i % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string source = state;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) <span class="comment">// 扩展预测距离最小的点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = nx + dx[i], b = ny + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt; <span class="number">2</span> || b &lt; <span class="number">0</span> || b &gt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            state = source;</span><br><span class="line">            <span class="built_in">swap</span>(state[nx * <span class="number">3</span> + ny], state[a * <span class="number">3</span> + b]);</span><br><span class="line">            <span class="keyword">if</span>(!dist.<span class="built_in">count</span>(state) || dist[state] &gt; dist[source] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[state] = dist[source] + <span class="number">1</span>;</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[state] + <span class="built_in">f</span>(state), state&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[ed];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string start;</span><br><span class="line">    cin &gt;&gt; start;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Bfs</span>(start) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="K-短路"><a href="#K-短路" class="headerlink" title="K-短路"></a>K-短路</h3><blockquote>
<p>爆搜，且搜索范围很大，很适合 A-star</p>
</blockquote>
<p>估价：</p>
<p>以当前点到终点的最短距离作为估价函数，因为它一定小于等于实际走的距离。</p>
<p>既然第一次弹出是距离最小的，那么第 $k$ 次弹出就应该是第 $k$ 小的？</p>
<p>先看第二次：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310021545963.webp"
                      alt="image.png"
                ></p>
<p>与第一次证明思路相同，</p>
<p>运用数学归纳法，可得第 $k$ 次弹出就应该是第 $k$ 小的。</p>
<p>注意，是弹出时的该状态，而不是 $dist$ 值，因为 $dist$ 值被更新为最小后将不会再被更新。</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/description/180/" >AcWing178<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second </span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, PII&gt; PIII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt, val, to;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fir[N], rfir[N];</span><br><span class="line"><span class="type">int</span> n, m, S, T, K;</span><br><span class="line"><span class="type">int</span> cnt, tot;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w, <span class="type">bool</span> direc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].val = w;</span><br><span class="line">    <span class="keyword">if</span>(direc)</span><br><span class="line">    &#123;</span><br><span class="line">        e[cnt].nxt = fir[u];</span><br><span class="line">        fir[u] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        e[cnt].nxt = rfir[u];</span><br><span class="line">        rfir[u] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver = t.y;</span><br><span class="line">        <span class="keyword">if</span>(vis[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = rfir[ver]; i; i = e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dist[v] &gt; dist[ver] + e[i].val)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = dist[ver] + e[i].val;</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Astar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;PIII&gt; &gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;dist[S], &#123;<span class="number">0</span>, S&#125;&#125;); <span class="comment">// 预测长度，真实值，编号</span></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver = t.y.y;</span><br><span class="line">        <span class="type">int</span> d = t.y.x;</span><br><span class="line">        <span class="keyword">if</span>(ver == T) tot++;</span><br><span class="line">        <span class="keyword">if</span>(tot == K) <span class="keyword">return</span> d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = fir[ver]; i; i = e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dist[v] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>; <span class="comment">// 不满足估价距离的定义</span></span><br><span class="line">            heap.<span class="built_in">push</span>(&#123;d + e[i].val + dist[v], &#123;d + e[i].val, v&#125;&#125;); <span class="comment">// 因为不是找最短路，所以每种状态都要搜</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">Add</span>(a, b, c, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">Add</span>(b, a, c, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;S, &amp;T, &amp;K);</span><br><span class="line">    <span class="keyword">if</span>(S == T) K++;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Astar</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="爬山"><a href="#爬山" class="headerlink" title="爬山"></a>爬山</h1><p>在一个多峰函数上行走，每次可以走一小步，当且仅当向左和向右走都不是更优的时候，我就停下，否则就向更优的方向走。</p>
<p>但是这样有一个问题，我们找到的“最优解”很可能是“局部最优解”。</p>
<p>因为这本身就是一个贪心的思路。</p>
<p>所以需要加一些东西使这个贪心找到正确答案的概率更高一些。</p>
<h1 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h1><p>基于爬山算法,加上了<strong>温度T</strong>参数作为控制步子大小的参数。</p>
<p>温度越高，就容易冲动从而一步走得很大，这样就会波动到全局最优解，但是很不稳定。</p>
<p>温度渐渐降下来时，冷静下来后每次的步子就走的比较小了，这样最后就会在全局最优解附近不断逼近直至找到最优解。</p>
<p>虽然说也有可能在局部最优解就冷静下来了，不过没关系，你多重复几次这样的过程，得到正解的概率就会大大增加。</p>
<p>先设置一个初始温度，每次操作后进行一个降温操作，即$T$乘上某个系数，具体依题目而定。</p>
<p>还要设一个满足条件的初始答案，在此基础上进行调整（这个答案不必很准确，尽量接近答案以减少迭代次数）。</p>
<p>每次走一步后，如果是更优解，那么就走过去；如果不是更优解，那就以一定的概率走过去，这个是平衡概率$exp(\Delta{E}&#x2F;T)$，其中$exp$函数是$e$的多少次方。</p>
<p>如果怕参数没调校好导致超时，或者是想尽量多重复几次步骤，可以尝试加入<strong>卡时</strong>技巧。</p>
<p>如：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((<span class="type">double</span>)<span class="built_in">clock</span>()/CLOCKS_PER_SEC&lt;T) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>

<p>其中 T 为时限，记得预留足够的输出时间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202308011959927.webp"
                      alt="image.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202308012008597.webp"
                      alt="image.png"
                ></p>
<p>会有$0\sim{5} ms$的误差。</p>
<h1 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h1><blockquote>
<p>一种区间暴力结合分块的玄学优化的离线算法。<br><a class="link"   href="https://www.zhihu.com/people/mythly" >莫涛大神的知乎<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<p>如果题目要求强制在线的话，线段树和树状数组才是更优选择。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>给定一个序列，每次询问为一个区间，每次输出该区间内共有多少不同的数。</p>
<p>对于这道题，暴力的做法肯定是把每个区间都扫一遍，扫的时候统计区间内不同书的个数。</p>
<p> 而这个的一个优化就是移动区间的左右端点的指针。</p>
<p>初始时$l&#x3D;1,r&#x3D;0$，记录一个$cnt$数组为该种数出现的次数，类似于桶。</p>
<p>而每遇到一个新数，就把它出现的次数加一，如果它出现的次数是零，那么说明这个数在之前都没有出现过，所以不同数的个数也要加一。假如这个数字之前出现过了，那么就只加对应数的个数，而不需要加不同数的个数。</p>
<p>每减去一个数，把它的出现次数减一，这时候判断一下是否为零，如果是，那就说明这个数已经消失了，所以不同数的个数也要减一。</p>
<p>具体的实现过程，注意<code>++</code>和<code>--</code>的顺序：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!cnt[a[pos]]) ++now;</span><br><span class="line">    ++cnt[a[pos]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    --cnt[a[pos]];</span><br><span class="line">    <span class="keyword">if</span>(!cnt[a[pos]]) --now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ql,qr;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;qr,&amp;ql);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;ql) <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span>(l&gt;ql) <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span>(r&lt;qr) <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;qr) <span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但这还不够，因为在一些极端情况下，比如中间有一段很长的区间，但是查询都是在两端的小区间，而且还是换着来的，这样就会导致区间一会跑向左边，一会跑向右边，就会被卡。</p>
<p>所以我们就要上一些<em>玄学优化</em>了。</p>
<h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>将长度为$n$的序列分为$\sqrt{n}$个块，编号从$1$到$\sqrt{n}$，把查询区间按照左端点所在块的编号排序，如果左端点所在的块相同，那就按照右端点排序。</p>
<p>排序函数：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(query a, query b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> belong[a.l]==belong[b.l]?a.r&lt;b.r:belong[a.l]&lt;belong[b.l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这么一个优化就把时间复杂度从$n^2$变为了$n\sqrt{n}$，好极了，那么继续。</p>
<h2 id="奇偶性排序"><a href="#奇偶性排序" class="headerlink" title="奇偶性排序"></a>奇偶性排序</h2><p>对于左端点在同一个编号为奇数的块内，右端点按照升序排列。</p>
<p>对于左端点在统一编号为偶数的块内，右端点按照降序排列。</p>
<p>它的主要原理便是右指针跳完奇数块往回跳时在同一个方向能顺路把偶数块跳完，然后跳完这个偶数块又能顺带把下一个奇数块跳完。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(query a, query b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (belong[a.l]^belong[b.l])?belong[a.l]&lt;belong[b.l]:((belong[a.l]&amp;<span class="number">1</span>)?a.r&lt;b.r:a.r&gt;b.r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>先用异或判断两个数是否相等，如果不同，那么就按照编号升序排序；如果相同，那么再比较它们的块的编号的奇偶性，如果是奇数，那就按照右端点升序排序，否则按照右端点降序排序。</p>
<h2 id="压常"><a href="#压常" class="headerlink" title="压常"></a>压常</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;ql) now-=!--cnt[a[l++]];</span><br><span class="line"><span class="keyword">while</span>(l&gt;ql) now+=!cnt[a[--l]]++;</span><br><span class="line"><span class="keyword">while</span>(r&lt;qr) now+=!cnt[a[++r]]++;</span><br><span class="line"><span class="keyword">while</span>(r&gt;qr) now-=!--cnt[a[r--]];</span><br></pre></td></tr></table></figure></div>

<p>注意此处<code>+=</code>优先级比<code>cnt++</code>更高</p>
<h2 id="快读-快写"><a href="#快读-快写" class="headerlink" title="快读&#x2F;快写"></a>快读&#x2F;快写</h2><p>略。</p>
<blockquote>
<p>参考文章：</p>
</blockquote>
<ul>
<li><a class="link"   href="https://www.cnblogs.com/WAMonster/p/10118934.html" >莫队算法——从入门到黑题 - WAMonster - 博客园 (cnblogs.com)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/115243708" >算法学习笔记(24): 莫队 - 知乎 (zhihu.com)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<h2 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h2><h2 id="回滚莫队"><a href="#回滚莫队" class="headerlink" title="回滚莫队"></a>回滚莫队</h2>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/668ad1af.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>注意对于所有的数据结构，遍历前一定要检查是否为空，或者有无可能访问到空节点。</strong></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="动态链表"><a href="#动态链表" class="headerlink" title="动态链表"></a>动态链表</h2><p><del>略。</del></p>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>以<a class="link"   href="https://www.luogu.com.cn/problem/P1996" >P1996约瑟夫问题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>为例</p>
<h3 id="手写静态链表"><a href="#手写静态链表" class="headerlink" title="手写静态链表:"></a>手写静态链表:</h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> id,next,pre;</span><br><span class="line">    <span class="type">int</span> date;</span><br><span class="line">&#125;nodes[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    nodes[<span class="number">0</span>].next=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes[i].id=i;</span><br><span class="line">        nodes[i].pre=i<span class="number">-1</span>;</span><br><span class="line">        nodes[i].next=i<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nodes[n].next=<span class="number">0</span>;</span><br><span class="line">    nodes[<span class="number">0</span>].pre=n;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">            now=nodes[now].next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,nodes[now].id);</span><br><span class="line">        <span class="type">int</span> prev=nodes[now].pre.nex=nodes[now].next;</span><br><span class="line">        nodes[prev].next=nodes[now].next;</span><br><span class="line">        nodes[nex].pre=nodes[now].pre;</span><br><span class="line">        now=nex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,nodes[now].next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>以<a class="link"   href="https://www.luogu.com.cn/problem/P1540" >P1540机器翻译<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>为例</p>
<h2 id="手写队列"><a href="#手写队列" class="headerlink" title="手写队列"></a>手写队列</h2><h1 id="双端队列和单调队列"><a href="#双端队列和单调队列" class="headerlink" title="双端队列和单调队列"></a>双端队列和单调队列</h1><p><a class="link"   href="https://blog.csdn.net/weixin_42462202/article/details/87537503" >Deque<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>这里以<a class="link"   href="https://www.luogu.com.cn/problem/P1886" >P1886滑动窗口<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>举例</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>dq[i]</code></td>
<td>返回队列中下标为i的元素</td>
</tr>
<tr>
<td><code>dq.front()</code></td>
<td>返回队头</td>
</tr>
<tr>
<td><code>dq.back()</code></td>
<td>返回队尾</td>
</tr>
<tr>
<td><code>dq.pop_front()</code></td>
<td>删除队头</td>
</tr>
<tr>
<td><code>dq.pop_back</code></td>
<td>删除队尾</td>
</tr>
<tr>
<td><code>dq.push_back(e)</code></td>
<td>在队尾添加一个元素e</td>
</tr>
<tr>
<td><code>dq.push_front(e)</code></td>
<td>在队头添加一个元素e</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;a[q.<span class="built_in">back</span>()]&gt;a[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;q.<span class="built_in">front</span>()&lt;=i-m) q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;a[q.<span class="built_in">back</span>()]&lt;a[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;q.<span class="built_in">front</span>()&lt;=i-m) q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例题<a class="link"   href="https://acm.hdu.edu.cn/showproblem.php?pid=1003" >Max sum<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=t;l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="type">int</span> maxsum=INT_MIN,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> st=<span class="number">1</span>,en=<span class="number">1</span>,p=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s);</span><br><span class="line">            sum+=s;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;maxsum)</span><br><span class="line">            &#123;</span><br><span class="line">                maxsum=sum;</span><br><span class="line">                st=p;</span><br><span class="line">                en=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">                p=i<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>,l);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,maxsum,st,en);</span><br><span class="line">        <span class="keyword">if</span>(l!=t) <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="DP优化"><a href="#DP优化" class="headerlink" title="DP优化"></a>DP优化</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P1725" >P1725<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,l,r;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">128</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;l,&amp;r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">+1</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">0</span>,ans=<span class="number">-0x7ffffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">+1</span>;i&lt;=n<span class="number">+1</span>;i++)<span class="comment">//l+1左边的格子跳不到</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;=t&amp;&amp;q[h]&lt;i-r) h++;<span class="comment">//删头</span></span><br><span class="line">        <span class="keyword">while</span>(h&lt;=t&amp;&amp;f[q[t]]&lt;f[i-l]) t--;<span class="comment">//把小于当前新加的值的尾部都去掉</span></span><br><span class="line">        q[++t]=i-l;<span class="comment">//将最右端加入队尾</span></span><br><span class="line">        f[i]=f[q[h]]+a[i];</span><br><span class="line">        <span class="keyword">if</span>(i+r&gt;n<span class="number">+1</span>) ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>以例题<a class="link"   href="https://www.luogu.com.cn/problem/P2947" >P2947<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>为例</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> h[<span class="number">200005</span>],ans[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;h[st.<span class="built_in">top</span>()]&lt;=h[i]) st.<span class="built_in">pop</span>();<span class="comment">//比它矮的全部出栈</span></span><br><span class="line">        <span class="comment">//因为倒着遍历，所以新入栈的一定更靠左更靠前也更矮更有可能是更优解</span></span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) ans[i]=<span class="number">0</span>;<span class="comment">//右边没有奶牛比它高</span></span><br><span class="line">        <span class="keyword">else</span> ans[i]=st.<span class="built_in">top</span>();<span class="comment">//最近的且比它高的</span></span><br><span class="line">        st.<span class="built_in">push</span>(i);<span class="comment">//入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>习题<a class="link"   href="https://www.luogu.com.cn/problem/P5788" >P5788<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>:</p>
<p>这里贴一份<code>手写栈</code>的代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">3000055</span>],f[<span class="number">3000055</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fstack</span>&#123;<span class="comment">//手写栈</span></span><br><span class="line">    <span class="type">int</span> w[<span class="number">3000055</span>];</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;<span class="comment">//栈顶位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//插入</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        w[++t]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span><span class="comment">//返回顶部值</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span><span class="comment">//弹出栈顶</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="comment">//判断是否为空</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;a[i]&gt;=a[s.<span class="built_in">top</span>()]) s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) f[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> f[i]=s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"><span class="comment">// int n,a[300005],f[300005];</span></span><br><span class="line"><span class="comment">// int main()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     scanf(&quot;%d&quot;,&amp;n);</span></span><br><span class="line"><span class="comment">//     stack&lt;int&gt; s;</span></span><br><span class="line"><span class="comment">//     for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//         scanf(&quot;%d&quot;,&amp;a[i]);</span></span><br><span class="line"><span class="comment">//     for(int i=n;i&gt;=1;i--)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         while(!s.empty()&amp;&amp;a[i]&gt;=a[s.top()]) s.pop();</span></span><br><span class="line"><span class="comment">//         if(s.empty()) f[i]=0;</span></span><br><span class="line"><span class="comment">//         else f[i]=s.top();</span></span><br><span class="line"><span class="comment">//         s.push(i);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         printf(&quot;%d &quot;,f[i]);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></div>

<p>习题<a class="link"   href="https://www.luogu.com.cn/problem/P1449" >P1449<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i]!=<span class="string">&#x27;@&#x27;</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            now*=<span class="number">10</span>;</span><br><span class="line">            now+=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(now);</span><br><span class="line">            now=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            a+=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(a);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a=-st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            a+=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(a);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            a*=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(a);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a=st.<span class="built_in">top</span>(),b;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            b=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(b/a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,st.<span class="built_in">top</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>习题<a class="link"   href="https://www.luogu.com.cn/problem/P1981" >P1981<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">10000</span>;</span><br><span class="line">    a=a%m;</span><br><span class="line">    s.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;c&gt;&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(a*b%m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    s.<span class="built_in">push</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        a+=s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        a%=m;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>习题<a class="link"   href="https://www.luogu.com.cn/problem/P1175" >P1175<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="comment">/*懒得写了，目前进度走到将前缀表达式转为中缀表达式，但是同运算级并没有按照题目顺序*/</span></span><br><span class="line"><span class="comment">/*40%*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fstack</span>&#123;<span class="comment">//手写栈</span></span><br><span class="line">    <span class="type">char</span> w[<span class="number">30005</span>];</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;<span class="comment">//栈顶位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//插入</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        w[++t]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">top</span><span class="params">()</span><span class="comment">//返回顶部值</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span><span class="comment">//弹出栈顶</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="comment">//判断是否为空</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;st,bas;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//st;//存放待处理符号</span></span><br><span class="line">    <span class="comment">//bas;//存放表达式</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bas.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                bas.<span class="built_in">push</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                st.<span class="built_in">pop</span>();<span class="comment">//弹出(</span></span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;^&#x27;</span>&amp;&amp;(st.<span class="built_in">empty</span>()||st.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>((c==<span class="string">&#x27;^&#x27;</span>&amp;&amp;(st.<span class="built_in">empty</span>()||st.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>))==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                bas.<span class="built_in">push</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((c==<span class="string">&#x27;*&#x27;</span>||c==<span class="string">&#x27;/&#x27;</span>)&amp;&amp;(st.<span class="built_in">empty</span>()||st.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>||st.<span class="built_in">top</span>()!=<span class="string">&#x27;^&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;*&#x27;</span>||c==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(((c==<span class="string">&#x27;*&#x27;</span>||c==<span class="string">&#x27;/&#x27;</span>)&amp;&amp;(st.<span class="built_in">empty</span>()||st.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>||st.<span class="built_in">top</span>()!=<span class="string">&#x27;^&#x27;</span>))==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                bas.<span class="built_in">push</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((c==<span class="string">&#x27;+&#x27;</span>||c==<span class="string">&#x27;-&#x27;</span>)&amp;&amp;(st.<span class="built_in">empty</span>()||st.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>||(st.<span class="built_in">top</span>()!=<span class="string">&#x27;^&#x27;</span>&amp;&amp;st.<span class="built_in">top</span>()!=<span class="string">&#x27;*&#x27;</span>&amp;&amp;st.<span class="built_in">top</span>()!=<span class="string">&#x27;/&#x27;</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;+&#x27;</span>||c==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(((c==<span class="string">&#x27;+&#x27;</span>||c==<span class="string">&#x27;-&#x27;</span>)&amp;&amp;(st.<span class="built_in">empty</span>()||st.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>||(st.<span class="built_in">top</span>()!=<span class="string">&#x27;^&#x27;</span>&amp;&amp;st.<span class="built_in">top</span>()!=<span class="string">&#x27;*&#x27;</span>&amp;&amp;st.<span class="built_in">top</span>()!=<span class="string">&#x27;/&#x27;</span>)))==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                bas.<span class="built_in">push</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        bas.<span class="built_in">push</span>(st.<span class="built_in">top</span>());</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!bas.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;bas.<span class="built_in">top</span>();</span><br><span class="line">        bas.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><del>这个大模拟作者有时间再补。</del></p>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><blockquote>
<p><code>#include&lt;vector&gt;</code><br><a class="link"   href="https://blog.csdn.net/qiancm/article/details/119611928" >链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>若类型为<code>int</code>，则初始化为0.</p>
<p>若类型为<code>string</code>，则初始化为空字符串。</p>
<hr>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//初始化了一个有十个元素的vector，且十个元素的值都是0</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>;<span class="comment">//初始化了一个有十个元素的vector，且十个元素的值都是1</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;<span class="comment">//将a复制一份给b</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>().a.<span class="built_in">begin</span>())<span class="comment">//将从b.begin开始到b.end()结束的元素复制到从a.begin()开始的地方若超出则停止</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:a)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> it=b.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">advance</span>(it,<span class="number">6</span>);</span><br><span class="line">    b.<span class="built_in">insert</span>(it,<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">copy</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),a.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:a)</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>输出：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307181441496.webp"
                      alt="image.png"
                ></p>
<hr>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">b.<span class="built_in">push_back</span>(i);</span><br><span class="line">b.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);<span class="comment">//pair</span></span><br></pre></td></tr></table></figure></div>

<p>对于已存在的元素，可以像数组一样通过下标进行访问和修改。</p>
<p>或者：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">b.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">b.<span class="built_in">emplace_back</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//pair</span></span><br></pre></td></tr></table></figure></div>

<p>emplace 比 push 少了拷贝的过程，直接在容器尾部创建元素，因此速度更快。</p>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; demo&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//第一种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>);<span class="comment">//&#123;1,3,2&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//第二种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//&#123;1,3,2,5,5&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//第三种格式用法</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>,3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());<span class="comment">//&#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//第四种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;);<span class="comment">//&#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">b.<span class="built_in">insert</span>(it,<span class="number">6</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure></div>

<p>在迭代器<code>it</code>的位置后插入$6$个$6$。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:a)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> it=b.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">advance</span>(it,<span class="number">6</span>);</span><br><span class="line">    b.<span class="built_in">insert</span>(it,<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:b)</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>输出：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307181427472.webp"
                      alt="image.png"
                ></p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    demo.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="comment">//输出 dmeo 容器新的size</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出 demo 容器新的容量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>输出：</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">size is :<span class="number">4</span></span><br><span class="line">capacity is :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></div>

<p>可以看出，虽然最后一个元素被删去了，但是容器容量并没有变。</p>
<hr>
<p><code>erase</code>函数：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(pos)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>其中<code>pos</code>为迭代器，表示要删除元素的位置。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> iter = demo.<span class="built_in">erase</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>);<span class="comment">//删除元素 2</span></span><br><span class="line">    <span class="comment">//输出 dmeo 容器新的size</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出 demo 容器新的容量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//iter迭代器指向元素 3</span></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>输出：</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">size is :<span class="number">4</span></span><br><span class="line">capacity is :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<p>删除元素，容器的<code>size</code>变小了，但是容量并没有变，迭代器指向删除元素的下一个元素。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote>
<p><code>#include&lt;map&gt;</code></p>
</blockquote>
<p>STL的一个关联容器，有映射功能。</p>
<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,string&gt; m;</span><br></pre></td></tr></table></figure></div>

<p>第一个值为 键，第二个值为 值。</p>
<p>键相当于数组下标，值相当于数组里存储的东西。</p>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">int</span>,string&gt; m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m[<span class="number">1</span>]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">2</span>,<span class="string">&quot;no&quot;</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>,<span class="string">&quot;yes&quot;</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">4</span>,<span class="string">&quot;oh&quot;</span>));</span><br><span class="line">    cout&lt;&lt;m[<span class="number">1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>&lt;&lt;m[<span class="number">2</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>&lt;&lt;m[<span class="number">3</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>&lt;&lt;m[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里提供了三种不同的插入元素方法。</p>
<p>当访问不存在的元素时，会返回空。</p>
<h3 id="删除与清空："><a href="#删除与清空：" class="headerlink" title="删除与清空："></a>删除与清空：</h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,string&gt;::iterator it;</span><br><span class="line">it=m.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">m.<span class="built_in">erase</span>(it);</span><br></pre></td></tr></table></figure></div>

<p>或者</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></div>

<p>注意<code>m.find()</code>返回的是<strong>键</strong>的迭代器而非 值 的。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></div>

<p>这里<code>.begin()</code>和<code>.end()</code>返回的也都是迭代器。</p>
<h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307181124413.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307181125496.webp"
                     
                ></p>
<p>这是这串代码正常的运行结果。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307181125042.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307181126406.webp"
                     
                ></p>
<p>假如我先找到$key&#x3D;2$的元素的迭代器并储存，清空<code>map</code>后找到的迭代器依旧可以访问。</p>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307181126015.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307181127556.webp"
                     
                ></p>
<p>但是如果是将<code>m.begin()</code>的迭代器存下来清空后却访问不到了。</p>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p><code>m.size()</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307181138306.webp"
                      alt="image.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307181139999.webp"
                      alt="image.png"
                ></p>
<p><code>m.size()</code>虽然输出为整数，但是类型返回值却是<code>y</code>，这个类型我也不得而知，反正返回值不是一个整数，所以拿<code>.size()</code>和整型比较的时候一定要先把<code>.size()</code>赋值给一个整型，不然可能就会把负数变成较大的无符号值导致出错。</p>
<h2 id="Unordered-map"><a href="#Unordered-map" class="headerlink" title="Unordered_map"></a>Unordered_map</h2><blockquote>
<p><a class="link"   href="https://blog.csdn.net/BillCYJ/article/details/78985895" >map和unordered_map的差别和使用_map和unorderedmap的区别-CSDN博客<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<p>map 元素有有序性，但空间占用率高。</p>
<p>unordered_map 查询快，原理是哈希表。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><a class="link"   href="https://blog.csdn.net/KEPROM/article/details/109744379" >Queue<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> bj[<span class="number">2333</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> en;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;en);</span><br><span class="line">        <span class="keyword">if</span>(!bj[en])</span><br><span class="line">        &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            q.<span class="built_in">push</span>(en);</span><br><span class="line">            bj[en]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>()&gt;m)</span><br><span class="line">            &#123;</span><br><span class="line">                bj[q.<span class="built_in">front</span>()]=<span class="number">0</span>;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><a class="link"   href="https://blog.csdn.net/u014779536/article/details/111301635" >STL<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*STL的List*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; node;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        node.<span class="built_in">push_back</span>(i);</span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator it=node.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(node.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            it++;</span><br><span class="line">            <span class="keyword">if</span>(it==node.<span class="built_in">end</span>()) it=node.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        list&lt;<span class="type">int</span>&gt;::iterator next=++it;</span><br><span class="line">        <span class="keyword">if</span>(next==node.<span class="built_in">end</span>()) next=node.<span class="built_in">begin</span>();</span><br><span class="line">        node.<span class="built_in">erase</span>(--it);</span><br><span class="line">        it=next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;*it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Priority-queue"><a href="#Priority-queue" class="headerlink" title="Priority_queue"></a>Priority_queue</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;<span class="comment">//小根堆定义&lt;less&gt;为从大到小，&lt;greater&gt;为从小到大</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)<span class="comment">//入堆</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            q.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">q.<span class="built_in">push</span>()</span><br><span class="line">q.<span class="built_in">pop</span>()</span><br><span class="line">q.<span class="built_in">size</span>()</span><br><span class="line">q.<span class="built_in">empty</span>()</span><br><span class="line">q.<span class="built_in">top</span>()</span><br><span class="line">q.<span class="built_in">top</span>()</span><br><span class="line">q.<span class="built_in">back</span>()</span><br></pre></td></tr></table></figure></div>

<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>例题<a class="link"   href="https://acm.hdu.edu.cn/showproblem.php?pid=1062" >TextReverse<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>st.push(i)</td>
<td>将i元素放到栈顶</td>
</tr>
<tr>
<td>st.top()</td>
<td>返回栈顶元素</td>
</tr>
<tr>
<td>st.pop()</td>
<td>弹出栈顶元素</td>
</tr>
<tr>
<td>st.size()</td>
<td>查询栈中元素</td>
</tr>
<tr>
<td>st.empty()</td>
<td>查询栈是否为空</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27; &#x27;</span>||ch==<span class="string">&#x27;\n&#x27;</span>||ch==EOF)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s.<span class="built_in">top</span>()),s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(ch==<span class="string">&#x27;\n&#x27;</span>||ch==EOF) <span class="keyword">break</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> s.<span class="built_in">push</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Bitset"><a href="#Bitset" class="headerlink" title="Bitset"></a>Bitset</h2><ul>
<li><code>size()</code> 返回 <code>std::bitset</code> 的长度</li>
<li><code>count()</code> 返回 <code>std::bitset</code> 中值为 1 的位的数量</li>
<li><code>any()</code> 返回 <code>std::bitset</code> 中是否存在值为 1 的位</li>
<li><code>none()</code> 返回 <code>std::bitset</code> 中是否所有位都是 0</li>
<li><code>all()</code> 返回 <code>std::bitset</code> 中是否所有位都是 1</li>
<li><code>test(pos)</code> 返回 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值</li>
<li><code>set(pos)</code> 将 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值设为 1</li>
<li><code>reset(pos)</code> 将 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值设为 0</li>
<li><code>flip(pos)</code> 将 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值取反</li>
<li><code>to_ulong()</code> 返回 <code>std::bitset</code> 转换成的无符号整数值</li>
<li><code>to_ullong()</code> 返回 <code>std::bitset</code> 转换成的无符号长整数值</li>
<li><code>_Find_first()</code> 返回第一个 1 的位置，若没有则返回 <code>size</code></li>
<li><code>_Find_next()</code> 返回下一个 1 的位置，若没有则返回 <code>size</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309021438033.webp"
                      alt="image.png"
                ></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitset&lt;4&gt; a1;</span><br><span class="line">    <span class="function">bitset&lt;10&gt; <span class="title">a2</span><span class="params">(<span class="number">15</span>)</span></span>; <span class="comment">// 二进制初始化</span></span><br><span class="line">    string s = <span class="string">&quot;10001001&quot;</span>; <span class="comment">// 字符串初始化</span></span><br><span class="line">    <span class="function">bitset&lt;10&gt; <span class="title">a3</span><span class="params">(<span class="string">&quot;10001001&quot;</span>)</span></span>; <span class="comment">// 前面用0补位，或者bitset&lt;10&gt; a3(s);</span></span><br><span class="line">    <span class="comment">// 如果超出，则从后往前取，若长度不足，则前面用0补位</span></span><br><span class="line">    cout &lt;&lt; a3 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a2 &lt;&lt; endl;</span><br><span class="line">    a2 &amp;= a3; <span class="comment">// 必须长度相同才能进行位运算</span></span><br><span class="line">    cout &lt;&lt; a2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        cout &lt;&lt; a2[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Multiset"><a href="#Multiset" class="headerlink" title="Multiset"></a>Multiset</h2><p>logn 的时间内保证序列中的数是有序的。</p>
<p>比较函数需要自己重载。</p>
<p><a class="link"   href="https://blog.csdn.net/sodacoco/article/details/84798621" >multiset<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>与 set 的最大差别就是它可以存储同一个数很多次（可重集）。</p>
<ul>
<li><code>insert</code> 插入</li>
<li><code>erase</code> 删除</li>
<li><code>multiset&lt;rec, cmp&gt; h</code> 定义排序方式</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>维护一个集合，集合内的值都是有序的，那么理论上我们可以用它求第 k 小数。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">114514</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1919810</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">12</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// advance(it, k);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) it++;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><p>没啥好说的。</p>
<h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><h4 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h4><p><code>根-左-右</code></p>
<h4 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h4><p><code>左-根-右</code></p>
<h4 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a>3.后序遍历</h4><p><code>左-右-根</code></p>
<h4 id="4-练习"><a href="#4-练习" class="headerlink" title="4.练习"></a>4.练习</h4><p><a class="link"   href="https://acm.hdu.edu.cn/showproblem.php?pid=1710" >HDU1710<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><code>此坑待填ing</code></p>
<p><del>不是很会</del></p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>二叉树上两点间路径长度：这条路经过的边的数量。</p>
<p>树的路径长度：从根到每个节点的路径之和。</p>
<hr>
<p>带权节点的带权路径长度：根节点到该点的路径长度乘以节点权值。</p>
<p>树的带权路径长度：所有叶子节点的带权路径长度之和。</p>
<hr>
<p>现给定<code>n</code>个权值，构造一棵<code>n</code>个叶子节点的二叉树，每个叶子节点对应一个权值，那么带权路径最小的二叉树就叫做<code>哈夫曼树</code>。</p>
<p>要构造这样一颗树，那么肯定就是把权值大的叶子节点放在深度较小的地方，把权值小的叶子节点放在深度较大的地方。</p>
<p>算法流程：<a class="link"   href="https://zhuanlan.zhihu.com/p/415467000" >数据结构——哈夫曼树（Huffman Tree）<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>注：仅有叶子节点有权值。</p>
<p><strong>哈夫曼编码</strong>其实就是构造出一颗哈夫曼树，以字符为权值，左儿子为<code>0</code> 右儿子为<code>1</code>。</p>
<p>习题：<a class="link"   href="http://poj.org/problem?id=1521" >POJ1521<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include&lt;bits/stdc++.h&gt;//POJ不让用万能头aaa</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt; <span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,s)&amp;&amp;s!=<span class="string">&quot;END&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());<span class="comment">//字符串按字典序排序方法</span></span><br><span class="line">        <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;i++)<span class="comment">//字符串从0开始，先比较0和1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(num);</span><br><span class="line">                num=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>()==<span class="number">1</span>)<span class="comment">//只有一个字符的字符串</span></span><br><span class="line">        ans=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a=q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> b=q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(a+b);</span><br><span class="line">            ans+=a+b;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %.1f\n&quot;</span>, <span class="number">8</span>*s.<span class="built_in">length</span>() , ans , (<span class="type">double</span>)<span class="number">8</span>*s.<span class="built_in">length</span>()/(<span class="type">double</span>)ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="手写堆"><a href="#手写堆" class="headerlink" title="手写堆"></a>手写堆</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P3378" >P3378<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> heap[N],len=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//小根堆插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heap[++len]=x;</span><br><span class="line">    <span class="type">int</span> i=len;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">1</span>&amp;&amp;heap[i]&lt;heap[i/<span class="number">2</span>])<span class="comment">//i/2为i的父元素下标</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[i],heap[i/<span class="number">2</span>]);</span><br><span class="line">        i=i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>]=heap[len--];<span class="comment">//将堆头替换为最后一个节点，开始下沉</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span>*i&lt;=len)<span class="comment">//2*i即为i的左儿子,循环终止条件是i没有儿子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> son=<span class="number">2</span>*i;</span><br><span class="line">        <span class="keyword">if</span>(son&lt;len&amp;&amp;heap[son<span class="number">+1</span>]&lt;heap[son])<span class="comment">//右二子更小，那就让右儿子上浮</span></span><br><span class="line">            son++;<span class="comment">//切换为右儿子</span></span><br><span class="line">        <span class="keyword">if</span>(heap[son]&lt;heap[i])<span class="comment">//比当前要小，可以上浮</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap[i],heap[son]);</span><br><span class="line">            i=son;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//不能继续下沉就终止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)<span class="comment">//入堆</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,heap[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P2085" >P2085<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P2827" >P2827<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P3045" >P3045<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<hr>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>操作：</p>
<ul>
<li>合并两个集合</li>
<li>查询某个元素的祖宗节点</li>
</ul>
<p>优化：</p>
<ul>
<li>路径压缩（$O(logn)$）</li>
<li>按秩合并（$O(logn)$）</li>
<li>路径压缩+按秩合并（$O(\alpha n)\approx O(1)$</li>
</ul>
<p>扩展：</p>
<ul>
<li>记录每个集合的大小，一个集合大小是一定的，所以把它绑定到根节点身上就行。</li>
<li>每个点到根节点的距离，绑定到每个元素身上。</li>
</ul>
<p><a class="link"   href="https://www.acwing.com/problem/content/1252/" >AcWing1250<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * n + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * n; ++i)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">char</span> d;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; d;</span><br><span class="line">        x--, y--;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">get</span>(x, y);</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">if</span>(d == <span class="string">&#x27;D&#x27;</span>) b = <span class="built_in">get</span>(x + <span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">else</span> b = <span class="built_in">get</span>(x, y + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(pa == pb)</span><br><span class="line">        &#123;</span><br><span class="line">            res = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p[pa] = pb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!res) <span class="built_in">puts</span>(<span class="string">&quot;draw&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/1254/" >AcWing1252<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, val;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)</span><br><span class="line">        &#123;</span><br><span class="line">            v[pb] += v[pa];</span><br><span class="line">            w[pb] += w[pa];</span><br><span class="line">            p[pa] = p[pb];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(p[i] == i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = val; j &gt;= v[i]; --j)</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[val] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/239/" >AcWing237<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 约束条件的顺序不影响矛盾：先考虑所有的相等，那么不会出现矛盾</span></span><br><span class="line"><span class="comment">// 然后再考虑不等条件，如果这个时候不满足，那么就出现了矛盾。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, e;</span><br><span class="line">&#125;q[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.<span class="built_in">count</span>(x) == <span class="number">0</span>) S[x] = ++n;</span><br><span class="line">    <span class="keyword">return</span> S[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        S.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x, y, e;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;e);</span><br><span class="line">            q[i] = &#123;<span class="built_in">get</span>(x), <span class="built_in">get</span>(y), e&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) p[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="keyword">if</span>(q[i].e == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> pa = <span class="built_in">find</span>(q[i].x), pb = <span class="built_in">find</span>(q[i].y);</span><br><span class="line">                p[pa] = pb;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="type">bool</span> bj = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="keyword">if</span>(q[i].e == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> pa = <span class="built_in">find</span>(q[i].x), pb = <span class="built_in">find</span>(q[i].y);</span><br><span class="line">                <span class="keyword">if</span>(pa == pb)</span><br><span class="line">                &#123;</span><br><span class="line">                    bj = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(bj) <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/240/" >AcWing238<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>维护间隔多少战舰。</p>
<p>维护一下每个节点到根节点的距离即可。</p>
<p>让排头当根节点。</p>
<p>同时还要维护一下 $size$</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e4</span> + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3e4</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        s[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa != pb)</span><br><span class="line">            &#123;</span><br><span class="line">                d[pa] = s[pb];</span><br><span class="line">                s[pb] += s[pa];</span><br><span class="line">                p[pa] = pb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa != pb) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">abs</span>(d[a] - d[b]) - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/241/" >AcWing239<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>类似食物链。</p>
<p>带权并查集维护的是它与根节点之间的关系。</p>
<p>同类&#x2F;不同类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310041620900.webp"
                      alt="image.png"
                ></p>
<p>小结论：模二意义下的加法相当于异或。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.<span class="built_in">count</span>(x) == <span class="number">0</span>) S[x] = ++n;</span><br><span class="line">    <span class="keyword">return</span> S[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] ^= d[p[x]];</span><br><span class="line">        p[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        string type;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; type;</span><br><span class="line">        a = <span class="built_in">get</span>(a - <span class="number">1</span>), b = <span class="built_in">get</span>(b); <span class="comment">// 前缀和思路</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="string">&quot;odd&quot;</span>) t = <span class="number">1</span>; <span class="comment">//奇数,a 和 b 不是同类</span></span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(pa == pb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((d[a] ^ d[b]) != t) <span class="comment">// 不是同类的话和根节点的关系就应该不同，否则矛盾</span></span><br><span class="line">            &#123;</span><br><span class="line">                res = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">            d[pa] = d[a] ^ d[b] ^ t; <span class="comment">// 同类异或为0，异类异或为1，分类讨论即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><blockquote>
<p> 顾名思义，就是以区间为节点的二叉树</p>
</blockquote>
<p>这是它的样子：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307141416645.webp"
                      alt="image.png"
                ></p>
<p>和堆一样，线段树也是用一维数组存储。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307141454871.webp"
                     
                ></p>
<p><del>（8 9 反了）</del></p>
<hr>
<ul>
<li>父节点：$\lfloor{\dfrac{x}{2}}\rfloor$</li>
<li>左儿子：$2x$，<code>x&lt;&lt;1</code></li>
<li>右儿子：$2x+1$，<code>x&lt;&lt;1|1</code></li>
</ul>
<p>长度为 $n$ 的一段区间：</p>
<p>叶子节点数为 $n$ 个</p>
<p>倒数第二层最多为 $n$ 个节点，</p>
<p>二叉树性质：</p>
<ul>
<li>区间长度和叶子节点数相同</li>
<li>深度为$k-1$的满二叉树有$2^{k-1}-1$个节点，第$k$层有$2^{k-1}$个节点，那么第$k-1$层有$2^{k-1-1}$个节点，也就是$2^{k-2}$个节点，那么第$k-1$层往上共有$2^{k-2}-1$个节点。</li>
<li>第$i$层（不是最后一层）的节点数是第$i$层以上的节点数-1。</li>
</ul>
<p>所以倒数第二层以上的节点数最多为$n-1$个，那么除了最后一层的节点数最多为$2n-1$个。</p>
<p>最后一层不断往上加，最多可以加满为$2n$个，所以总节点数最大为$4n-1$，所以线段树的空间要开四倍。</p>
<h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//由子节点信息更新父节点信息（最大值）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].v=<span class="built_in">max</span>(tr[u&lt;&lt;<span class="number">1</span>].v,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>比如查询某段区间的最大值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307231638800.webp"
                      alt="image.png"
                ></p>
<p>查询的过程中无非就两种情况：查询区间与当前所在区间是包含关系还是交叉关系。</p>
<p>如果是包含关系，即查询区间包含树上区间，那么就没必要往下递归了，直接返回该段最大值即可。比如图中右分支递归到$[6,10]$，然后递归到$[6,8]$和$[9,10]$，这时候我们发现其实$[6,8]$没有向下递归的必要了，只需要直接返回该段区间的最大值即可。</p>
<p>如果是交叉关系，那么就接着向下递归，例如$[9,10]$区间再接着往下递归，在这个过程中若访问区间与查询区间没有交集，那么就不用管了，就不用访问它。</p>
<p>访问到的区间数量是$log$级别的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307231653396.webp"
                      alt="image.png"
                ></p>
<p>由于奇数除以$2$的时候是下取整，所以只要包含$mid$那么就要访问左区间。</p>
<p>最多大概会有$4logn$的访问。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].v;<span class="comment">//树中线段被查询区间包含</span></span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) v=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) v=<span class="built_in">max</span>(v,<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><p>从上往下递归，直到递归到某个叶子节点。</p>
<p>然后对它进行<code>pushup</code>就可以了。</p>
<p><code>pushup</code>其实就是从底下往上重新算一遍每个区间的和就可以了。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> v)</span><span class="comment">//修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==x&amp;&amp;tr[u].r==x) tr[u].v=v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,x,v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);<span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h2><h3 id="区间加法"><a href="#区间加法" class="headerlink" title="区间加法"></a>区间加法</h3><p>比如区间修改加访问区间和。</p>
<p>如果没有懒标记，那么只需要记录<strong>当前区间的总和</strong>。</p>
<p>现在还需要再加上懒标记<code>add</code>。</p>
<p><code>add</code>含义是以当前节点为根节点的子树中的每个节点都加上<code>add</code>这个数。</p>
<p>包不包含自己都可以，保证前后一致即可，下面采用只给子树加。</p>
<p>这样修改的复杂度就只有$O(logn)$了。</p>
<p>访问时需要把祖宗节点的值累计到子孙上。</p>
<p>只要在递归的时候清空当前懒标记并且将懒标记传给儿子，其实就是<code>pushdown</code>。</p>
<p><code>pushdown</code></p>
<p>这种是当前区间更新标记，而子树节点信息不更新的写法。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">l.add+=root.add;</span><br><span class="line">l.sum+=(l.r-l.l<span class="number">+1</span>)*root.add;</span><br><span class="line">r.add+=root.add;</span><br><span class="line">r.sum+=(r.r-r.l<span class="number">+1</span>)*root.add;</span><br></pre></td></tr></table></figure></div>

<p>修改的时候就往下传。</p>
<p>类似于查询，当递归到包含了这个节点，那么就没必要接着往下递归，打上标记然后返回就可以了。</p>
<p>递归到子区间需要把当前区间的标记下传并清空自身标记。</p>
<p>相当于查询和修改追着下放跑，总之我对当前节点做操作的时候，这个节点必须是没有标记的。</p>
<p>假如修改区间的左端点$\le{mid}$，那么就要递归修改左区间；</p>
<p>假如修改区间的右端点$&gt;{mid}$，那么就要递归修改右区间。</p>
<p>补充说明：</p>
<p>对于下传更好的理解：</p>
<p>假如你是个很懒惰的工人，有很多工作都推着不做，但是某天老板带着一堆人来查工，很幸运的是他们参观的都很慢，所以你就紧急地处理他们将要到达的地方，以保证他们查到这个地方的时候发现你已经把这个地方的工作做完了，你永远比老板快一步，你永远都是对的，至于他们不查的地方，你自然也懒得去做，也就是所谓“懒标记”。</p>
<p>所以为什么每次要修改儿子和查询儿子之前要先下传？</p>
<p>因为老板要去儿子节点的地方查工了。</p>
<h3 id="区间乘法"><a href="#区间乘法" class="headerlink" title="区间乘法"></a>区间乘法</h3><p>再加一个懒标记<code>mul</code>，表示乘法的懒标记。</p>
<p>假如先加再乘处理标记，那假如再加了一个数，变成了$(s+a)\times{b}+c$的形式，会非常不好处理，因为如果想把 $c$ 加到 $a$ 上，需要除以一个 $b$，会造成精度误差。</p>
<p>那就<strong>先乘再加</strong>，如果什么都没有那么$mul&#x3D;1,add&#x3D;0$，这样就比较好维护。</p>
<p>对于每个数，$x\times{mul}+add$，假如再加一个数，那么只需要改变$add$就可以了。</p>
<p>而对于乘法，那就把$add$和$mul$同时乘上这个数就可以了。</p>
<h2 id="扫描线法"><a href="#扫描线法" class="headerlink" title="扫描线法"></a>扫描线法</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202308081935464.webp"
                      alt="image.png"
                ></p>
<p>像这样沿着矩形的侧边切若干刀，将整个图形分成若干份，使得每一份内的截线长度都相等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202308081939494.webp"
                      alt="image.png"
                ></p>
<p>$h_i$代表第$i$段面积的长度。</p>
<p>那怎么求出$h_i$呢？</p>
<p>可以对纵坐标进行线段树维护。</p>
<p>每个矩形有两条侧边，把每个侧边看成一个线段，权值分别设为$+1,-1$，表示当前区间被几个矩形所覆盖。</p>
<p>有两个操作，一个是将某个区间加一或负一，一个是求整个区间里权值大于$0$的区间长度是多少。</p>
<p>维护的是区间，修改 $l\sim{r}$ 只需要修改 $y_l\sim{y_{r-1}}$</p>
<p>统计信息时只关心子孙节点。</p>
<p>扫描线性质：</p>
<ul>
<li>永远只考虑根节点信息，查询的时候不需要下放标记。</li>
<li>所有操作都是成对出现，有加也就有减。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x,y1,y2;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> segment &amp;a)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">double</span> len;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">3</span>];</span><br><span class="line">vector&lt;<span class="type">double</span>&gt; ys; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">double</span> y)</span><span class="comment">//查找离散化后的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>(),y)-ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].cnt)</span><br><span class="line">        tr[u].len=(ys[tr[u].r<span class="number">+1</span>]-ys[tr[u].l]);<span class="comment">//节点对应区间，所以右端点下标要加一</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l!=tr[u].r)<span class="comment">//不是叶子节点再用儿子更新</span></span><br><span class="line">        tr[u].len=tr[u&lt;&lt;<span class="number">1</span>].len+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l=l,tr[u].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].len=<span class="number">0</span>,tr[u].cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) </span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].cnt+=v;</span><br><span class="line">        <span class="built_in">pushup</span>(u);<span class="comment">//算一下要不要更新</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,v);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,v);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        ys.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> x1,x2,y1,y2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            seg[j++]=&#123;x1,y1,y2,<span class="number">1</span>&#125;;</span><br><span class="line">            seg[j++]=&#123;x2,y1,y2,<span class="number">-1</span>&#125;;</span><br><span class="line">            ys.<span class="built_in">push_back</span>(y1),ys.<span class="built_in">push_back</span>(y2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>());</span><br><span class="line">        ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>()),ys.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(seg,seg+n*<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,(<span class="type">int</span>)ys.<span class="built_in">size</span>()<span class="number">-2</span>);<span class="comment">//存的是区间</span></span><br><span class="line">        <span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) res+=tr[<span class="number">1</span>].len*(seg[i].x-seg[i<span class="number">-1</span>].x);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="built_in">find</span>(seg[i].y1),<span class="built_in">find</span>(seg[i].y2)<span class="number">-1</span>,seg[i].k);<span class="comment">//因为存的是区间而不是点，所以右端点要减一，因为一号节点代表的是1~2，那么l~r对应的节点就是l~r-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\n&quot;</span>,t++);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total explored area: %.2lf\n\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="动态开点"><a href="#动态开点" class="headerlink" title="动态开点"></a>动态开点</h2><p>线段树的堆式存储：</p>
<p>总共有 $n$ 个数，$logn$ 层，最后一层叶子节点数是 $2^{\lceil{logn}\rceil}$，由于万全二叉树的性质，总节点数就是 $2^{\lceil{logn}\rceil + 1} - 1$，最后一层的叶子节点最多有 $n$ 个，那么总节点数最多有 $2n - 1$ 个，这是正常情况。</p>
<p>在一些特殊情况下，倒数第二层最多有 $n - 1$ 个叶子节点，有一个节点在最后一层，那么倒数第二层及之前最多有 $2n - 3$ 个节点，而最后一层由于有了一个点所以要把这一层开满，也就是倒数第二层的两倍 $2n - 2$，所以节点总数最多为 $4n - 5$。</p>
<p>为了避免这种情况，所以我们<em>物尽其用</em>，做到用多少开多少，那么此时最大空间为 $2n - 1$。</p>
<p>也就是要开两倍空间。</p>
<p>由于我们不再记录节点的左右边界，所以要放到函数参数里，<code>pushdown</code> 的时候也要记录一下节点区间大小。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) tr[tr[x].l]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) tr[tr[x].r]</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, idx, root;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL sum, add;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = <span class="built_in">ls</span>(u).sum + <span class="built_in">rs</span>(u).sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[u].l) tr[u].l = ++idx;</span><br><span class="line">        <span class="keyword">if</span>(!tr[u].r) tr[u].r = ++idx;</span><br><span class="line">        <span class="built_in">ls</span>(u).add += tr[u].add;</span><br><span class="line">        <span class="built_in">rs</span>(u).add += tr[u].add;</span><br><span class="line">        <span class="built_in">ls</span>(u).sum += (LL)(len + <span class="number">1</span>) / <span class="number">2</span> * tr[u].add;</span><br><span class="line">        <span class="built_in">rs</span>(u).sum += (LL)len / <span class="number">2</span> * tr[u].add;</span><br><span class="line">        tr[u].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> <span class="comment">// 节点编号，节点区间，修改区间，加v</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u) u = ++idx;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[u].sum += v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tr[u].add += v;</span><br><span class="line">        tr[u].sum += (LL)(r - l + <span class="number">1</span>) * v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(u, r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">modify</span>(tr[u].l, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">modify</span>(tr[u].r, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(u, r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) res += <span class="built_in">query</span>(tr[u].l, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) res += <span class="built_in">query</span>(tr[u].r, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">modify</span>(root, <span class="number">1</span>, n, i, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            <span class="built_in">modify</span>(root, <span class="number">1</span>, n, x, y, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(root, <span class="number">1</span>, n, x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h2><blockquote>
<p>又叫做主席树</p>
</blockquote>
<p>$M$ 次修改， $M + 1$ 个版本。</p>
<p>某一个节点发生了变化，那就创建一个新的节点，否则就用原来的。</p>
<p>每次最多修改 $4logn$ 的点，所以一共需要最多 $4 logn \times m$ 倍的空间。</p>
<p>节点存储它的左右儿子的编号，节点的区间作为函数参数即可。</p>
<p>可持久化线段树难以进行区间修改。</p>
<p>因为有很多版本的很多懒标记需要更新。</p>
<p>除非做成<em>永久化懒标记</em>。</p>
<p><del>咕咕咕</del></p>
<p>相对于 Trie 树，它不会新加入一些点。</p>
<p>只是把要修改的点复制过来，然后修改它的一部分信息。</p>
<p>相当于动态开点。</p>
<p>每次先开一个点，然后把之前版本相应的节点先复制过来，如果没有那么就相当于复制了空信息，</p>
<hr>
<p><a class="link"   href="https://www.acwing.com/problem/content/257/" >AcWing255<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>首先这是一个静态问题。</p>
<ul>
<li><del>归并树</del></li>
<li>划分树</li>
<li>树套树（线段树套平衡树）</li>
<li>可持久化线段树</li>
</ul>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>划分树</td>
<td>$O(NlogN)$</td>
<td>$O(NlogN)$</td>
</tr>
<tr>
<td>树套树</td>
<td>$O(Mlog^2N)$</td>
<td>$O(NlogN)$</td>
</tr>
<tr>
<td>主席树</td>
<td>$O(NlogN)$</td>
<td>$O(NlogN)$</td>
</tr>
</tbody></table>
<p>所以划分树被完全取代了。</p>
<p>用线段树维护值域。</p>
<p>这里插入一个概念：<em>权值线段树</em>。</p>
<p>以值域为下标建立线段树，维护的是一段值域内数的个数，相当于用线段树维护了一堆桶。</p>
<p>先将值域离散化。</p>
<p>在数值上建立线段树。</p>
<p>维护每个数值区间中一共有多少个数。</p>
<p>先考虑如何求整体第 $k$ 小数，可以进行二分，直到找到一个位置使得它左边小于等于 $k$ 的数刚好为 $k$ 。</p>
<p>对于右边界，可以查询历史版本。</p>
<p>每个版本相当于比原来的版本多加了一个数，改变了线段树中的 $logN$ 个节点。</p>
<p>而线段树每个版本的结构都是不变的。</p>
<p>总节点数量在变？那是因为有新版本的节点替代了老版本的节点，所以一开始空树里有 $4N$ 个节点，后来还要再插入 $N$ 个数，每插入一个数最多可以增加 $logN$ 个节点，所以需要开的空间是 $(4 + logN)N$ 。</p>
<p>可以考虑前缀和，同时查一下 $l - 1$ 版本即可，这样就可以知道 $l\sim r$ 的这些数内，某段值域的变化量，然后就可以类似二分地找到这些数中第 $k$ 小的数。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[(N &lt;&lt; <span class="number">2</span>) + N * <span class="number">17</span>]; <span class="comment">// 4N + NlogN</span></span><br><span class="line"><span class="type">int</span> root[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), x) - nums.<span class="built_in">begin</span>(); <span class="comment">// 离散化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> <span class="comment">// 建立左右边界为 l 和 r 的线段树节点并返回其编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = ++idx;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tr[p].l = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    tr[p].r = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> <span class="comment">// 上一个版本的节点，左边界右边界，需要插入的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = ++idx; <span class="comment">// 新节点</span></span><br><span class="line">    tr[q] = tr[p]; <span class="comment">// 先复制，注意由于树的结构没有发生改变，所以 p 和 q 分别对应着老版本和新版本中同一个节点。</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[q].cnt++;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) tr[q].l = <span class="built_in">insert</span>(tr[p].l, l, mid, x); <span class="comment">// 注意第一个参数，历史版本同步递归</span></span><br><span class="line">    <span class="keyword">else</span> tr[q].r = <span class="built_in">insert</span>(tr[p].r, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt; <span class="comment">// 更新节点信息</span></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> q, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> <span class="comment">// 新版本，旧版本，左右边界，第 k 小的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="type">int</span> cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= cnt) <span class="keyword">return</span> <span class="built_in">query</span>(tr[q].l, tr[p].l, l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(tr[q].r, tr[p].r, mid + <span class="number">1</span>, r, k - cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        nums.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">// 初始化空树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        root[i] = <span class="built_in">insert</span>(root[i - <span class="number">1</span>], <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="built_in">find</span>(a[i]));</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nums[<span class="built_in">query</span>(root[r], root[l - <span class="number">1</span>], <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, k)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p><a class="link"   href="https://white.fallingsakura.top/3618463430/" >A1275<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://white.fallingsakura.top/2123984512/" >A245<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.acwing.com/problem/content/249/" >A247<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.acwing.com/problem/content/1279/" >A1277<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307241126046.webp"
                      alt="image.png"
                ></p>
<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><blockquote>
<p>树形结构的数组</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307252022858.webp"
                      alt="image.png"
                ></p>
<h2 id="Lowbit函数"><a href="#Lowbit函数" class="headerlink" title="Lowbit函数"></a>Lowbit函数</h2><blockquote>
<p><code>lowbit(i)=i&amp;-i</code></p>
</blockquote>
<p>这是树状数组最重要的一个环节。</p>
<p>单点修改向上传递时，每次加上当前点的$lowbit$</p>
<p>区间查询向下访问时，每次减去当前点的$lowbit$</p>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P3374" >P3374<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        t[i]+=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=y;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        ans+=t[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x<span class="number">-1</span>;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        ans-=t[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a),<span class="built_in">modify</span>(i,a);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.luogu.com.cn/problem/P3368" >P3368<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n,m,a;</span><br><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        t[i]+=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=y<span class="number">+1</span>;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        t[i]-=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        ans+=t[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a),<span class="built_in">modify</span>(i,i,a);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,x,y,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;y,&amp;k);</span><br><span class="line">            <span class="built_in">modify</span>(x,y,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://acm.hdu.edu.cn/showproblem.php?pid=1166" >HDU1166<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        t[i]+=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> an=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=y;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        an+=t[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x<span class="number">-1</span>;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        an-=t[i];</span><br><span class="line">    <span class="keyword">return</span> an;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(t,<span class="number">0</span>,<span class="built_in">sizeof</span>(t));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">            <span class="built_in">modify</span>(j,a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x,y,ans;</span><br><span class="line">        <span class="type">char</span> ss[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>,i);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss),ss[<span class="number">0</span>]!=<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ss[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">                ans=<span class="built_in">query</span>(x,y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ss[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">                <span class="built_in">modify</span>(x,y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ss[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">                <span class="built_in">modify</span>(x,-y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h1><h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><blockquote>
<p>Tree + heap</p>
</blockquote>
<p>二叉搜索树和堆的一个有机结合。</p>
<h3 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h3><blockquote>
<p>Binary search tree | 二叉搜索树</p>
</blockquote>
<p>每个节点都有一个权值，满足当前节点的左子树中的任何一个点的权值，右子树的任何一个点的权值大于该点，若有重复的，那就记录一下这个值出现了多少次。</p>
<p>BST 的<strong>中序遍历</strong>是严格单调递增的。</p>
<p>它在动态维护一个有序序列。</p>
<ol>
<li>插入</li>
<li>删除（叶节点）</li>
<li>找前驱（中序遍历的前一个位置）&#x2F;后继（中序遍历的后一个位置）</li>
<li>找最大（不断走右儿子直到不能走）&#x2F;最小值（不断走左儿子直到不能走）<br>以上 set 均可满足</li>
<li>求某个值的排名</li>
<li>求排名是 k 的数是哪个</li>
<li>找到比某个数小的最大值</li>
<li>找到比某个数大的最小值</li>
</ol>
<p>Treap 可以让 BST 尽量随机，使得其期望高度为 logn</p>
<p>节点：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l, r;</span><br><span class="line">	<span class="type">int</span> key, val; <span class="comment">// 排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>key 代表 BST 中排序的关键字，而 val 为<strong>大根堆</strong>中排序的关键字，那么假如所有节点的这两个值都互不相同，那么可以确定出唯一的平衡树：从上往下递归，每层将子树节点分为两部分，左子树 key 都小于根节点，右子树 key 都大于根节点，然后分别取两部分的 val 的最大值的节点作为子树的根。</p>
<p>val 是一个随机值。</p>
<p>一般初始化可以为空，但为了防止越界，可以安排两个哨兵，一个为负无穷作为根节点，一个为正无穷作为根的右子树的根节点，那么就可以保证从右儿子的左子树中搜索一定是在边界范围内的。</p>
<p>平衡树一个点只会对应一个数，所以空间复杂度为 $O(n)$。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>递归插入，并给这个节点赋值一个 val，然后类似堆更新一下结构。</p>
<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><ul>
<li>右旋（zig）：</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310051735460.webp"
                      alt="image.png"
                ></p>
<ul>
<li>左旋（zag）：</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310051737122.webp"
                      alt="image.png"
                ></p>
<blockquote>
<p>平衡树的旋转：右旋拎左右挂左，左旋拎右左挂右。</p>
</blockquote>
<p>性质：</p>
<p>旋转完后不会改变平衡树的中序遍历。</p>
<p>左旋是交换一下一个节点和它右儿子的父子关系，也就是相当于把右儿子给左旋到了父亲的位置，同时要维护中序不变。</p>
<p>右旋同理。</p>
<p>旋转需要特判，哪个大旋转哪个上去。</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/255/" >AcWing235<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> key, val;</span><br><span class="line">    <span class="type">int</span> cnt, siz; <span class="comment">// 这个数有几个，siz表示子树大小</span></span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> root, idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_node</span><span class="params">(<span class="type">int</span> key)</span> <span class="comment">// 创建节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[++idx].key = key;</span><br><span class="line">    tr[idx].val = <span class="built_in">rand</span>();</span><br><span class="line">    tr[idx].cnt = tr[idx].siz = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].siz = tr[tr[p].l].siz + tr[tr[p].r].siz + tr[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">get_node</span>(-INF), <span class="built_in">get_node</span>(INF);</span><br><span class="line">    root = <span class="number">1</span>, tr[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zig</span><span class="params">(<span class="type">int</span> &amp;p)</span> <span class="comment">// 右旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = tr[p].l;</span><br><span class="line">    tr[p].l = tr[q].r;</span><br><span class="line">    tr[q].r = p;</span><br><span class="line">    p = q; <span class="comment">// 交换编号</span></span><br><span class="line">    <span class="built_in">pushup</span>(tr[p].r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zag</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = tr[p].r;</span><br><span class="line">    tr[p].r = tr[q].l;</span><br><span class="line">    tr[q].l = p;</span><br><span class="line">    p = q;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[p].l);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p = <span class="built_in">get_node</span>(key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].key == key) tr[p].cnt++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].key &gt; key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(tr[p].l, key);</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[p].l].val &gt; tr[p].val) <span class="built_in">zig</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(tr[p].r, key);</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[p].r].val &gt; tr[p].val) <span class="built_in">zag</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].key == key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].cnt &gt; <span class="number">1</span>) tr[p].cnt--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].l || tr[p].r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">zig</span>(p);</span><br><span class="line">                <span class="built_in">remove</span>(tr[p].r, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">zag</span>(p);</span><br><span class="line">                <span class="built_in">remove</span>(tr[p].l, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].key &gt; key) <span class="built_in">remove</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">remove</span>(tr[p].r, key);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_rank_by_key</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].key == key) <span class="keyword">return</span> tr[tr[p].l].siz + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].key &gt; key) <span class="keyword">return</span> <span class="built_in">get_rank_by_key</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> tr[tr[p].l].siz + tr[p].cnt + <span class="built_in">get_rank_by_key</span>(tr[p].r, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_key_by_rank</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> rank)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span>(tr[tr[p].l].siz &gt;= rank) <span class="keyword">return</span> <span class="built_in">get_key_by_rank</span>(tr[p].l, rank);</span><br><span class="line">    <span class="keyword">if</span>(tr[tr[p].l].siz + tr[p].cnt &gt;= rank) <span class="keyword">return</span> tr[p].key;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_key_by_rank</span>(tr[p].r, rank - tr[tr[p].l].siz - tr[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_prev</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].key &gt;= key) <span class="keyword">return</span> <span class="built_in">get_prev</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(tr[p].key, <span class="built_in">get_prev</span>(tr[p].r, key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_next</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].key &lt;= key) <span class="keyword">return</span> <span class="built_in">get_next</span>(tr[p].r, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(tr[p].key, <span class="built_in">get_next</span>(tr[p].l, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) <span class="built_in">insert</span>(root, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>) <span class="built_in">remove</span>(root, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_rank_by_key</span>(root, x) - <span class="number">1</span>); <span class="comment">// 哨兵</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_key_by_rank</span>(root, x + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_prev</span>(root, x));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_next</span>(root, x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ???</span></span><br><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment">vector&lt;int&gt; a;</span></span><br><span class="line"><span class="comment">int qread()&#123;</span></span><br><span class="line"><span class="comment">    int fx=0; </span></span><br><span class="line"><span class="comment">    char ch=getchar();</span></span><br><span class="line"><span class="comment">    while(ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar();</span></span><br><span class="line"><span class="comment">    while(ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;)&#123;</span></span><br><span class="line"><span class="comment">        fx=fx*10+ch-&#x27;0&#x27;;</span></span><br><span class="line"><span class="comment">        ch=getchar();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return fx;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int n,opt,x;</span></span><br><span class="line"><span class="comment">    scanf(&quot;%d&quot;,&amp;n);</span></span><br><span class="line"><span class="comment">    a.reserve(100005);</span></span><br><span class="line"><span class="comment">    while(n--)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        scanf(&quot;%d%d&quot;,&amp;opt,&amp;x);</span></span><br><span class="line"><span class="comment">        switch(opt)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            case 1:a.insert(upper_bound(a.begin(),a.end(),x),x); break;</span></span><br><span class="line"><span class="comment">            case 2:a.erase(lower_bound(a.begin(),a.end(),x)); break;</span></span><br><span class="line"><span class="comment">            case 3:cout&lt;&lt;lower_bound(a.begin(),a.end(),x)-a.begin()+1&lt;&lt;endl; break;</span></span><br><span class="line"><span class="comment">            case 4:cout&lt;&lt;a[x-1]&lt;&lt;endl; break;</span></span><br><span class="line"><span class="comment">            case 5:cout&lt;&lt;(*--lower_bound(a.begin(),a.end(),x))&lt;&lt;endl; break;</span></span><br><span class="line"><span class="comment">            case 6:cout&lt;&lt;(*upper_bound(a.begin(),a.end(),x))&lt;&lt;endl; break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/267/" >AcWing256<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>在一堆数中找到和某个数最接近的数。</p>
<p>可以分成两种情况：前驱和后继。</p>
<p>所以操作就有：</p>
<ol>
<li>插入</li>
<li>找前驱（<code>lower_bound</code>）&#x2F;后继（<code>upper_bound--</code>）</li>
</ol>
<p>所有 set 能做的平衡树都可以做，平衡树可以多维护几个值，而 set 不行。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">33300</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> key, val;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> root, idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_node</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[++idx].key = key;</span><br><span class="line">    tr[idx].val = <span class="built_in">rand</span>();</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">get_node</span>(-INF);</span><br><span class="line">    <span class="built_in">get_node</span>(INF);</span><br><span class="line">    root = <span class="number">1</span>;</span><br><span class="line">    tr[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zig</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = tr[p].l;</span><br><span class="line">    tr[p].l = tr[q].r;</span><br><span class="line">    tr[q].r = p;</span><br><span class="line">    p = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zag</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = tr[p].r;</span><br><span class="line">    tr[p].r = tr[q].l;</span><br><span class="line">    tr[q].l = p;</span><br><span class="line">    p = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p = <span class="built_in">get_node</span>(key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].key == key) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].key &gt; key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(tr[p].l, key);</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[p].l].val &gt; tr[p].val) <span class="built_in">zig</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(tr[p].r, key);</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[p].r].val &gt; tr[p].val) <span class="built_in">zag</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_prev</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].key &gt; key) <span class="keyword">return</span> <span class="built_in">get_prev</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(tr[p].key, <span class="built_in">get_prev</span>(tr[p].r, key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_next</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].key &lt; key) <span class="keyword">return</span> <span class="built_in">get_next</span>(tr[p].r, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(tr[p].key, <span class="built_in">get_next</span>(tr[p].l, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) res += x;</span><br><span class="line">        <span class="keyword">else</span> res += <span class="built_in">min</span>(x - <span class="built_in">get_prev</span>(root, x), <span class="built_in">get_next</span>(root, x) - x);</span><br><span class="line">        <span class="built_in">insert</span>(root, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>把对应节点旋转到叶子节点后删除即可。</p>
<h2 id="FHQ-Treap"><a href="#FHQ-Treap" class="headerlink" title="FHQ Treap"></a>FHQ Treap</h2><blockquote>
<p>非旋转 Treap，通过分裂和合并来维护。<br><a class="link"   href="https://www.luogu.com.cn/blog/85514/fhq-treap-xue-xi-bi-ji" >参考文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h3 id="Split"><a href="#Split" class="headerlink" title="Split"></a>Split</h3><p>一旦优先级确定，并且一个单调递增的序列确定，那么这个区间怎样分裂和合并对这颗树的结构是没有影响的。</p>
<p>所以我们把整个区间分为<strong>左区间</strong>和<strong>右区间</strong>，相当于切了一刀。</p>
<p>一开始先创建两个虚拟点，然后从原二叉搜索树中的根节点开始遍历，假如当前节点的 $val_{now}$ 小于等于划分的边界的 $val$，那么当前节点以及它的子树都应该属于左区间，此时应该将左区间的虚拟点的指针指向当前节点，虚拟节点由虚变实，然后以当前节点的右儿子为下一个虚拟点继续递归，因为 $\le val_{now}$ 的都已经在左区间了，我们还要找的是 $val_{now} &lt; x\le val$ 的节点。</p>
<p>假如当前节点的 $val_{now}$ 大于划分的边界 $val$ 的话，那么我们就应该把当前节点以及它的右子树给划分到右区间中，并将虚拟点的指针指向当前节点，把当前节点的左儿子变为下一个虚拟点继续递归。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> k, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x y 代表的是当前递归的是左区间还是右区间的节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now)</span><br><span class="line">    &#123;</span><br><span class="line">        x = y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[now].val &lt;= k)</span><br><span class="line">    &#123;</span><br><span class="line">        x = now;</span><br><span class="line">        <span class="built_in">split</span>(tr[now].r, k, tr[now].r, y); <span class="comment">// 左区间的当前点的右儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        y = now;</span><br><span class="line">        <span class="built_in">split</span>(tr[now].l, k, x, tr[now].l); <span class="comment">// 右区间的当前点的左儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(now);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">split</span>(root, q, x, y); <span class="comment">// 分裂后 x 得到的就是左区间的根节点，y 就是右区间的根节点。</span></span><br></pre></td></tr></table></figure></div>



<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><h2 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h2><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>STL map</li>
<li>红黑树（巨麻烦）</li>
<li>SBT</li>
<li>AVL</li>
</ul>
<h1 id="可持久化"><a href="#可持久化" class="headerlink" title="可持久化"></a>可持久化</h1><blockquote>
<p>数据结构可以进行可持久化的前提是本身的拓扑结构不变，变的只是里面的数据。</p>
</blockquote>
<p>比如：线段树、树状数组、Trie 树、堆、并查集。</p>
<p>可以把所有的修改的历史版本记录下来。</p>
<p>如果全部备份的话，那么消耗会非常的大。</p>
<p>只需要记录每一个版本相对于前一个版本变化的地方。</p>
<p>比如线段树，每次操作最多需要记录 log 级别的节点，把复杂度从平方变成 log。</p>
<h2 id="字符串-可持久化-Trie-树-可持久化-Trie-树"><a href="#字符串-可持久化-Trie-树-可持久化-Trie-树" class="headerlink" title="[[字符串#可持久化 Trie 树|可持久化 Trie 树]]"></a>[[字符串#可持久化 Trie 树|可持久化 Trie 树]]</h2><h2 id="数据结构-可持久化线段树-可持久化线段树"><a href="#数据结构-可持久化线段树-可持久化线段树" class="headerlink" title="[[数据结构#可持久化线段树|可持久化线段树]]"></a>[[数据结构#可持久化线段树|可持久化线段树]]</h2><h1 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h1><p>可以通过给树中的点编号，使得可以将书中任意一条路径变成链的序列里 $logn$ 段连续的区间。</p>
<p>就可以把树上问题转化为区间问题。</p>
<p>转换为区间后，用数据结构就可以维护了。</p>
<ol>
<li>重儿子&#x2F;轻儿子（叶子节点没有），重儿子为子树大小最大的儿子，若多个都是最大，那么就任选一个，其它都是轻儿子。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310101616428.webp"
                      alt="image.png|300"
                ></p>
<ol start="2">
<li>重&#x2F;轻边：重儿子和它父亲之间的边叫做重边，其余的叫做轻边。</li>
<li>重&#x2F;轻链：重边组成重链，落单的节点也叫做重链，重儿子所在的重链为它父亲所在的重链，轻儿子所在的重链为它重儿子所在的重链。</li>
</ol>
<p>按照 DFS 序（<strong>优先遍历重儿子</strong>，这样重链的编号都是连续的，顺便求一下子树大小）把整个树变成一个区间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202310101622754.webp"
                      alt="image.png|300"
                ></p>
<p>定理：树中任意一条路径均可拆分成 $O(logn)$ 条重链（即连续区间）。</p>
<p>标记一下每个点所在重链的顶点即可。</p>
<p>那么如何把路径用区间表示呢？</p>
<p>可以用类似最近公共祖先的方法，每次取深度较深的重链，让它向上走，直到走到同一条重链（最近公共祖先所在的重链），这样就可以分为 $logn$ 条链（也就是区间），这样就可以对区间进行操作，总复杂度在 $log^2n$ 的级别内。</p>
<p>并且可以注意到重链的顶点一定是某一个轻儿子。</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/2570/" >A2568<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ol>
<li>区间修改</li>
<li>区间修改（因为子树里的点 DFS 编号是连续的）</li>
<li>区间查询</li>
<li>区间查询</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt, to;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> id[N], nw[N], cnt, idx;</span><br><span class="line"><span class="type">int</span> dep[N], sz[N], top[N], fa[N], son[N]; <span class="comment">// 深度，子树大小，重链顶点，父节点，儿子节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL sum, add;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++idx].nxt = fir[u];</span><br><span class="line">    e[idx].to = v;</span><br><span class="line">    fir[u] = idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;righ = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.add)</span><br><span class="line">    &#123;</span><br><span class="line">        left.add += root.add;</span><br><span class="line">        righ.add += root.add;</span><br><span class="line">        left.sum += (left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        righ.sum += (righ.r - righ.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l = l, tr[u].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum = nw[r];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].add += k;</span><br><span class="line">        tr[u].sum += k * (tr[u].r - tr[u].l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fath, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[u] = depth, fa[u] = fath;</span><br><span class="line">    sz[u] = <span class="number">1</span>; <span class="comment">// important</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = fir[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == fath) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u, depth + <span class="number">1</span>);</span><br><span class="line">        sz[u] += sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[u]] &lt; sz[v]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[u] = ++cnt;</span><br><span class="line">    nw[cnt] = w[u]; <span class="comment">// 方便线段树的维护</span></span><br><span class="line">    top[u] = t;</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = fir[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_path</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v]) <span class="comment">// 不在同一条重链里</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]] &lt; dep[top[v]]) <span class="built_in">swap</span>(u, v); <span class="comment">// 保证 u 所在重链较深</span></span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, id[top[u]], id[u], k);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) <span class="built_in">swap</span>(u, v); <span class="comment">// u 深度更大</span></span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, id[v], id[u], k); <span class="comment">// 在同一条重链里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query_path</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]] &lt; dep[top[v]]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        res += <span class="built_in">query</span>(<span class="number">1</span>, id[top[u]], id[u]);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    res += <span class="built_in">query</span>(<span class="number">1</span>, id[v], id[u]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_tree</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, id[u], id[u] + sz[u] - <span class="number">1</span>, k); <span class="comment">// 子树是一段连续的区间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query_tree</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, id[u], id[u] + sz[u] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>); <span class="comment">// 点的编号 父节点 深度</span></span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 当前点 重链的顶点 </span></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t, u, v, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t, &amp;u);</span><br><span class="line">        <span class="keyword">switch</span>(t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v, &amp;k);</span><br><span class="line">                <span class="built_in">update_path</span>(u, v, k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">                <span class="built_in">update_tree</span>(u, k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query_path</span>(u, v));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query_tree</span>(u));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.acwing.com/problem/content/920/" >A918<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>A 依赖 B，每个软件有且只有一个依赖软件，安装 A 之前必须安装 B，卸载 B 之前必须先卸载 A。</p>
<p>每个点只有两个状态：已安装&#x2F;未安装。</p>
<p>操作：</p>
<ul>
<li>安装 x：把根到 x 路径上的所有点变成 1</li>
<li>卸载 x：把以 x 为根的子树全部变成 0</li>
</ul>
<p>询问：</p>
<p>操作了多少个节点，维护一下总的区间和，作差即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt, idx;</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">int</span> dep[N], sz[N], top[N], fa[N], son[N], id[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt, to;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="comment">// -1:ÎÞ²Ù×÷ 0:°Ñ½ÚµãËùÓÐÖµ±ä³É0 1:°Ñ½ÚµãËùÓÐÖµ±äÎª1</span></span><br><span class="line">    <span class="type">int</span> add, sum;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].nxt = fir[u];</span><br><span class="line">    e[cnt].to = v;</span><br><span class="line">    fir[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[u] = depth, sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = fir[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, depth + <span class="number">1</span>);</span><br><span class="line">        sz[u] += sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[u]] &lt; sz[v]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[u] = ++idx;</span><br><span class="line">    top[u] = t;</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = fir[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;righ = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.add != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        left.add = righ.add = root.add;</span><br><span class="line">        left.sum = (left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        righ.sum = (righ.r - righ.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l = l, tr[u].r = r, tr[u].add = <span class="number">-1</span>, tr[u].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].add = k;</span><br><span class="line">        tr[u].sum = k * (tr[u].r - tr[u].l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_path</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]] &lt; dep[top[v]]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, id[top[u]], id[u], k);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, id[v], id[u], k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_tree</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, id[u], id[u] + sz[u] - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">        p++;</span><br><span class="line">        <span class="built_in">add</span>(p, i);</span><br><span class="line">        fa[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;u);</span><br><span class="line">        u++;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;install&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = tr[<span class="number">1</span>].sum;</span><br><span class="line">            <span class="built_in">update_path</span>(<span class="number">1</span>, u, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tr[<span class="number">1</span>].sum - t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = tr[<span class="number">1</span>].sum;</span><br><span class="line">            <span class="built_in">update_tree</span>(u, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t - tr[<span class="number">1</span>].sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">g</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>题解汇总</title>
    <url>/859461957.html</url>
    <content><![CDATA[<blockquote>
<p>也没有很杂</p>
</blockquote>
<h1 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h1><h2 id="P3469"><a href="#P3469" class="headerlink" title="P3469"></a>P3469</h2><p>分两种情况讨论：</p>
<ul>
<li>如果删去的这个点不是割点，那么有序点对的数不变，连通分量只有两个，分别是这个点和剩下的所有点，答案是$2\times(n-1)$。</li>
<li>如果删去的这个点是割点，那么这张连通图将会变为若干连通分量，分别是这个点、这个点的若干个子树，以及剩下的所有点。设$siz_i$代表第$i$个子树的大小，$sum$为$i$的的子树大小之和。那么答案就是$\sum_i{siz_i\times(n-siz_i)}+1\times(n-1)+(n-sum-1)\times(sum+1)$。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,edcnt,cnt;</span><br><span class="line"><span class="type">int</span> fir[N],dfsn[N],low[N],siz[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans[N];</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    dfsn[p]=low[p]=++cnt;</span><br><span class="line">    siz[p]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[p];i;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfsn[q])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(q);</span><br><span class="line">            siz[p]+=siz[q];</span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[p],low[q]);</span><br><span class="line">            <span class="keyword">if</span>(low[q]&gt;=dfsn[p])<span class="comment">//割点</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans[p]+=<span class="number">1ll</span>*siz[q]*(n-siz[q]);</span><br><span class="line">                sum+=siz[q];</span><br><span class="line">                tot++;</span><br><span class="line">                <span class="keyword">if</span>(p!=<span class="number">1</span>||tot&gt;<span class="number">1</span>) cut[p]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[p]=<span class="built_in">min</span>(low[p],dfsn[q]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!cut[p]) ans[p]=<span class="number">2</span>*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> ans[p]+=(n<span class="number">-1</span>)*<span class="number">1</span><span class="number">+1ll</span>*(n-sum<span class="number">-1</span>)*(sum<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="P2860"><a href="#P2860" class="headerlink" title="P2860"></a>P2860</h2><p>先求一下边双连通分量，然后对边双连通分量进行缩点，然后就可以找到度数为1的节点，答案就是$\lceil\frac{s}{2}\rceil$，也就是叶子节点的个数除以2上取整。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5050</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,edcnt,cnt,cdcc,ans;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; bj[N];</span><br><span class="line"><span class="type">int</span> fir[N],low[N],fa[N],dfsn[N],dcc[N],dd[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfsn[p]=low[p]=++cnt;</span><br><span class="line">    s.<span class="built_in">push</span>(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[p];i;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfsn[q])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[q]=p;</span><br><span class="line">            <span class="built_in">tarjan</span>(q);</span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[p],low[q]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fa[p]!=q) low[p]=<span class="built_in">min</span>(low[p],dfsn[q]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfsn[p]==low[p])</span><br><span class="line">    &#123;</span><br><span class="line">        cdcc++;</span><br><span class="line">        <span class="type">int</span> top;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            top=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            dcc[top]=cdcc;</span><br><span class="line">        &#125; <span class="keyword">while</span> (top!=p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="comment">// if(u==v) continue;</span></span><br><span class="line">        <span class="keyword">if</span>(bj[u][v]||bj[v][u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">        bj[u][v]=<span class="literal">true</span>;</span><br><span class="line">        bj[v][u]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=edcnt;i+=<span class="number">2</span>)<span class="comment">//建新图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=e[i].to;</span><br><span class="line">        <span class="type">int</span> y=e[i<span class="number">+1</span>].to;</span><br><span class="line">        <span class="keyword">if</span>(dcc[x]!=dcc[y])</span><br><span class="line">            dd[dcc[x]]++,dd[dcc[y]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cdcc;i++)</span><br><span class="line">        <span class="keyword">if</span>(dd[i]==<span class="number">1</span>) ans++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(ans<span class="number">+1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>记得判重边！</p>
<h2 id="P2783"><a href="#P2783" class="headerlink" title="P2783"></a>P2783</h2><p>点双连通分量的缩点，然后利用LCA求距离，$x$到$y$的距离为$depth_x+depth_y-2\times{depth_{lca(x,y)}}$</p>
<p>由于是碳的个数，所以还需要加一。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">5e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,cdcc,q;</span><br><span class="line"><span class="type">int</span> low[N],dfsn[N],cnt,edcnt;</span><br><span class="line"><span class="type">int</span> fir[N],fa[N];</span><br><span class="line"><span class="type">int</span> dcc[N],depth[N],f[N][<span class="number">23</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; bj[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; mp[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[p]=dfsn[p]=++cnt;</span><br><span class="line">    s.<span class="built_in">push</span>(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[p];i;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfsn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[v]=p;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[p],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(v!=fa[p]) low[p]=<span class="built_in">min</span>(low[p],dfsn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfsn[p]==low[p])</span><br><span class="line">    &#123;</span><br><span class="line">        cdcc++;</span><br><span class="line">        <span class="type">int</span> top;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            top=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            dcc[top]=cdcc;</span><br><span class="line">        &#125; <span class="keyword">while</span> (top!=p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:mp[u])</span><br><span class="line">        <span class="keyword">if</span>(v!=f[u][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            depth[v]=depth[u]<span class="number">+1</span>;</span><br><span class="line">            f[v][<span class="number">0</span>]=u;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">21</span>;i++)</span><br><span class="line">                f[v][i]=f[f[v][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[x]&lt;depth[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">21</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(depth[f[x][i]]&gt;=depth[y])</span><br><span class="line">            x=f[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">21</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nx=f[x][i];</span><br><span class="line">        <span class="type">int</span> ny=f[y][i];</span><br><span class="line">        <span class="keyword">if</span>(nx!=ny)</span><br><span class="line">        &#123;</span><br><span class="line">            x=nx;</span><br><span class="line">            y=ny;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dist</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="built_in">lca</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> depth[x]+depth[y]<span class="number">-2</span>*depth[l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(bj[u][v]||bj[v][u]) <span class="keyword">continue</span>;</span><br><span class="line">        bj[u][v]=<span class="literal">true</span>;</span><br><span class="line">        bj[v][u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=fir[i];j;j=e[j].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[j].to;</span><br><span class="line">            <span class="keyword">if</span>(dcc[i]!=dcc[v])</span><br><span class="line">                mp[dcc[i]].<span class="built_in">push_back</span>(dcc[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    depth[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="type">int</span> ans=<span class="built_in">dist</span>(dcc[x],dcc[y])<span class="number">+1</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ans&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j]=ans&amp;<span class="number">1</span>;</span><br><span class="line">            j++;</span><br><span class="line">            ans&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j--;j&gt;=<span class="number">0</span>;j--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h3 id="P1219八皇后"><a href="#P1219八皇后" class="headerlink" title="P1219八皇后"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1219" >P1219八皇后<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>左下对角线的横纵坐标之和不变，右下对角线的横纵坐标之差不变，作差要记得加上 $n$，防止负数下标。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> <span class="number">+7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,tot;</span><br><span class="line"><span class="type">bool</span> line[N], ldia[N], rdia[N];</span><br><span class="line"><span class="type">int</span> row[N];</span><br><span class="line"><span class="comment">// 行，列，左下对角线，右下对角线</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        tot++;</span><br><span class="line">        <span class="keyword">if</span>(tot &gt; <span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, row[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(line[i]) &amp;&amp; (!ldia[x + i]) &amp;&amp; (!rdia[x - i +n]))</span><br><span class="line">        &#123;</span><br><span class="line">            row[x] = i;</span><br><span class="line">            line[i] = <span class="literal">true</span>;</span><br><span class="line">            ldia[x + i] = <span class="literal">true</span>;</span><br><span class="line">            rdia[x + n - i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">Dfs</span>(x + <span class="number">1</span>); <span class="comment">// 找下一行</span></span><br><span class="line">            line[i] = <span class="literal">false</span>;</span><br><span class="line">            ldia[x + i] = <span class="literal">false</span>;</span><br><span class="line">            rdia[x + n - i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">Dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="P1019单词接龙"><a href="#P1019单词接龙" class="headerlink" title="P1019单词接龙"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1019" >P1019单词接龙<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>注释。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">22</span>;</span><br><span class="line">string s[N];</span><br><span class="line"><span class="type">int</span> used[N],length = <span class="number">0</span>, n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Link</span><span class="params">(string s1, string s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">min</span>(s<span class="number">1.l</span>ength(), s<span class="number">2.l</span>ength());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) <span class="comment">// 枚举重叠长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> bj = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="comment">// 枚举s1的后缀和s2的前缀</span></span><br><span class="line">            <span class="keyword">if</span>(s1[s<span class="number">1.l</span>ength() - i + j] != s2[j]) bj = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 由于要使拼接后最长，也就是使重叠部分最短，那么找到就返回即可</span></span><br><span class="line">        <span class="keyword">if</span>(bj) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没有就是 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dfs</span><span class="params">(string now, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = <span class="built_in">max</span>(len, length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(used[i] &gt;= <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> over = <span class="built_in">Link</span>(now, s[i]);</span><br><span class="line">        <span class="keyword">if</span>(over &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            used[i]++;</span><br><span class="line">            <span class="built_in">Dfs</span>(s[i], len + s[i].<span class="built_in">length</span>() - over);</span><br><span class="line">            used[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">    <span class="built_in">Dfs</span>(<span class="string">&#x27; &#x27;</span> + s[n], <span class="number">1</span>); <span class="comment">//凑长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="P5194"><a href="#P5194" class="headerlink" title="P5194"></a><a class="link"   href="https://www.luogu.com.cn/problem/P5194" >P5194<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, c;</span><br><span class="line">ll ans = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line">ll pre[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dfs</span><span class="params">(<span class="type">int</span> x, ll sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &gt; c)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(pre[x - <span class="number">1</span>] + sum &lt;= c) <span class="comment">// 如果之前都可以拿那就都拿了</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, pre[x - <span class="number">1</span>] + sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="built_in">Dfs</span>(i, sum + w[i]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] + w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dfs</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h2><h3 id="P3398"><a href="#P3398" class="headerlink" title="P3398"></a>P3398</h3><p>树上两条路径有交点，路径分别为$a\leftrightarrow{b}$和$c\leftrightarrow{d}$，那么一定有$lca(a,b)$在$c,d$路径上或者$lca(c,d)$在$a,b$路径上。</p>
<p>判断一个点是否在一个路径上，可以判断这个点到左右端点的距离之和是否等于做右端点的距离，而处理两点之间距离可以通过$lca$来求。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,q,edcnt;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+9</span>;</span><br><span class="line"><span class="type">int</span> fir[N],depth[N],f[N][<span class="number">23</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=f[u][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            depth[v]=depth[u]<span class="number">+1</span>;</span><br><span class="line">            f[v][<span class="number">0</span>]=u;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">21</span>;i++)</span><br><span class="line">                f[v][i]=f[f[v][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">            <span class="built_in">init</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> p1,<span class="type">int</span> p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[p1]&lt;depth[p2]) <span class="built_in">swap</span>(p1,p2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">21</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[f[p1][i]]&gt;=depth[p2]) p1=f[p1][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p1==p2) <span class="keyword">return</span> p1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">21</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[p1][i]!=f[p2][i])</span><br><span class="line">            p1=f[p1][i],p2=f[p2][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[p1][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dist</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="built_in">lca</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> depth[x]+depth[y]<span class="number">-2</span>*depth[l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">        <span class="type">int</span> lab=<span class="built_in">lca</span>(a,b),lcd=<span class="built_in">lca</span>(c,d);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dist</span>(c,lab)+<span class="built_in">dist</span>(d,lab)==<span class="built_in">dist</span>(c,d)||<span class="built_in">dist</span>(a,lcd)+<span class="built_in">dist</span>(b,lcd)==<span class="built_in">dist</span>(a,b)) <span class="built_in">printf</span>(<span class="string">&quot;Y\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;N\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="直径"><a href="#直径" class="headerlink" title="直径"></a>直径</h2><h3 id="P4408逃学的小孩"><a href="#P4408逃学的小孩" class="headerlink" title="P4408逃学的小孩"></a><a class="link"   href="https://www.luogu.com.cn/problem/P4408" >P4408逃学的小孩<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>首先，这是棵树，最坏情况下两个朋友的家正好是树的直径的两个端点，然后我们枚举一下树上每个点（不包含直径端点），看下这个点到两个端点之间距离的最小值最大即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,edcnt;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt,to,val;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">int</span> F,G;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].val=w;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> df[N][<span class="number">23</span>],depth[N];</span><br><span class="line">ll d[N];<span class="comment">//该点到根的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            df[v][<span class="number">0</span>]=u;</span><br><span class="line">            depth[v]=depth[u]<span class="number">+1</span>;</span><br><span class="line">            d[v]=d[u]+e[i].val;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">22</span>;j++)</span><br><span class="line">                df[v][j]=df[df[v][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    depth[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(depth[x]&lt;depth[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">22</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(depth[df[x][i]]&gt;=depth[y])</span><br><span class="line">            x=df[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">22</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(df[x][i]!=df[y][i])</span><br><span class="line">            x=df[x][i],y=df[y][i];</span><br><span class="line">    <span class="keyword">return</span> df[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dist</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d[x]+d[y]<span class="number">-2</span>*d[<span class="built_in">lca</span>(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,ll sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;=ans)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=sum;</span><br><span class="line">        F=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa) <span class="built_in">dfs1</span>(e[i].to,u,sum+e[i].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,ll sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;=ans)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=sum;</span><br><span class="line">        G=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa) <span class="built_in">dfs2</span>(e[i].to,u,sum+e[i].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(F,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    ans=<span class="number">-1</span>;</span><br><span class="line">    ll len=<span class="built_in">dist</span>(F,G);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(i!=F&amp;&amp;i!=G)</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">min</span>(<span class="built_in">dist</span>(i,F),<span class="built_in">dist</span>(i,G)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans+len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P3304直径"><a href="#P3304直径" class="headerlink" title="P3304直径"></a><a class="link"   href="https://www.luogu.com.cn/problem/P3304" >P3304直径<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>这道题首先 DFS 两遍求出直径以及直径的两个端点，然后再 DFS 一遍找到直径的路径，然后标记这条路径上的每一条边，然后再分别进行两次 DFS，这个过程中记录每个点以A&#x2F;B 为根节点时，到子树中非直径的最长路径，如果这个最长路径等与该点到对应直径端点的距离的话，那么就出现了分叉，这时候就可以被替代，所以这个点下面就不再是所有直径的公共边，就这样不断向内缩，从一端缩完再缩另一端，剩下的就是公共边。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,edcnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> A,B;</span><br><span class="line">ll dist_AB,flen_A[N],flen_B[N],lins,length[N];</span><br><span class="line"><span class="type">int</span> fir[N],depth[N],f[N][<span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> line[N],cnt;</span><br><span class="line"><span class="type">bool</span> bj;</span><br><span class="line"><span class="type">bool</span> vis[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; point;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt,val;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    e[edcnt].val=w;</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    depth[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(depth[x]&lt;depth[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">23</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(depth[f[x][i]]&gt;=depth[y]) x=f[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">23</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(f[x][i]!=f[y][i])</span><br><span class="line">            x=f[x][i],y=f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dist_1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> depth[x]+depth[y]<span class="number">-2</span>*depth[<span class="built_in">lca</span>(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dist_2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length[x]+length[y]<span class="number">-2</span>*length[<span class="built_in">lca</span>(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,ll sum,<span class="type">int</span> first)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;lins&amp;&amp;first&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        lins=sum;</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="number">0</span>) A=u;</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="number">1</span>) B=u,dist_AB=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            depth[v]=depth[u]<span class="number">+1</span>;</span><br><span class="line">            length[v]=length[u]+e[i].val;</span><br><span class="line">            f[v][<span class="number">0</span>]=u;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">23</span>;i++)</span><br><span class="line">                f[v][i]=f[f[v][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u,sum+e[i].val,first);</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="number">3</span>&amp;&amp;vis[i]==<span class="literal">false</span>) flen_A[u]=<span class="built_in">max</span>(flen_A[u],flen_A[v]+e[i].val);</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="number">4</span>&amp;&amp;vis[i]==<span class="literal">false</span>) flen_B[u]=<span class="built_in">max</span>(flen_B[u],flen_B[v]+e[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_again</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==B)</span><br><span class="line">    &#123;</span><br><span class="line">        point.<span class="built_in">emplace_back</span>(u);</span><br><span class="line">        bj=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs_again</span>(v,u);</span><br><span class="line">        <span class="keyword">if</span>(bj)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i]=vis[i^<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">            point.<span class="built_in">emplace_back</span>(u);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(u,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//A</span></span><br><span class="line">    lins=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(A,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//B</span></span><br><span class="line">    <span class="built_in">dfs_again</span>(A,<span class="number">-1</span>);<span class="comment">//路径</span></span><br><span class="line">    <span class="built_in">dfs</span>(A,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//flenA</span></span><br><span class="line">    <span class="built_in">dfs</span>(B,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">4</span>);<span class="comment">//flenB</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;A&lt;&lt;endl&lt;&lt;B&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">int</span> ans1=<span class="built_in">dist_1</span>(A,B);</span><br><span class="line">    <span class="comment">// printf(&quot;ans[1]=%d\n&quot;,ans1);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:point)</span><br><span class="line">        line[++cnt]=i;<span class="comment">//,printf(&quot;%d\n&quot;,i)</span></span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">    <span class="comment">//     printf(&quot;flen_A[%d]=%d,flen_B[%d]=%d\n&quot;,i,flen_A[i],i,flen_B[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;,cnt);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dist_2</span>(line[i],A)==flen_B[line[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            ans1-=<span class="built_in">dist_1</span>(A,line[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=cnt;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dist_2</span>(line[j],B)==flen_A[line[j]])</span><br><span class="line">        &#123;</span><br><span class="line">            ans1-=<span class="built_in">dist_1</span>(B,line[j]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n%d&quot;</span>,dist_AB,ans1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="基环树"><a href="#基环树" class="headerlink" title="基环树"></a>基环树</h2><h3 id="基础：找环"><a href="#基础：找环" class="headerlink" title="基础：找环"></a>基础：找环</h3><p><a class="link"   href="https://www.luogu.com.cn/problem/P8655" >P8655<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n,edcnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">bool</span> bj;</span><br><span class="line"><span class="type">int</span> st;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(vis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                mp.<span class="built_in">push_back</span>(v);</span><br><span class="line">                st=v;</span><br><span class="line">                bj=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">            <span class="keyword">if</span>(bj)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(v==st)</span><br><span class="line">                &#123;</span><br><span class="line">                    st=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(st)</span><br><span class="line">                &#123;</span><br><span class="line">                    mp.<span class="built_in">push_back</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[v]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:mp)</span><br><span class="line">        ans[++cnt]=i;</span><br><span class="line">    <span class="built_in">sort</span>(ans<span class="number">+1</span>,ans+cnt<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="P2607骑士"><a href="#P2607骑士" class="headerlink" title="P2607骑士"></a><a class="link"   href="https://www.luogu.com.cn/problem/P2607" >P2607骑士<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>首先先找环把这个环的两个端点和连接两个端点的边找出，在树形DP的时候注意两个端点不能同时选即可，由于是环，所以要对两个端点分别进行DP。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,edcnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> A,B,E;</span><br><span class="line">ll ans;</span><br><span class="line">ll f[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> battleEffectiveness[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(vis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                A=u;</span><br><span class="line">                B=v;</span><br><span class="line">                E=i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">Find</span>(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    f[u][<span class="number">1</span>]=battleEffectiveness[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa&amp;&amp;i!=E&amp;&amp;(i^<span class="number">1</span>)!=E)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="built_in">dp</span>(v,u);</span><br><span class="line">            f[u][<span class="number">0</span>]+=<span class="built_in">max</span>(f[v][<span class="number">0</span>],f[v][<span class="number">1</span>]);</span><br><span class="line">            f[u][<span class="number">1</span>]+=f[v][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> hate;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;battleEffectiveness[i],&amp;hate);</span><br><span class="line">        <span class="built_in">add</span>(i,hate);</span><br><span class="line">        <span class="built_in">add</span>(hate,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">Find</span>(i,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dp</span>(A,<span class="number">-1</span>);</span><br><span class="line">        ll temp=f[A][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">dp</span>(B,<span class="number">-1</span>);</span><br><span class="line">        temp=<span class="built_in">max</span>(temp,f[B][<span class="number">0</span>]);</span><br><span class="line">        ans+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h2><h3 id="AcWing247"><a href="#AcWing247" class="headerlink" title="AcWing247"></a>AcWing247</h3><p>将横坐标从小到大排序，而纵坐标由于是实数所以需要对它的下标进行离散化，线段树的一个节点代表一个区间，n个数那么就有$n-1$个区间也就是$n-1$个节点，所以建树是从$1\sim{siz-1}$，也就是$0\sim{siz-2}$，查询和修改时注意右端点要加一。</p>
<p>面积就按x轴从左往右扫描线，每块面积相加即可。</p>
<p>$cnt$代表当前被几块矩形覆盖，$len$代表当前被覆盖的长度。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x,y1,y2;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> segment &amp;a)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">double</span> len;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">3</span>];</span><br><span class="line">vector&lt;<span class="type">double</span>&gt; ys; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">double</span> y)</span><span class="comment">//查找离散化后的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>(),y)-ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].cnt)</span><br><span class="line">        tr[u].len=(ys[tr[u].r<span class="number">+1</span>]-ys[tr[u].l]);<span class="comment">//节点对应区间，所以右端点下标要加一</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l!=tr[u].r)<span class="comment">//不是叶子节点再用儿子更新</span></span><br><span class="line">        tr[u].len=tr[u&lt;&lt;<span class="number">1</span>].len+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l=l,tr[u].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].len=<span class="number">0</span>,tr[u].cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) </span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].cnt+=v;</span><br><span class="line">        <span class="built_in">pushup</span>(u);<span class="comment">//算一下要不要更新</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,v);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,v);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        ys.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> x1,x2,y1,y2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            seg[j++]=&#123;x1,y1,y2,<span class="number">1</span>&#125;;</span><br><span class="line">            seg[j++]=&#123;x2,y1,y2,<span class="number">-1</span>&#125;;</span><br><span class="line">            ys.<span class="built_in">push_back</span>(y1),ys.<span class="built_in">push_back</span>(y2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>());</span><br><span class="line">        ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>()),ys.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(seg,seg+n*<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,(<span class="type">int</span>)ys.<span class="built_in">size</span>()<span class="number">-2</span>);<span class="comment">//存的是区间</span></span><br><span class="line">        <span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) res+=tr[<span class="number">1</span>].len*(seg[i].x-seg[i<span class="number">-1</span>].x);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="built_in">find</span>(seg[i].y1),<span class="built_in">find</span>(seg[i].y2)<span class="number">-1</span>,seg[i].k);<span class="comment">//因为存的是区间而不是点，所以右端点要减一，因为一号节点代表的是1~2，那么l~r对应的节点就是l~r-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\n&quot;</span>,t++);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total explored area: %.2lf\n\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P5490扫描线"><a href="#P5490扫描线" class="headerlink" title="P5490扫描线"></a><a class="link"   href="https://www.luogu.com.cn/problem/P5490" >P5490扫描线<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y1,y2,k;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> segment &amp;a)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> len,cnt;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">3</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; mem;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(mem.<span class="built_in">begin</span>(),mem.<span class="built_in">end</span>(),x)-mem.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l=l,tr[u].r=r;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==tr[u].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].len=tr[u].cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].cnt) tr[u].len=mem[tr[u].r<span class="number">+1</span>]-mem[tr[u].l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l!=tr[u].r) tr[u].len=tr[u&lt;&lt;<span class="number">1</span>].len+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].cnt+=v;</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,v);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,v);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        seg[j++]=&#123;x1,y1,y2,<span class="number">1</span>&#125;;</span><br><span class="line">        seg[j++]=&#123;x2,y1,y2,<span class="number">-1</span>&#125;;</span><br><span class="line">        mem.<span class="built_in">push_back</span>(y1),mem.<span class="built_in">push_back</span>(y2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,mem.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">sort</span>(mem.<span class="built_in">begin</span>(),mem.<span class="built_in">end</span>());</span><br><span class="line">    mem.<span class="built_in">erase</span>(<span class="built_in">unique</span>(mem.<span class="built_in">begin</span>(),mem.<span class="built_in">end</span>()),mem.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(seg,seg+n*<span class="number">2</span>);</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>) res+=<span class="number">1ll</span>*tr[<span class="number">1</span>].len*(seg[i].x-seg[i<span class="number">-1</span>].x);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,<span class="built_in">find</span>(seg[i].y1),<span class="built_in">find</span>(seg[i].y2)<span class="number">-1</span>,seg[i].k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="P1471"><a href="#P1471" class="headerlink" title="P1471"></a>P1471</h2><p>要求<strong>方差</strong>，我们需要维护的信息有 <strong>区间和</strong>，<strong>区间平方和</strong>。</p>
<p>那么区间修改怎么下放标记呢？</p>
<p>通过简单的公式推导，我们可以得出：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202308092122395.webp"
                      alt="image.png"
                ></p>
<p>那么这样下放标记就很简单了。</p>
<p>值得注意的是，要<strong>先更新区间平方和</strong>，因为这里用到了更新之前的区间和。</p>
<p>方差嘛就很好求了：</p>
<p>$$<br>s^2&#x3D;\sum_{i&#x3D;l}^{r}{a_i}^2-\overline{a}^2<br>$$</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">double</span> a,b,add;<span class="comment">//区间和，区间平方和，懒标记</span></span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">double</span> a[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].a=tr[u&lt;&lt;<span class="number">1</span>].a+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].a;</span><br><span class="line">    tr[u].b=tr[u&lt;&lt;<span class="number">1</span>].b+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].add)</span><br><span class="line">    &#123;</span><br><span class="line">        node &amp;t=tr[u],&amp;l=tr[u&lt;&lt;<span class="number">1</span>],&amp;r=tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">        l.b+=<span class="number">2</span>*t.add*l.a+(l.r-l.l<span class="number">+1</span>)*t.add*t.add;<span class="comment">//注意修改顺序，修改b值用的是原来的a</span></span><br><span class="line">        r.b+=<span class="number">2</span>*t.add*r.a+(r.r-r.l<span class="number">+1</span>)*t.add*t.add;</span><br><span class="line">        r.a+=(r.r-r.l<span class="number">+1</span>)*t.add;</span><br><span class="line">        l.a+=(l.r-l.l<span class="number">+1</span>)*t.add;</span><br><span class="line">        r.add+=t.add;</span><br><span class="line">        l.add+=t.add;</span><br><span class="line">        t.add=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l=l,tr[u].r=r,tr[u].add=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].a=a[r];</span><br><span class="line">        tr[u].b=a[r]*a[r];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].add+=x;</span><br><span class="line">        tr[u].b+=(tr[u].r-tr[u].l<span class="number">+1</span>)*x*x<span class="number">+2</span>*x*tr[u].a;<span class="comment">//注意顺序</span></span><br><span class="line">        tr[u].a+=(tr[u].r-tr[u].l<span class="number">+1</span>)*x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,x);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,x);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">query_0</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//区间和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].a;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">query_0</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans+=<span class="built_in">query_0</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">query_1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//平方和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].b;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">query_1</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans+=<span class="built_in">query_1</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> k;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;k);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>,<span class="built_in">query_0</span>(<span class="number">1</span>,l,r)/(r-l<span class="number">+1</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>,<span class="built_in">query_1</span>(<span class="number">1</span>,l,r)/(r-l<span class="number">+1</span>)-(<span class="built_in">query_0</span>(<span class="number">1</span>,l,r)/(r-l<span class="number">+1</span>))*(<span class="built_in">query_0</span>(<span class="number">1</span>,l,r)/(r-l<span class="number">+1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="P1908"><a href="#P1908" class="headerlink" title="P1908"></a>P1908</h2><blockquote>
<p>经典的逆序对问题。</p>
</blockquote>
<p>将数字看作树状数组的下标，由于数字的值域可能会很大，因此要先进行离散化。</p>
<p>假如是正序，每次把对应数字下标的元素加一，那么当前已经处理的数字的个数减去当前数字的下标的前缀和即为以该数字为较小数的逆序对的个数。</p>
<p>因为减去当前数字下标的前缀和即为减去所有小于这个数的个数，而已经在之前出现的小于等于该数的数显然不能与该数组成逆序对，所以该点对答案的贡献。</p>
<p>假如是倒序，那么就是当前数字前一个数字的前缀和即为对答案的贡献。这很显然，因为是倒序，所以出现过就相当于在当前元素的后面，也就是产生了逆序对，数字要减一是因为两个相同的数字组成不了逆序对。</p>
<p>正序代码如下：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> tr[N],rk[N],n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num,val;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(point x,point y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.val==y.val) <span class="keyword">return</span> x.num&lt;y.num;</span><br><span class="line">    <span class="keyword">return</span> x.val&lt;y.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        tr[i]+=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        sum+=tr[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i].val);</span><br><span class="line">        a[i].num=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) rk[a[i].num]=i;<span class="comment">//离散化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(rk[i],<span class="number">1</span>);</span><br><span class="line">        ans+=i-<span class="built_in">query</span>(rk[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="随机化"><a href="#随机化" class="headerlink" title="随机化"></a>随机化</h1><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="P8819星战"><a href="#P8819星战" class="headerlink" title="P8819星战"></a><a class="link"   href="https://www.luogu.com.cn/problem/solution/P8819" >P8819星战<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll r[N],w[N],a[N];</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line">ll sum;</span><br><span class="line">ll tot;</span><br><span class="line"><span class="function">mt19937 <span class="title">rd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        w[i]=<span class="built_in">rd</span>()%mod,sum+=<span class="number">1ll</span>*w[i],sum%=mod;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        r[v]+=w[u];</span><br><span class="line">        a[v]=r[v];</span><br><span class="line">        tot+=w[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            r[v]-=w[u];</span><br><span class="line">            tot-=w[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">            tot-=r[v];</span><br><span class="line">            r[v]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            r[v]+=w[u];</span><br><span class="line">            tot+=w[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">            tot+=a[v]-r[v];</span><br><span class="line">            r[v]=a[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tot%mod==sum) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><h3 id="P4391"><a href="#P4391" class="headerlink" title="P4391"></a><a class="link"   href="https://www.luogu.com.cn/problem/P4391" >P4391<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> pmt[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">char</span> a[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> ans,n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;a[i]!=a[j]) j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[j]) j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n-pmt[n<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>求一个 Border 。</p>
<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h3 id="P1775石子合并"><a href="#P1775石子合并" class="headerlink" title="P1775石子合并"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1775" >P1775石子合并<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+a[i];<span class="comment">//前缀和</span></span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f3f3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		f[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)<span class="comment">//当前处理长度为len的区间 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=n;r++,l++)<span class="comment">//长度为r-l+1 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">				f[l][r]=<span class="built_in">min</span>(sum[r]-sum[l<span class="number">-1</span>]+f[l][k]+f[k<span class="number">+1</span>][r],f[l][r]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P1880石子环合并"><a href="#P1880石子环合并" class="headerlink" title="P1880石子环合并"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1880" >P1880石子环合并<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>相较于链，复制出一份首尾相接即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">+1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">		a[i]=a[i-n]; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">		f[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++) </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=<span class="number">2</span>*n;r++,l++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">				f[l][r]=<span class="built_in">min</span>(sum[r]-sum[l<span class="number">-1</span>]+f[l][k]+f[k<span class="number">+1</span>][r],f[l][r]);</span><br><span class="line">	<span class="type">int</span> ans=f[<span class="number">1</span>][n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=n;r&lt;=<span class="number">2</span>*n;l++,r++)</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,f[l][r]);</span><br><span class="line">	<span class="type">int</span> maxn,minn;</span><br><span class="line">	minn=ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=<span class="number">2</span>*n;r++,l++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">				f[l][r]=<span class="built_in">max</span>(sum[r]-sum[l<span class="number">-1</span>]+f[l][k]+f[k<span class="number">+1</span>][r],f[l][r]);</span><br><span class="line">	ans=f[<span class="number">1</span>][n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=n;r&lt;=<span class="number">2</span>*n;l++,r++)</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,f[l][r]);</span><br><span class="line">	maxn=ans;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>,minn,maxn);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P1063能量项链"><a href="#P1063能量项链" class="headerlink" title="P1063能量项链"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1063" >P1063能量项链<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>与上道题类似，注意转移的量和珠子贡献的产生。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">220</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">+1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">        a[i]=a[i-n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n*<span class="number">2</span>;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=n*<span class="number">2</span>;l++,r++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                f[l][r]=<span class="built_in">max</span>(f[l][r],f[l][k]+f[k<span class="number">+1</span>][r]+a[l]*a[k<span class="number">+1</span>]*a[r<span class="number">+1</span>]);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P1220关路灯"><a href="#P1220关路灯" class="headerlink" title="P1220关路灯"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1220" >P1220关路灯<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>注意初始位置不需要花时间，所以一开始不耗电，注意前缀和处理。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="type">int</span> a[N],v[N];</span><br><span class="line"><span class="type">int</span> f[N][N][<span class="number">2</span>];<span class="comment">//i~j的路灯已经熄灭时的最小总功耗，此时老张站在0左边，1右边</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i],&amp;v[i]);</span><br><span class="line">        v[i]+=v[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[c][c][<span class="number">0</span>]=f[c][c][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=n;l++,r++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[l][r][<span class="number">0</span>]=<span class="built_in">min</span>(f[l<span class="number">+1</span>][r][<span class="number">0</span>]+(a[l<span class="number">+1</span>]-a[l])*(v[l]+v[n]-v[r]),f[l<span class="number">+1</span>][r][<span class="number">1</span>]+(a[r]-a[l])*(v[l]+v[n]-v[r]));</span><br><span class="line">            f[l][r][<span class="number">1</span>]=<span class="built_in">min</span>(f[l][r<span class="number">-1</span>][<span class="number">1</span>]+(a[r]-a[r<span class="number">-1</span>])*(v[l<span class="number">-1</span>]+v[n]-v[r<span class="number">-1</span>]),f[l][r<span class="number">-1</span>][<span class="number">0</span>]+(a[r]-a[l])*(v[l<span class="number">-1</span>]+v[n]-v[r<span class="number">-1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">min</span>(f[<span class="number">1</span>][n][<span class="number">0</span>],f[<span class="number">1</span>][n][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P2858卖零食"><a href="#P2858卖零食" class="headerlink" title="P2858卖零食"></a><a class="link"   href="https://www.luogu.com.cn/problem/P2858" >P2858卖零食<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>$l\sim{r}$ 可以由 $l+1\sim{r}$ 和 $l\sim{r-1}$ 转移而来。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2005</span>;</span><br><span class="line"><span class="type">int</span> a[N],f[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][i]=a[i]*n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=n;l++,r++)</span><br><span class="line">            f[l][r]=<span class="built_in">max</span>(f[l][r<span class="number">-1</span>]+a[r]*(n-len<span class="number">+1</span>),f[l<span class="number">+1</span>][r]+a[l]*(n-len<span class="number">+1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P3146-248G"><a href="#P3146-248G" class="headerlink" title="P3146 248G"></a><a class="link"   href="https://www.luogu.com.cn/problem/P3146" >P3146 248G<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>原来最大为 $40$ ，最多合并 $logn$ 次，所以最大为 $58$。</p>
<p>注意处理为左闭右开区间方便合并，不然左右端点共用没法处理。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> a,n,ans;</span><br><span class="line"><span class="type">int</span> f[<span class="number">60</span>][N];<span class="comment">//i为能合并出来的最大值，j为此时的左端点，值为此时的右端点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a),f[a][i]=i<span class="number">+1</span>;<span class="comment">//左闭右开区间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">58</span>;i++)<span class="comment">//40+18</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//枚举左端点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[i][j])</span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][f[i<span class="number">-1</span>][j]];</span><br><span class="line">            <span class="keyword">if</span>(f[i][j]) ans=i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P3147"><a href="#P3147" class="headerlink" title="P3147"></a><a class="link"   href="https://www.luogu.com.cn/problem/P3147" >P3147<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>同上，注意请使用左闭右开区间，为此还发了篇讨论区。</p>
<p>通过以上两题，我们可以总结出两条规律：</p>
<ul>
<li>合并区间时请使用左闭右开区间。</li>
<li>设计状态时，以值域较小的变量作为数组下标，就像本题并没有选择传统的 $l,r$ 写法。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> a,n,ans;</span><br><span class="line"><span class="type">int</span> f[<span class="number">60</span>][N];<span class="comment">//i为能合并出来的最大值，j为此时的左端点，值为此时的右端点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a),f[a][i]=i<span class="number">+1</span>;<span class="comment">//左闭右开区间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">58</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//枚举左端点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[i][j])</span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][f[i<span class="number">-1</span>][j]];</span><br><span class="line">            <span class="keyword">if</span>(f[i][j]) ans=i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P3205合唱队"><a href="#P3205合唱队" class="headerlink" title="P3205合唱队"></a><a class="link"   href="https://www.luogu.com.cn/problem/P3205" >P3205合唱队<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>见注释。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"><span class="type">int</span> f[N][N][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//f[i][j][0]表示[i,j]且最后一个人从左边进队的方案数</span></span><br><span class="line"><span class="comment">//f[i][j][1]表示[i,j]且最后一个人从右边进队的方案数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),f[i][i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//左端点等于右端点时，方案只能有一个，不然会转移两次，所以就默认一个方向</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=n;l++,r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[l]&lt;a[l<span class="number">+1</span>]) f[l][r][<span class="number">0</span>]=(f[l][r][<span class="number">0</span>]+f[l<span class="number">+1</span>][r][<span class="number">0</span>])%mod;</span><br><span class="line">            <span class="keyword">if</span>(a[l]&lt;a[r]) f[l][r][<span class="number">0</span>]=(f[l][r][<span class="number">0</span>]+f[l<span class="number">+1</span>][r][<span class="number">1</span>])%mod;</span><br><span class="line">            <span class="keyword">if</span>(a[r]&gt;a[l]) f[l][r][<span class="number">1</span>]=(f[l][r][<span class="number">1</span>]+f[l][r<span class="number">-1</span>][<span class="number">0</span>])%mod;</span><br><span class="line">            <span class="keyword">if</span>(a[r]&gt;a[r<span class="number">-1</span>]) f[l][r][<span class="number">1</span>]=(f[l][r][<span class="number">1</span>]+f[l][r<span class="number">-1</span>][<span class="number">1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(f[<span class="number">1</span>][n][<span class="number">0</span>]+f[<span class="number">1</span>][n][<span class="number">1</span>])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P4170涂色"><a href="#P4170涂色" class="headerlink" title="P4170涂色"></a><a class="link"   href="https://www.luogu.com.cn/problem/P4170" >P4170涂色<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>首先初始化一个区间只需要涂一次。</p>
<p>枚举区间，假如区间左右端点的颜色相同，那么就可以在之前一起涂上，所以就可以从 $l+1\sim{r}$ 和$l\sim{r-1}$ 中无代价转移而来。</p>
<p>假如不同的话，那就需要枚举分界点。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) f[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=len<span class="number">-1</span>;r&lt;n;l++,r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l]==s[r])</span><br><span class="line">            &#123;</span><br><span class="line">                f[l][r]=<span class="built_in">min</span>(f[l][r],<span class="built_in">min</span>(f[l<span class="number">+1</span>][r],f[l][r<span class="number">-1</span>]));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                f[l][r]=<span class="built_in">min</span>(f[l][r],f[l][k]+f[k<span class="number">+1</span>][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">0</span>][n<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P4290玩具取名"><a href="#P4290玩具取名" class="headerlink" title="P4290玩具取名"></a><a class="link"   href="https://www.luogu.com.cn/problem/P4290" >P4290玩具取名<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>状态定义为区间 $l\sim{r}$ 是否可以被 $k$ 取代，其中 $k$ 将字符转为数字。</p>
<p>$p$ 可以被 $f_1,f_2$ 取代，若 $f_1$ 可以取代左半部分区间， $f_2$ 可以取代右半部分区间，那么 $p$ 就可以取代整个区间，这就是转移。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">205</span>;</span><br><span class="line"><span class="type">bool</span> f[N][N][<span class="number">5</span>];</span><br><span class="line"><span class="type">char</span> a[<span class="number">10</span>];</span><br><span class="line">vector&lt;string&gt; s[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> w,o,n,g;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ch</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;I&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;N&#x27;</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;G&#x27;</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">string name;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;w,&amp;o,&amp;n,&amp;g);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=w;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">        s[<span class="number">1</span>].<span class="built_in">emplace_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=o;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">        s[<span class="number">2</span>].<span class="built_in">emplace_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">        s[<span class="number">3</span>].<span class="built_in">emplace_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=g;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">        s[<span class="number">4</span>].<span class="built_in">emplace_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;name;</span><br><span class="line">    <span class="type">int</span> length=name.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        f[i][i][<span class="built_in">ch</span>(name[i])]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=length;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=i<span class="number">-1</span>;r&lt;length;l++,r++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">1</span>;p&lt;=<span class="number">4</span>;p++)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:s[p])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">char</span> f1=v[<span class="number">0</span>],f2=v[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(f[l][k][<span class="built_in">ch</span>(f1)]&amp;&amp;f[k<span class="number">+1</span>][r][<span class="built_in">ch</span>(f2)])</span><br><span class="line">                            f[l][r][p]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">    <span class="type">bool</span> bj=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[<span class="number">0</span>][length<span class="number">-1</span>][<span class="number">1</span>]) bj=<span class="literal">true</span>,<span class="built_in">printf</span>(<span class="string">&quot;W&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(f[<span class="number">0</span>][length<span class="number">-1</span>][<span class="number">2</span>]) bj=<span class="literal">true</span>,<span class="built_in">printf</span>(<span class="string">&quot;I&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(f[<span class="number">0</span>][length<span class="number">-1</span>][<span class="number">3</span>]) bj=<span class="literal">true</span>,<span class="built_in">printf</span>(<span class="string">&quot;N&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(f[<span class="number">0</span>][length<span class="number">-1</span>][<span class="number">4</span>]) bj=<span class="literal">true</span>,<span class="built_in">printf</span>(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!bj) <span class="built_in">printf</span>(<span class="string">&quot;The name is wrong!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P4342Polygon"><a href="#P4342Polygon" class="headerlink" title="P4342Polygon"></a><a href="">P4342Polygon</a></h3><p>首先断环为链，考虑转移。</p>
<p>如果是加法，那直接取max肯定没问题，但是有乘法，并且有负数，就要考虑负负得正的情况，而且最大值乘以一个负数后便不再是最大值，所以我们还要维护一个区间答案最小值。</p>
<p>转移的时候，左右两半部分都有可能是正或者负，所以四种情况取一个最大值。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">160</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">char</span> cl[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">ll f[N][N],g[N][N];<span class="comment">//区间内的最大结果,最小结果</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot; %c %d&quot;</span>,&amp;cl[i],&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">+1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">        cl[i]=cl[i-n],a[i]=a[i-n];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-127</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">127</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)</span><br><span class="line">        f[i][i]=g[i][i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=len;r&lt;=n*<span class="number">2</span>;l++,r++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cl[k<span class="number">+1</span>]==<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[l][r]=<span class="built_in">max</span>(f[l][r],f[l][k]+f[k<span class="number">+1</span>][r]);</span><br><span class="line">                    g[l][r]=<span class="built_in">min</span>(g[l][r],g[l][k]+g[k<span class="number">+1</span>][r]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cl[k<span class="number">+1</span>]==<span class="string">&#x27;x&#x27;</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    f[l][r]=<span class="built_in">max</span>(f[l][r],<span class="built_in">max</span>(f[l][k]*f[k<span class="number">+1</span>][r],<span class="built_in">max</span>(g[l][k]*g[k<span class="number">+1</span>][r],<span class="built_in">max</span>(f[l][k]*g[k<span class="number">+1</span>][r],g[l][k]*f[k<span class="number">+1</span>][r]))));</span><br><span class="line">                    g[l][r]=<span class="built_in">min</span>(g[l][r],<span class="built_in">min</span>(f[l][k]*f[k<span class="number">+1</span>][r],<span class="built_in">min</span>(g[l][k]*g[k<span class="number">+1</span>][r],<span class="built_in">min</span>(f[l][k]*g[k<span class="number">+1</span>][r],g[l][k]*f[k<span class="number">+1</span>][r]))));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// printf(&quot;f[%d][%d]=%lld\n&quot;,l,r,f[l][r]);</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">+1</span>;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(f[i][i+n<span class="number">-1</span>]==ans) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P6701"><a href="#P6701" class="headerlink" title="P6701"></a><a class="link"   href="https://www.luogu.com.cn/problem/P6701" >P6701<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>分裂太复杂不太好想，不如反过来考虑，如何把给定的字符串合成为长度尽量小的 <code>S</code>，$f_{i,j}$ 代表区间 $[i,j]$ 最少用几个 S 表示，$h_{i,j}$ 表示区间 $[i,j]$ 可以用哪个字符表示，这个可以用状态压缩的形式表示。假如一个区间可以被 S 表示，那么它的答案就是1，最后判断一下整个区间是否被更新过即可。</p>
<p>之所以要状态压缩而不是直接赋值编号的原因是某个区间会被多个字符有可能取代，而它们只需要满足一个就可以转移。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">120</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> mp[N][N];</span><br><span class="line"><span class="type">int</span> h[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">        mp[a[<span class="number">1</span>]-<span class="string">&#x27;A&#x27;</span><span class="number">+1</span>][a[<span class="number">2</span>]-<span class="string">&#x27;A&#x27;</span><span class="number">+1</span>]|=(<span class="number">1</span>&lt;&lt;(a[<span class="number">0</span>]-<span class="string">&#x27;A&#x27;</span><span class="number">+1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">        <span class="type">int</span> len=<span class="built_in">strlen</span>(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]==<span class="string">&#x27;S&#x27;</span>) f[j<span class="number">+1</span>][j<span class="number">+1</span>]=<span class="number">1</span>;</span><br><span class="line">            h[j<span class="number">+1</span>][j<span class="number">+1</span>]|=(<span class="number">1</span>&lt;&lt;(a[j]-<span class="string">&#x27;A&#x27;</span><span class="number">+1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=j;r&lt;=len;l++,r++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[l][r]=<span class="built_in">min</span>(f[l][r],f[l][k]+f[k<span class="number">+1</span>][r]);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=<span class="number">26</span>;x++)</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=<span class="number">26</span>;y++)</span><br><span class="line">                            <span class="keyword">if</span>((h[l][k]&amp;(<span class="number">1</span>&lt;&lt;x))&amp;&amp;(h[k<span class="number">+1</span>][r]&amp;(<span class="number">1</span>&lt;&lt;y)))</span><br><span class="line">                                h[l][r]|=mp[x][y];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(h[l][r]&amp;(<span class="number">1</span>&lt;&lt;(<span class="string">&#x27;S&#x27;</span>-<span class="string">&#x27;A&#x27;</span><span class="number">+1</span>))) f[l][r]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">1</span>][len]&gt;=<span class="number">0x3f3f3f3f</span>) <span class="built_in">printf</span>(<span class="string">&quot;NIE\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[<span class="number">1</span>][len]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P2466Sue的小球"><a href="#P2466Sue的小球" class="headerlink" title="P2466Sue的小球"></a><a class="link"   href="https://www.luogu.com.cn/problem/P2466" >P2466Sue的小球<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>这道题相当于是关路灯的升级版。需要先按照横坐标排个序，并且没有固定的起点。</p>
<p>我们可以利用关路灯的思路，求最小下降的总高度，用一开始的总高度减去就可以了。</p>
<p>而本题中一开始不一定在某个彩蛋下面，关路灯是从某个确定的路灯下开始的，所以我们要预处理出它一开始到每个彩蛋的花费（其实预处理出最小的就可以了，但是为了方便不如一起预处理了）。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1005</span>;</span><br><span class="line">ll f[N][N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> x_0,n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">egg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y,v;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> egg &amp;a)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;eg[N];</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">double</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x_0);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;eg[i].x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;eg[i].y),ans+=<span class="number">1.0</span>*eg[i].y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;eg[i].v);</span><br><span class="line">    <span class="built_in">sort</span>(eg<span class="number">+1</span>,eg<span class="number">+1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]=sum[i<span class="number">-1</span>]+eg[i].v;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        f[i][i][<span class="number">0</span>]=f[i][i][<span class="number">1</span>]=<span class="number">1ll</span>*sum[n]*<span class="built_in">abs</span>(x_0-eg[i].x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=i;r&lt;=n;l++,r++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[l][r][<span class="number">0</span>]=<span class="built_in">min</span>(f[l<span class="number">+1</span>][r][<span class="number">0</span>]<span class="number">+1ll</span>*(sum[l]+sum[n]-sum[r])*(eg[l<span class="number">+1</span>].x-eg[l].x),f[l<span class="number">+1</span>][r][<span class="number">1</span>]<span class="number">+1ll</span>*(sum[l]+sum[n]-sum[r])*(eg[r].x-eg[l].x));</span><br><span class="line">            f[l][r][<span class="number">1</span>]=<span class="built_in">min</span>(f[l][r<span class="number">-1</span>][<span class="number">1</span>]<span class="number">+1ll</span>*(sum[l<span class="number">-1</span>]+sum[n]-sum[r<span class="number">-1</span>])*(eg[r].x-eg[r<span class="number">-1</span>].x),f[l][r<span class="number">-1</span>][<span class="number">0</span>]<span class="number">+1ll</span>*(sum[l<span class="number">-1</span>]+sum[n]-sum[r<span class="number">-1</span>])*(eg[r].x-eg[l].x));</span><br><span class="line">        &#125;</span><br><span class="line">    ans-=(<span class="type">double</span>)<span class="built_in">min</span>(f[<span class="number">1</span>][n][<span class="number">0</span>],f[<span class="number">1</span>][n][<span class="number">1</span>]);</span><br><span class="line">    ans/=<span class="number">1000.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P1868饥饿的奶牛"><a href="#P1868饥饿的奶牛" class="headerlink" title="P1868饥饿的奶牛"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1868" >P1868饥饿的奶牛<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>对每个右端点记录它对应的左端点，从小到大枚举右端点，区间扩大了那么肯定至少能继承之前的区间，假如它对应的某个左端点之前也有贡献，那么就可以新加入这个区间的贡献。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e6</span><span class="number">+10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[N];</span><br><span class="line"><span class="type">int</span> n,maxn;</span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//i之前的草块能获得的最大价值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[y].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">        maxn=<span class="built_in">max</span>(maxn,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="built_in">max</span>(f[i],f[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;j:a[i])</span><br><span class="line">            f[i]=<span class="built_in">max</span>(f[i],f[j<span class="number">-1</span>]+i-j<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[maxn]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P1280"><a href="#P1280" class="headerlink" title="P1280"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1280" >P1280<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>倒叙枚举，考虑后缀，如果当前有任务，那就拿当前所能获得的最大空闲时间与完成任务后得到的最大空闲时间取一个 max，如果当前空闲，那就可以多一分钟的空闲时间。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[N];</span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//从第i分钟开始最大的空暇时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[x].<span class="built_in">emplace_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].<span class="built_in">size</span>())<span class="comment">//当前有任务</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;j:a[i])</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[i+j]);</span><br><span class="line">        <span class="keyword">else</span> f[i]=f[i<span class="number">+1</span>]<span class="number">+1</span>;<span class="comment">//当前空闲</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h3 id="P1233木棍加工"><a href="#P1233木棍加工" class="headerlink" title="P1233木棍加工"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1233" >P1233木棍加工<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>求单调不降子序列的个数其实就是求最长上升子序列的长度，注意要对 $l$ 排序。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> n,ans=<span class="number">-1</span>,maxn=<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=u;i&lt;=maxn;i+=<span class="built_in">lowbit</span>(i)) f[i]=<span class="built_in">max</span>(f[i],v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edge &amp;x)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l!=x.l) <span class="keyword">return</span> l&gt;x.l;</span><br><span class="line">        <span class="keyword">return</span> w&gt;x.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;e[i].l,&amp;e[i].w),maxn=<span class="built_in">max</span>(maxn,e[i].w);</span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e<span class="number">+1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q=<span class="built_in">query</span>(e[i].w<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">update</span>(e[i].w,q<span class="number">+1</span>);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,q<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P3903导弹拦截"><a href="#P3903导弹拦截" class="headerlink" title="P3903导弹拦截"></a><a class="link"   href="https://www.luogu.com.cn/problem/P3903" >P3903导弹拦截<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>其实就是求拐点的数量，注意不能算开头。</p>
<p>绝妙的异或代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,p,q,bj,ans=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">        <span class="keyword">if</span>(p==q) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(bj^(q&lt;p))<span class="comment">//第二发要比第一发小，第三发要比第二发大</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans++,bj=q&lt;p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P2782友好城市"><a href="#P2782友好城市" class="headerlink" title="P2782友好城市"></a><a class="link"   href="https://www.luogu.com.cn/problem/P2782" >P2782友好城市<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>与木棍加工类似。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,ans=<span class="number">-1</span>,maxn=<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=u;i&lt;=maxn;i+=<span class="built_in">lowbit</span>(i)) f[i]=<span class="built_in">max</span>(f[i],v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edge &amp;x)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l&lt;x.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;e[i].l,&amp;e[i].w),maxn=<span class="built_in">max</span>(maxn,e[i].w);</span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e<span class="number">+1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q=<span class="built_in">query</span>(e[i].w<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">update</span>(e[i].w,q<span class="number">+1</span>);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,q<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P1095守望者的逃离"><a href="#P1095守望者的逃离" class="headerlink" title="P1095守望者的逃离"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1095" >P1095守望者的逃离<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>我们分别计算闪烁和跑步的距离，能闪烁是一定闪烁的，假如某时刻闪烁更优，只需要把跑步替换成闪烁即可，否则就只进行跑步，如果到了终点直接就退出。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> s1,s2;<span class="comment">//相同时间内跑步，闪烁所能跑的最远距离</span></span><br><span class="line"><span class="type">int</span> m,s,t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;m,&amp;s,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s1+=<span class="number">17</span>;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;=<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s2+=<span class="number">60</span>;</span><br><span class="line">            m-=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> m+=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(s2&gt;s1) s1=s2;<span class="comment">//能替换时就进行替换</span></span><br><span class="line">        <span class="keyword">if</span>(s1&gt;=s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n%d\n&quot;</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No\n%d\n&quot;</span>,s1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P2679"><a href="#P2679" class="headerlink" title="P2679"></a><a class="link"   href="https://www.luogu.com.cn/problem/P2679" >P2679<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>状态定义见注释，转移分情况讨论，注意滚动数组优化空间。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">char</span> a[N],b[<span class="number">220</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][<span class="number">220</span>][<span class="number">220</span>][<span class="number">2</span>];<span class="comment">//f[i][j][l][1/0]表示考虑了前i个a中的字符使用l个子串匹配了b串中的前j个字符且第i位选/不选的方案数</span></span><br><span class="line"><span class="comment">//第一维采用滚动数组优化</span></span><br><span class="line"><span class="type">bool</span> bj;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s\n%s&quot;</span>,a,b);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    bj=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++,bj=!bj)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=k;l++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i<span class="number">-1</span>]==b[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    f[bj][j][l][<span class="number">0</span>]=(f[!bj][j][l][<span class="number">0</span>]+f[!bj][j][l][<span class="number">1</span>])%mod;</span><br><span class="line">                    f[bj][j][l][<span class="number">1</span>]=(f[!bj][j<span class="number">-1</span>][l<span class="number">-1</span>][<span class="number">0</span>]+(f[!bj][j<span class="number">-1</span>][l<span class="number">-1</span>][<span class="number">1</span>]+f[!bj][j<span class="number">-1</span>][l][<span class="number">1</span>])%mod)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    f[bj][j][l][<span class="number">0</span>]=(f[!bj][j][l][<span class="number">0</span>]+f[!bj][j][l][<span class="number">1</span>])%mod;</span><br><span class="line">                    f[bj][j][l][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(f[!bj][m][k][<span class="number">0</span>]+f[!bj][m][k][<span class="number">1</span>])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P2051中国象棋"><a href="#P2051中国象棋" class="headerlink" title="P2051中国象棋"></a><a class="link"   href="https://www.luogu.com.cn/problem/P2051" >P2051中国象棋<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>定义 $f_{i,j,k}$ 为考虑完了前 $i$ 行，该行有 $j$ 个零个炮的列，有 $k$ 个一个炮的列，这种情况下的方案数。</p>
<p>首先中国象棋要使得每个炮互不攻击，每行每列的炮的数量不能超过两个，所以数量有三种状态，由于知道两个剩下一个就可以算出来，所以只需要记录两个。</p>
<p>考虑在下一行放零个炮还是一个炮还是两个炮，分别写出转移式子。</p>
<p>假如下一行不放炮，那么就直接继承。</p>
<p>假如下一行放一个炮，这个炮可能放在一个炮的列，也可能放在零个炮的列。</p>
<p>假如下一行放两个炮，那么有可能这两个炮都放在零个炮的列，有可能都放在一个炮的列，也有可能一个炮放在零个炮的列，一个放在一个炮的列，这里就需要预处理一下 2 的组合数了。</p>
<p>最后统计答案的时候，每种情况取一个 max。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">9999973</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> f[<span class="number">105</span>][<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">105</span>;i++)</span><br><span class="line">        c[i][<span class="number">2</span>]=i*(i<span class="number">-1</span>)/<span class="number">2</span>%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    f[<span class="number">0</span>][m][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=m-j;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i<span class="number">+1</span>][j][k]=(f[i<span class="number">+1</span>][j][k]+f[i][j][k])%mod;<span class="comment">//0</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=<span class="number">1</span>) f[i<span class="number">+1</span>][j<span class="number">-1</span>][k<span class="number">+1</span>]=(f[i<span class="number">+1</span>][j<span class="number">-1</span>][k<span class="number">+1</span>]+(<span class="number">1ll</span>*f[i][j][k]*j%mod))%mod;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;=<span class="number">1</span>) f[i<span class="number">+1</span>][j][k<span class="number">-1</span>]=(f[i<span class="number">+1</span>][j][k<span class="number">-1</span>]+(<span class="number">1ll</span>*f[i][j][k]*k%mod))%mod;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=<span class="number">1</span>) f[i<span class="number">+1</span>][j<span class="number">-1</span>][k]=(f[i<span class="number">+1</span>][j<span class="number">-1</span>][k]+(<span class="number">1ll</span>*f[i][j][k]*j*k%mod))%mod;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=<span class="number">2</span>) f[i<span class="number">+1</span>][j<span class="number">-2</span>][k<span class="number">+2</span>]=(f[i<span class="number">+1</span>][j<span class="number">-2</span>][k<span class="number">+2</span>]+(<span class="number">1ll</span>*f[i][j][k]*c[j][<span class="number">2</span>]%mod))%mod;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;=<span class="number">2</span>) f[i<span class="number">+1</span>][j][k<span class="number">-2</span>]=(f[i<span class="number">+1</span>][j][k<span class="number">-2</span>]+(<span class="number">1ll</span>*f[i][j][k]*c[k][<span class="number">2</span>]%mod))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m-i;j++)</span><br><span class="line">            ans=(ans+f[n][i][j])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P7074方格取数"><a href="#P7074方格取数" class="headerlink" title="P7074方格取数"></a><a class="link"   href="https://www.luogu.com.cn/problem/P7074" >P7074方格取数<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>由于本题不仅可以向下，还可以向上，所以不能像数字三角形那样进行转移。</p>
<p>因为不能走重复的路，所以我们可以再开一维，记录它是从上方转移而来还是从下方转移而来，因为假如它这步走了向下，那么它上一步如果也是纵向移动的话也一定是向下。</p>
<p>从左向右的转移还是正常进行，这时候不考虑上一步是从上方走来还是从下方走来。</p>
<p>对于向下走，正序枚举一遍，对于向上走，倒叙枚举一遍即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> number[N][N];</span><br><span class="line">ll f[N][N][<span class="number">2</span>];<span class="comment">//1代表从格子上方走来，0代表从格子的下方走来</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number[i][j]);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xc0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=number[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j][<span class="number">0</span>]=<span class="built_in">max</span>(f[i][j][<span class="number">0</span>],<span class="built_in">max</span>(f[i][j<span class="number">-1</span>][<span class="number">0</span>],f[i][j<span class="number">-1</span>][<span class="number">1</span>])+number[i][j]);</span><br><span class="line">                f[i][j][<span class="number">1</span>]=<span class="built_in">max</span>(f[i][j][<span class="number">1</span>],<span class="built_in">max</span>(f[i][j<span class="number">-1</span>][<span class="number">0</span>],f[i][j<span class="number">-1</span>][<span class="number">1</span>])+number[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">                f[i][j][<span class="number">1</span>]=<span class="built_in">max</span>(f[i][j][<span class="number">1</span>],f[i<span class="number">-1</span>][j][<span class="number">1</span>]+number[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">            f[i][j][<span class="number">0</span>]=<span class="built_in">max</span>(f[i][j][<span class="number">0</span>],f[i<span class="number">+1</span>][j][<span class="number">0</span>]+number[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">max</span>(f[n][m][<span class="number">1</span>],f[n][m][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="P4158-粉刷匠"><a href="#P4158-粉刷匠" class="headerlink" title="P4158 粉刷匠"></a><a class="link"   href="https://www.luogu.com.cn/problem/P4158" >P4158 粉刷匠<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>注释已述备矣。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t, ans;</span><br><span class="line"><span class="type">char</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="comment">// 前 i 条模板粉刷了 j 次 能正确粉刷的最大格子数</span></span><br><span class="line"><span class="type">int</span> f[<span class="number">55</span>][<span class="number">2505</span>];</span><br><span class="line"><span class="comment">// 第 i 条木板上粉刷了 j 次涂了前 k 个格子的情况下正确粉刷的最大格子数</span></span><br><span class="line"><span class="type">int</span> g[<span class="number">55</span>][<span class="number">2505</span>][<span class="number">55</span>];</span><br><span class="line"><span class="comment">// g[i][j][k] = max(g[i][j][k], g[i][j - 1][q] + max(sum[i][k] - sum[i][q], k - q - sum[i][k] + sum[i][q]));</span></span><br><span class="line"><span class="comment">// 第 i 条木板上前 j 个格子有多少蓝色格子</span></span><br><span class="line"><span class="type">int</span> sum[<span class="number">55</span>][<span class="number">2505</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="string">&#x27;1&#x27;</span>) sum[i][j + <span class="number">1</span>] = sum[i][j] + <span class="number">1</span>; <span class="comment">// 处理蓝色格子的前缀和</span></span><br><span class="line">            <span class="keyword">else</span> sum[i][j + <span class="number">1</span>] = sum[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; k++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> q = j - <span class="number">1</span>; q &lt; k; q++) <span class="comment">// 最少刷 j - 1 个格子 最多刷 k - 1 个格子 因为下一步还要刷 q ~ k</span></span><br><span class="line">                g[i][j][k] = <span class="built_in">max</span>(g[i][j][k], g[i][j - <span class="number">1</span>][q] + <span class="built_in">max</span>(sum[i][k] - sum[i][q], k - q - sum[i][k] + sum[i][q]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="built_in">min</span>(j, m); k++) <span class="comment">// 这次最多粉刷 j 次 但假如比这一条木板还多次由于不能重复刷 所以还要小于等于木板的长度</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k] + g[i][k][m]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;            </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="P3558-BAJ-Bytecomputer"><a href="#P3558-BAJ-Bytecomputer" class="headerlink" title="P3558 BAJ-Bytecomputer"></a><a class="link"   href="https://www.luogu.com.cn/problem/P3558" >P3558 BAJ-Bytecomputer<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>还不是很懂第一篇题解的做法，到时候懂了来补。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">3</span>]; <span class="comment">// 前 i 个数 以 0 - -1 1 - 0 2 - 1 结尾的操作数</span></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = f[<span class="number">2</span>] = INF;</span><br><span class="line">    f[a[<span class="number">1</span>] + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            f[<span class="number">1</span>] = INF; <span class="comment">// 不必转移</span></span><br><span class="line">            f[<span class="number">2</span>] += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            f[<span class="number">1</span>] = <span class="built_in">min</span>(f[<span class="number">0</span>], f[<span class="number">1</span>]);</span><br><span class="line">            f[<span class="number">0</span>]++;</span><br><span class="line">            f[<span class="number">2</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[<span class="number">2</span>] = <span class="built_in">min</span>(f[<span class="number">0</span>], <span class="built_in">min</span>(f[<span class="number">1</span>], f[<span class="number">2</span>]));</span><br><span class="line">            f[<span class="number">1</span>] = f[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            f[<span class="number">0</span>] += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">min</span>(f[<span class="number">0</span>], <span class="built_in">min</span>(f[<span class="number">1</span>], f[<span class="number">2</span>]));</span><br><span class="line">    <span class="keyword">if</span>(ans &lt; INF) cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;BRAK&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="P1855-榨取kkksc03"><a href="#P1855-榨取kkksc03" class="headerlink" title="P1855 榨取kkksc03"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1855" >P1855 榨取kkksc03<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>经典 0 &#x2F; 1 背包问题，不过有两种限制，都加入状态即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t;</span><br><span class="line"><span class="type">int</span> mm[<span class="number">101</span>], tt[<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;mm[i], &amp;tt[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= mm[i]; j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = t; k &gt;= tt[i]; k--)</span><br><span class="line">                f[j][k] = <span class="built_in">max</span>(f[j][k], f[j - mm[i]][k - tt[i]] + <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; f[m][t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="P5020-货币系统"><a href="#P5020-货币系统" class="headerlink" title="P5020 货币系统"></a><a class="link"   href="https://www.luogu.com.cn/problem/P5020" >P5020 货币系统<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>A 集合中可以被除了自己的金币表示的面额一定没用，剩下的就是最小的 m。</p>
<p>设 $f_i$ 为 $i$ 是否能被 $a$ 集合内组成。</p>
<p>假如 $x$ 可以被 $a$ 集合内元素组成，那么可能组成 $x$ 的某个数 $a_i$</p>
<p>减去之后，$x - a_i$ 也是可以被 $a$ 集合内的元素组成。</p>
<p>枚举一下比当前面额大的然后用当前面额更新它们即可。</p>
<p>初始化 $f_0&#x3D;1$</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> f[<span class="number">25555</span>]; <span class="comment">// i 能否被组成</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="type">int</span> ans = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 枚举集合中的物品</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i]]) <span class="comment">// 如果能被表示 那就不要它了</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = a[i]; j &lt;= a[n]; j++) <span class="comment">// 枚举比 a[i] 大的来更新</span></span><br><span class="line">                f[j] |= f[j - a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="P1064-金明的预算方案"><a href="#P1064-金明的预算方案" class="headerlink" title="P1064 金明的预算方案"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1064" >P1064 金明的预算方案<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>由于最多只有两个附件，所以我们正常枚举主件，然后看看附件选不选怎么选优即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">32010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N], p[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> mp[<span class="number">66</span>][<span class="number">3</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; mm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;w[i], &amp;v[i], &amp;p[i]);</span><br><span class="line">        <span class="keyword">if</span>(p[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp[p[i]][<span class="number">1</span>]) mp[p[i]][<span class="number">1</span>] = i;</span><br><span class="line">            <span class="keyword">else</span> mp[p[i]][<span class="number">2</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> mm.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : mm)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= w[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> val0 = w[i] * v[i], val1 = w[mp[i][<span class="number">1</span>]] * v[mp[i][<span class="number">1</span>]], val2 = w[mp[i][<span class="number">2</span>]] * v[mp[i][<span class="number">2</span>]];</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + val0);</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= w[i] + w[mp[i][<span class="number">1</span>]] &amp;&amp; val1)</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - w[i] - w[mp[i][<span class="number">1</span>]]] + val0 + val1);</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= w[i] + w[mp[i][<span class="number">2</span>]] &amp;&amp; val2)</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - w[i] - w[mp[i][<span class="number">2</span>]]] + val0 + val2);</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= w[i] + w[mp[i][<span class="number">1</span>]] + w[mp[i][<span class="number">2</span>]] &amp;&amp; val1 &amp;&amp; val2)</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - w[i] - w[mp[i][<span class="number">1</span>]] - w[mp[i][<span class="number">2</span>]]] + val0 + val1 + val2);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="P2946-Cow-Frisbee-Team-S"><a href="#P2946-Cow-Frisbee-Team-S" class="headerlink" title="P2946 Cow Frisbee Team S"></a><a class="link"   href="https://www.luogu.com.cn/problem/P2946" >P2946 Cow Frisbee Team S<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>考虑模数为状态，然后正常考虑每一个牛选不选的方案数，最后输出模数为 0 的状态即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[M]; <span class="comment">// 考虑了前 i 头牛总能力模 f 为 j 的方案数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[a[i] % c] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = c - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = (f[j] + f[j] % MOD + f[(j - a[i] % c + c) % c] % MOD) % MOD; <span class="comment">// 选或者不选两种情况</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="P1156-垃圾陷阱"><a href="#P1156-垃圾陷阱" class="headerlink" title="P1156 垃圾陷阱"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1156" >P1156 垃圾陷阱<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>用 $f_i$ 代表高度为 $i$ 时的最长存活时间。</p>
<p>枚举当前要决定堆哪个，用旧状态更新新状态，然后把旧状态更新为可以吃垃圾的新状态。</p>
<p>这里的顺序非常精妙，值得深思。</p>
<p>短短的代码，大大的智慧。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">101</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">De</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t, p, h;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> De &amp;a) <span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> t &lt; a.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;de[N];</span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// 考虑了前 i 个垃圾 堆了 j 米 的最多存活时长</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d, g;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;d, &amp;g);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= g; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;de[i].t, &amp;de[i].p, &amp;de[i].h);</span><br><span class="line">    <span class="built_in">sort</span>(de + <span class="number">1</span>, de + <span class="number">1</span> + g);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= g; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = d; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[j] &gt;= de[i].t) <span class="comment">// 当前高度可以存活</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j + de[i].h &gt;= d) <span class="comment">// 可以出去</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; de[i].t &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                f[j + de[i].h] = <span class="built_in">max</span>(f[j + de[i].h], f[j]); <span class="comment">// 堆</span></span><br><span class="line">                f[j] += de[i].p; <span class="comment">// 吃</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &#x27;Y&#x27; &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; f[<span class="number">0</span>] &lt;&lt; endl; <span class="comment">// 出不去 就都吃不堆</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><h3 id="P2014选课"><a href="#P2014选课" class="headerlink" title="P2014选课"></a><a class="link"   href="https://www.luogu.com.cn/problem/P2014" >P2014选课<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>树形背包问题。</p>
<p>倒叙枚举体积把枚举到第几个儿子这个状态给滚掉，详情见DP-背包问题。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">305</span>;</span><br><span class="line"><span class="type">int</span> n,m,edcnt;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m<span class="number">+1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)</span><br><span class="line">                f[u][j]=<span class="built_in">max</span>(f[u][j],f[v][k]+f[u][j-k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;k,&amp;s[i]);</span><br><span class="line">        f[i][<span class="number">1</span>]=s[i];</span><br><span class="line">        <span class="built_in">add</span>(k,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">0</span>][m<span class="number">+1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P1352没有上司的舞会"><a href="#P1352没有上司的舞会" class="headerlink" title="P1352没有上司的舞会"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1352" >P1352没有上司的舞会<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>本质为树的最大独立集问题。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">6e3</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n,edcnt;</span><br><span class="line"><span class="type">int</span> r[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt,to;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">    f[u][<span class="number">1</span>]=r[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            f[u][<span class="number">0</span>]+=<span class="built_in">max</span>(f[v][<span class="number">0</span>],f[v][<span class="number">1</span>]);</span><br><span class="line">            f[u][<span class="number">1</span>]+=f[v][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;k);</span><br><span class="line">        <span class="built_in">add</span>(k,l);</span><br><span class="line">        <span class="built_in">add</span>(l,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">max</span>(f[<span class="number">1</span>][<span class="number">0</span>],f[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P2016战略游戏"><a href="#P2016战略游戏" class="headerlink" title="P2016战略游戏"></a><a class="link"   href="https://www.luogu.com.cn/problem/P2016" >P2016战略游戏<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>与没有上司的舞会类似。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2000</span>;</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,edcnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>]=<span class="number">1</span>,f[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">            f[u][<span class="number">1</span>]+=<span class="built_in">min</span>(f[v][<span class="number">0</span>],f[v][<span class="number">1</span>]);</span><br><span class="line">            f[u][<span class="number">0</span>]+=f[v][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,k,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;k);</span><br><span class="line">        u++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">            <span class="built_in">add</span>(u,++v);</span><br><span class="line">            <span class="built_in">add</span>(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">min</span>(f[<span class="number">1</span>][<span class="number">0</span>],f[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P4516潜入行动"><a href="#P4516潜入行动" class="headerlink" title="P4516潜入行动"></a><a class="link"   href="https://www.luogu.com.cn/problem/P4516" >P4516潜入行动<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>典型的树形背包问题，问题在于合并两颗子树，状态定义见注释。</p>
<p>对于一个子树，它的根节点有四种可能的情况：没放置没被监听，没放置被监听，放置没被监听，放置被监听。</p>
<p>然后对这些另一个子树的情况进行分类讨论即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> edcnt;</span><br><span class="line"><span class="type">int</span> fir[N],siz[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>][<span class="number">2</span>][<span class="number">101</span>];<span class="comment">//以i为根的子树，i节点放没放装置，当前这个节点有没有被监听到，当前用了l个监听设备的方案数</span></span><br><span class="line"><span class="type">int</span> temp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt,to;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="built_in">dp</span>(v,u);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(siz[u],k);j++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp[<span class="number">0</span>][<span class="number">0</span>][j]=f[u][<span class="number">0</span>][<span class="number">0</span>][j];</span><br><span class="line">                f[u][<span class="number">0</span>][<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">                temp[<span class="number">1</span>][<span class="number">0</span>][j]=f[u][<span class="number">1</span>][<span class="number">0</span>][j];</span><br><span class="line">                f[u][<span class="number">1</span>][<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">                temp[<span class="number">0</span>][<span class="number">1</span>][j]=f[u][<span class="number">0</span>][<span class="number">1</span>][j];</span><br><span class="line">                f[u][<span class="number">0</span>][<span class="number">1</span>][j]=<span class="number">0</span>;</span><br><span class="line">                temp[<span class="number">1</span>][<span class="number">1</span>][j]=f[u][<span class="number">1</span>][<span class="number">1</span>][j];</span><br><span class="line">                f[u][<span class="number">1</span>][<span class="number">1</span>][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(siz[u],k);j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=<span class="built_in">min</span>(siz[v],k-j);l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[u][<span class="number">0</span>][<span class="number">0</span>][j+l]=(<span class="number">1ll</span>*f[u][<span class="number">0</span>][<span class="number">0</span>][j+l]<span class="number">+1ll</span>*temp[<span class="number">0</span>][<span class="number">0</span>][j]*f[v][<span class="number">0</span>][<span class="number">1</span>][l])%mod;</span><br><span class="line">                    f[u][<span class="number">0</span>][<span class="number">1</span>][j+l]=(<span class="number">1ll</span>*f[u][<span class="number">0</span>][<span class="number">1</span>][j+l]<span class="number">+1ll</span>*temp[<span class="number">0</span>][<span class="number">1</span>][j]*(f[v][<span class="number">0</span>][<span class="number">1</span>][l]+f[v][<span class="number">1</span>][<span class="number">1</span>][l])%mod<span class="number">+1ll</span>*temp[<span class="number">0</span>][<span class="number">0</span>][j]*f[v][<span class="number">1</span>][<span class="number">1</span>][l])%mod;</span><br><span class="line">                    f[u][<span class="number">1</span>][<span class="number">0</span>][j+l]=(<span class="number">1ll</span>*f[u][<span class="number">1</span>][<span class="number">0</span>][j+l]<span class="number">+1ll</span>*temp[<span class="number">1</span>][<span class="number">0</span>][j]*(f[v][<span class="number">0</span>][<span class="number">0</span>][l]+f[v][<span class="number">0</span>][<span class="number">1</span>][l]))%mod;</span><br><span class="line">                    f[u][<span class="number">1</span>][<span class="number">1</span>][j+l]=((<span class="number">1ll</span>*f[u][<span class="number">1</span>][<span class="number">1</span>][j+l]<span class="number">+1ll</span>*temp[<span class="number">1</span>][<span class="number">0</span>][j]*(f[v][<span class="number">1</span>][<span class="number">0</span>][l]+f[v][<span class="number">1</span>][<span class="number">1</span>][l]))%mod<span class="number">+1ll</span>*temp[<span class="number">1</span>][<span class="number">1</span>][j]*(<span class="number">1ll</span>*f[v][<span class="number">0</span>][<span class="number">0</span>][l]<span class="number">+1ll</span>*f[v][<span class="number">0</span>][<span class="number">1</span>][l]<span class="number">+1ll</span>*f[v][<span class="number">1</span>][<span class="number">0</span>][l]<span class="number">+1ll</span>*f[v][<span class="number">1</span>][<span class="number">1</span>][l]))%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>][k]+f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][k])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P1122最大子树和"><a href="#P1122最大子树和" class="headerlink" title="P1122最大子树和"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1122" >P1122最大子树和<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>常规树形DP。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n,edcnt;</span><br><span class="line"><span class="type">int</span> beauty[N];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt,to;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u]=beauty[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="built_in">dp</span>(v,u);</span><br><span class="line">            f[u]+=<span class="built_in">max</span>(f[v],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;beauty[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P1273有线电视网"><a href="#P1273有线电视网" class="headerlink" title="P1273有线电视网"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1273" >P1273有线电视网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>对于叶子节点，它满足一个用户的最大收益就是对应价值，然后转移时当作背包来做，用户总数量相当于背包容量，最后我们就是找找看以1为根的子树中最大收益大于等于零的最大用户数，倒叙枚举即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3100</span>;</span><br><span class="line"><span class="type">int</span> n,m,edcnt;</span><br><span class="line"><span class="type">int</span> pay[N];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">int</span> f[N][N];<span class="comment">//在以i为根的子树中满足j个用户需求的最大收益</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt,val;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].val=w;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!fir[u])</span><br><span class="line">    &#123;</span><br><span class="line">        f[u][<span class="number">1</span>]=pay[u];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">dp</span>(v);</span><br><span class="line">        sum+=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=x;k++)</span><br><span class="line">                <span class="keyword">if</span>(j-k&gt;=<span class="number">0</span>) f[u][j]=<span class="built_in">max</span>(f[u][j],f[u][j-k]+f[v][k]-e[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;c);</span><br><span class="line">            <span class="built_in">add</span>(i,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pay[n-m+i]);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xc0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">1</span>][i]&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P3047"><a href="#P3047" class="headerlink" title="P3047"></a><a class="link"   href="https://www.luogu.com.cn/problem/P3047" >P3047<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>状态设计为 $f_{i,j}$，表示距离 $i$ 为 $j$ 的点权之和，首先先正常进行一遍 DFS，然后向下的距离就处理好了，但是还可以向上走，于是再进行一遍 DFS，这时候在回溯之前更新上方的距离，由于可能会有重复：比如先从儿子走到父亲，但是父亲又走到了儿子，所以要减去与当前节点距离少二的那些点，如图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202308270953403.webp"
                      alt="image.png"
                ></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n,k,edcnt;</span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">27</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt,to;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="built_in">dp</span>(v,u);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">                f[u][j]+=f[v][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=k;j&gt;=<span class="number">2</span>;j--)</span><br><span class="line">                f[v][j]-=f[v][j<span class="number">-2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">                f[v][j]+=f[u][j<span class="number">-1</span>];</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val[i]),f[i][<span class="number">0</span>]=val[i];</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++)</span><br><span class="line">            sum+=f[i][j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P5658括号树"><a href="#P5658括号树" class="headerlink" title="P5658括号树"></a><a class="link"   href="https://www.luogu.com.cn/problem/P5658" >P5658括号树<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>记录一下以 $i$ 结尾的合法串数，和根节点到 $i$ 的离 $i$ 最近的未匹配的左括号，</p>
<p>然后进行 DFS，如果当前点是左括号，那么就更新一下最近未匹配的左括号，如果是右括号，那么合法的括号数就要加上之前已经合法的括号数再加一。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> n,edcnt;</span><br><span class="line"><span class="type">int</span> fir[N],fa[N],last[N];</span><br><span class="line">ll f[N];</span><br><span class="line">string par;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    last[u]=last[fa[u]];</span><br><span class="line">    <span class="keyword">if</span>(par[u<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span>) last[u]=u;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(last[u]) f[u]=f[fa[last[u]]]<span class="number">+1</span>,last[u]=last[fa[last[u]]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="built_in">dfs</span>(e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    cin&gt;&gt;par;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;fa[i]);</span><br><span class="line">        <span class="built_in">add</span>(fa[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    ans=f[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        f[i]+=f[fa[i]],ans^=i*f[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P3177树上染色"><a href="#P3177树上染色" class="headerlink" title="P3177树上染色"></a><a class="link"   href="https://www.luogu.com.cn/problem/P3177" >P3177树上染色<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>我们考虑每条边，这条边被经过的次数乘以它的边权便是它产生的贡献，而一条边被经过的次数其实就是它左边和右边的点对数，设 $f_{i,j}$ 为以 $i$ 为根的子树中选了 $j$ 个黑色点所得到的最大价值。</p>
<p>转移时，其实就是合并子树，如果不是第一次，也就是说可以不选黑色点，要记得与该子树全为白色点取max。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,k,edcnt;</span><br><span class="line"><span class="type">int</span> fir[N],siz[N];</span><br><span class="line">ll f[N][N];<span class="comment">//在以i为根的子树中选了j个黑色点的最大贡献</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt,val;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    e[edcnt].val=w;</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>]=f[u][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="built_in">dp</span>(v,u);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">min</span>(k,siz[u]);j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(f[u][j]!=<span class="number">-1</span>)</span><br><span class="line">                    f[u][j]+=f[v][<span class="number">0</span>]<span class="number">+1ll</span>*siz[v]*(n-k-siz[v])*e[i].val;</span><br><span class="line">                <span class="comment">//假如已经更新过，那么黑色点就都可以在之前被更新的子树上，剩下的子树就多出了全为白色点的情况，拿它与黑点的情况取max</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="built_in">min</span>(j,siz[v]);l&gt;=<span class="number">1</span>;l--)<span class="comment">//枚举子树中黑色点的个数</span></span><br><span class="line">                    <span class="keyword">if</span>(f[u][j-l]!=<span class="number">-1</span>)<span class="comment">//可以从此状态转移而来</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        ll tot=(<span class="number">1ll</span>*l*(k-l)+(siz[v]-l)*(n-k-siz[v]+l))*e[i].val;<span class="comment">//相同颜色点对在这条边产生的总价值</span></span><br><span class="line">                        f[u][j]=<span class="built_in">max</span>(f[u][j],f[u][j-l]+f[v][l]+tot);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[<span class="number">1</span>][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h2><h3 id="P1433吃奶酪"><a href="#P1433吃奶酪" class="headerlink" title="P1433吃奶酪"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1433" >P1433吃奶酪<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>定义 $f_{i,j}$ 为当前状态为 $i$，走到了第 $j$ 个奶酪的最短距离。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cheese</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">&#125;c[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dist</span><span class="params">(Cheese a,Cheese b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> f[<span class="number">1</span>&lt;&lt;<span class="number">16</span>][<span class="number">18</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;c[i].x,&amp;c[i].y);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">127</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        f[<span class="number">1</span>&lt;&lt;i][i]=<span class="built_in">dist</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">                    <span class="keyword">if</span>(((i&gt;&gt;k)&amp;<span class="number">1</span>)==<span class="number">0</span>)</span><br><span class="line">                        f[i|(<span class="number">1</span>&lt;&lt;k)][k]=<span class="built_in">min</span>(f[i|(<span class="number">1</span>&lt;&lt;k)][k],f[i][j]+<span class="built_in">dist</span>(c[j],c[k]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][i]);</span><br><span class="line">        <span class="comment">// printf(&quot;%.2f\n&quot;,f[(1&lt;&lt;n)-1][i]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P1171售货员的难题"><a href="#P1171售货员的难题" class="headerlink" title="P1171售货员的难题"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1171" >P1171售货员的难题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>与吃奶酪类似，就是最后要回到起点。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">+1</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> dist[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> ans=INT_MAX;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;dist[i][j]);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">                    <span class="keyword">if</span>(((i&gt;&gt;k)&amp;<span class="number">1</span>)==<span class="number">0</span>)</span><br><span class="line">                        f[i|(<span class="number">1</span>&lt;&lt;k)][k]=<span class="built_in">min</span>(f[i|(<span class="number">1</span>&lt;&lt;k)][k],f[i][j]+dist[j][k]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][i]+dist[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P1278单词游戏"><a href="#P1278单词游戏" class="headerlink" title="P1278单词游戏"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1278" >P1278单词游戏<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>先预处理出所有能连着说的两个单词所贡献的复杂度，然后处理下只说这个单词的复杂度，然后就可以愉快地进行状压DP了，枚举每一个状态，判断下上一个是否已经选过了，只有上一个选过了才能进行转移，并且下一个要选的没有选过。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dist[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1</span>&lt;&lt;<span class="number">17</span>][<span class="number">17</span>];</span><br><span class="line">string word[<span class="number">17</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        cin&gt;&gt;word[i];</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0xc0</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(i!=j&amp;&amp;word[i][word[i].<span class="built_in">length</span>()<span class="number">-1</span>]==word[j][<span class="number">0</span>])</span><br><span class="line">                dist[i][j]=word[j].<span class="built_in">length</span>();</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        f[<span class="number">1</span>&lt;&lt;i][i]=word[i].<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">                    <span class="keyword">if</span>(((i&gt;&gt;k)&amp;<span class="number">1</span>)==<span class="number">0</span>)</span><br><span class="line">                        f[i|(<span class="number">1</span>&lt;&lt;k)][k]=<span class="built_in">max</span>(f[i|(<span class="number">1</span>&lt;&lt;k)][k],f[i][j]+dist[j][k]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,f[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P2704炮兵阵地"><a href="#P2704炮兵阵地" class="headerlink" title="P2704炮兵阵地"></a><a class="link"   href="https://www.luogu.com.cn/problem/P2704" >P2704炮兵阵地<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>首先把每一行的地形都预处理为一个二进制数，1代表山地，0代表平原，这样枚举每一个状态的时候，如果它们与起来的结果不是零，那么这个状态便不合法。</p>
<p>由于该行状态会受到上一行和上上行的影响，所以我们只需要记录本行和上一行，枚举三行的状态即可，这里需要用到滚动数组优化。</p>
<p>判断状态是否合法可以通过左移一位和两位与上行、上上行与来判断。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,ans;</span><br><span class="line"><span class="type">int</span> f[<span class="number">3</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> mp[<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">            <span class="keyword">while</span>(c!=<span class="string">&#x27;H&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;P&#x27;</span>) c=<span class="built_in">getchar</span>();</span><br><span class="line">            mp[i]&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            mp[i]+=(c==<span class="string">&#x27;H&#x27;</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nope=i;</span><br><span class="line">        <span class="keyword">while</span>(nope)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nope&amp;<span class="number">1</span>) sum[i]++;</span><br><span class="line">            nope&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++)</span><br><span class="line">        <span class="keyword">if</span>(!((i&amp;mp[<span class="number">0</span>])||(i&amp;(i&lt;&lt;<span class="number">1</span>))||(i&amp;(i&lt;&lt;<span class="number">2</span>))))</span><br><span class="line">            f[<span class="number">0</span>][<span class="number">0</span>][i]=sum[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);j++)</span><br><span class="line">            <span class="keyword">if</span>(!(i&amp;j||i&amp;mp[<span class="number">0</span>]||j&amp;mp[<span class="number">1</span>]||(i&amp;(i&lt;&lt;<span class="number">1</span>))||(i&amp;(i&lt;&lt;<span class="number">2</span>))||(j&amp;(j&lt;&lt;<span class="number">1</span>))||(j&amp;(j&lt;&lt;<span class="number">2</span>))))</span><br><span class="line">                f[<span class="number">1</span>][i][j]=sum[i]+sum[j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);j++)</span><br><span class="line">            <span class="keyword">if</span>(!(j&amp;(mp[i<span class="number">-1</span>])||(j&amp;(j&lt;&lt;<span class="number">1</span>))||(j&amp;(j&lt;&lt;<span class="number">2</span>))))</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;(<span class="number">1</span>&lt;&lt;m);l++)</span><br><span class="line">                    <span class="keyword">if</span>(!((l&amp;j)||(l&amp;mp[i<span class="number">-2</span>])||(l&amp;(l&lt;&lt;<span class="number">1</span>))||(l&amp;(l&lt;&lt;<span class="number">2</span>))))</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);k++)</span><br><span class="line">                            <span class="keyword">if</span>(!((k&amp;mp[i])||(j&amp;k)||(l&amp;k)||(k&amp;(k&lt;&lt;<span class="number">1</span>))||(k&amp;(k&lt;&lt;<span class="number">2</span>))))</span><br><span class="line">                                f[i%<span class="number">3</span>][j][k]=<span class="built_in">max</span>(f[i%<span class="number">3</span>][j][k],f[(i<span class="number">-1</span>)%<span class="number">3</span>][l][j]+sum[k]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);j++)</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,f[(n<span class="number">-1</span>)%<span class="number">3</span>][i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P1896互不侵犯"><a href="#P1896互不侵犯" class="headerlink" title="P1896互不侵犯"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1896" >P1896互不侵犯<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>与炮兵阵地类似，利用左移和右移判断状态是否合法。</p>
<p>由于要用完所有国王，所以要记录一下当前状态用了几个国王，预处理出来每个状态该行对应的国王数即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,K;</span><br><span class="line">ll ans;</span><br><span class="line">ll f[<span class="number">10</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nope=i;</span><br><span class="line">        <span class="keyword">while</span>(nope)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nope&amp;<span class="number">1</span>) sum[i]++;</span><br><span class="line">            nope&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line">            <span class="keyword">if</span>(!((j&amp;(j&lt;&lt;<span class="number">1</span>))||(j&amp;(j&gt;&gt;<span class="number">1</span>))))</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;n);k++)</span><br><span class="line">                    <span class="keyword">if</span>(!(k&amp;(k&lt;&lt;<span class="number">1</span>)||(k&amp;(k&gt;&gt;<span class="number">1</span>))||(k&amp;j)||((j&gt;&gt;<span class="number">1</span>)&amp;k)||((j&lt;&lt;<span class="number">1</span>)&amp;k)))</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> l=sum[k];l&lt;=K;l++)</span><br><span class="line">                            f[i][k][l]+=f[i<span class="number">-1</span>][j][l-sum[k]];</span><br><span class="line">                        </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">        <span class="keyword">if</span>(!(i&amp;(i&lt;&lt;<span class="number">1</span>)||(i&amp;(i&gt;&gt;<span class="number">1</span>))))</span><br><span class="line">            ans+=f[n][i][K];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="P1283平板涂色"><a href="#P1283平板涂色" class="headerlink" title="P1283平板涂色"></a><a class="link"   href="https://www.luogu.com.cn/problem/P1283" >P1283平板涂色<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>记录色块可以用二维矩阵模拟。</p>
<p>为了防止边界计算重复，所以在二维数组中采用左开右闭的方式存储，</p>
<p>然后记录一下每一个矩形上方的矩阵，用来判断当前状态是否合法。</p>
<p>什么都没涂的时候第一次也是要拿起刷子的，注意。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> topLeftX,topLeftY,bottomRightX,bottomRightY;</span><br><span class="line">    <span class="type">int</span> color;</span><br><span class="line">&#125;rec[<span class="number">17</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> mp[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">17</span>];</span><br><span class="line"><span class="type">int</span> up[<span class="number">17</span>][<span class="number">17</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">16</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//x状态下第y个矩形上方所有矩形是否已经完成涂色</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sum[y];i++)</span><br><span class="line">        <span class="keyword">if</span>(!(x&gt;&gt;(up[y][i]<span class="number">-1</span>)&amp;<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;rec[i].topLeftY,&amp;rec[i].topLeftX,&amp;rec[i].bottomRightY,&amp;rec[i].bottomRightX,&amp;rec[i].color);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=rec[i].topLeftX;j&lt;rec[i].bottomRightX;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=rec[i].topLeftY;k&lt;rec[i].bottomRightY;k++)</span><br><span class="line">                mp[j][k]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(rec[i].topLeftY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=rec[i].topLeftY<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=rec[i].topLeftX<span class="number">+1</span>;j&lt;=rec[i].bottomRightX;j++)</span><br><span class="line">                <span class="keyword">if</span>(mp[j][y]!=mp[j<span class="number">-1</span>][y]) up[i][++sum[i]]=mp[j<span class="number">-1</span>][y];<span class="comment">//找出所有i上方的矩形</span></span><br><span class="line">            <span class="keyword">if</span>(mp[rec[i].bottomRightX][y]==mp[rec[i].bottomRightX<span class="number">-1</span>][y]) up[i][++sum[i]]=mp[rec[i].bottomRightX<span class="number">-1</span>][y];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">        dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(((i&gt;&gt;(j<span class="number">-1</span>))&amp;<span class="number">1</span>)&amp;&amp;<span class="built_in">check</span>(i,j)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">20</span>;k++)</span><br><span class="line">                    <span class="keyword">if</span>(k!=rec[j].color) dp[i][rec[j].color]=<span class="built_in">min</span>(dp[i][rec[j].color],dp[i-(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][k]<span class="number">+1</span>);</span><br><span class="line">                dp[i][rec[j].color]=<span class="built_in">min</span>(dp[i][rec[j].color],dp[i-(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][rec[j].color]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0x3f3f3f5f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p><a class="link"   href="https://www.luogu.com.cn/problem/P5005" >P5005中国象棋-摆上马<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>注意判断要进行双向判断，并不是我 $i$ 行打不到 $j$ 行 $j$ 行就一定打不到 $i$ 行。</p>
<p>对于这种状态累加而非覆盖的滚动数组优化，一定要在更新前把旧的用不到的状态清零。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> f[<span class="number">3</span>][<span class="number">65</span>][<span class="number">65</span>];<span class="comment">//当前已经放完了前i行的马，上一行的状态是j，第i行的状态是k</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//分别代表两个状态：上一行，本行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(((x&gt;&gt;i)&amp;<span class="number">1</span>)&amp;&amp;(!((x&gt;&gt;(i<span class="number">+1</span>))&amp;<span class="number">1</span>))&amp;&amp;((y&gt;&gt;(i<span class="number">+2</span>))&amp;<span class="number">1</span>))<span class="comment">//i位有马且i-1位无马</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(((x&gt;&gt;i)&amp;<span class="number">1</span>)&amp;&amp;(!((x&gt;&gt;(i<span class="number">-1</span>))&amp;<span class="number">1</span>))&amp;&amp;((y&gt;&gt;(i<span class="number">-2</span>))&amp;<span class="number">1</span>))<span class="comment">//i位有马且i+1位无马</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span><span class="comment">//分别代表三个状态：上上行，上一行，本行,判断上上行与本行是否冲突</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="comment">//i位置上上行有马并且上行这个位置没有马并且本行前后两位有马</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(((x&gt;&gt;i)&amp;<span class="number">1</span>)&amp;&amp;(!((y&gt;&gt;i)&amp;<span class="number">1</span>))&amp;&amp;((z&gt;&gt;(i<span class="number">+1</span>))&amp;<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(((x&gt;&gt;i)&amp;<span class="number">1</span>)&amp;&amp;(!((y&gt;&gt;i)&amp;<span class="number">1</span>))&amp;&amp;((z&gt;&gt;(i<span class="number">-1</span>))&amp;<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++)</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++)<span class="comment">//第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);j++)<span class="comment">//第二行</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check_1</span>(i,j)&amp;&amp;<span class="built_in">check_1</span>(j,i))</span><br><span class="line">                f[<span class="number">2</span>][i][j]=(<span class="number">1ll</span>*f[<span class="number">2</span>][i][j]<span class="number">+1ll</span>*f[<span class="number">1</span>][<span class="number">0</span>][i])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f[i%<span class="number">3</span>],<span class="number">0</span>,<span class="built_in">sizeof</span>(f[i%<span class="number">3</span>]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);j++)<span class="comment">//上上行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);k++)<span class="comment">//上一行</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check_1</span>(j,k)&amp;&amp;<span class="built_in">check_1</span>(k,j))</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;(<span class="number">1</span>&lt;&lt;m);l++)<span class="comment">//本行</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">check_1</span>(k,l)&amp;&amp;<span class="built_in">check_1</span>(l,k)&amp;&amp;<span class="built_in">check_2</span>(j,k,l)&amp;&amp;<span class="built_in">check_2</span>(l,k,j))</span><br><span class="line">                            f[i%<span class="number">3</span>][k][l]=(<span class="number">1ll</span>*f[i%<span class="number">3</span>][k][l]<span class="number">+1ll</span>*f[(i<span class="number">-1</span>)%<span class="number">3</span>][j][k])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check_1</span>(i,j)&amp;&amp;<span class="built_in">check_1</span>(j,i))</span><br><span class="line">                ans=(ans<span class="number">+1ll</span>*f[n%<span class="number">3</span>][i][j])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h2><h3 id="P2657-Windy数"><a href="#P2657-Windy数" class="headerlink" title="P2657 Windy数"></a><a class="link"   href="https://www.luogu.com.cn/problem/P2657" >P2657 Windy数<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>首先预处理出所有长度和不同最高位的windy数方案数。</p>
<p>然后进行讨论即可，详情见注释。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll f[<span class="number">11</span>][<span class="number">11</span>];<span class="comment">//长度为i中最高位为j的</span></span><br><span class="line"><span class="type">int</span> numb[<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">        f[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">11</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">9</span>;k++)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(j-k)&gt;=<span class="number">2</span>) f[i][j]+=f[i<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(numb,<span class="number">0</span>,<span class="built_in">sizeof</span>(numb));</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        numb[++len]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)<span class="comment">//长度比原数小那么一定是在上界之内的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;numb[len];j++)<span class="comment">//枚举最高位也小于原数的情况</span></span><br><span class="line">                sum+=f[i][j];     </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)<span class="comment">//枚举最高位填多少</span></span><br><span class="line">            sum+=f[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)<span class="comment">//假如i位之前与原数相同，那么其实就是统计满足条件的长度为1~len-1的个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;numb[i];j++)<span class="comment">//第i位填什么与第i+1位可以相差至少为2，这里是小于，因为要保证小于上界</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(j-numb[i<span class="number">+1</span>])&gt;=<span class="number">2</span>) sum+=f[i][j];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(numb[i]-numb[i<span class="number">+1</span>])&lt;<span class="number">2</span>) <span class="keyword">break</span>;<span class="comment">//假如从高到低枚举填完了第i位与第i+1位则不符合条件</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) sum++;<span class="comment">//最后一位相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">solve</span>(b)-<span class="built_in">solve</span>(a<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>题意：求区间内满足 相邻两个数位至少差 2 的条件的数的个数。</p>
<p>本题有两个额外限制条件：前导零和上一个填的数，都需要记录。</p>
<p>注意初始 last 的初始化，不要约束到第一个数。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">22</span>][<span class="number">12</span>]; <span class="comment">// [pos + 1,len] 都已经填写，上一位填的数是 last，[1,pos] 随便填的windy数量</span></span><br><span class="line"><span class="comment">// 即长度为 pos + 1 的以last开头的 windy 数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> limit, <span class="type">bool</span> lead, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 第一位假如是windy数，那就返回 1</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; last != INF &amp;&amp; ~f[pos][last]) <span class="keyword">return</span> f[pos][last];</span><br><span class="line">    <span class="type">int</span> up = limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 代表的是当前 [1,pos] 都填完了的答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead) res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, lead &amp;&amp; i == <span class="number">0</span>, i == <span class="number">0</span> ? last : i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(last - i) &gt;= <span class="number">2</span>) res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, <span class="literal">false</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; last != INF) f[pos][last] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++len] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len, <span class="literal">true</span>, <span class="literal">true</span>, INF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    LL l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    LL ans = <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="P4999烦人的数学作业"><a href="#P4999烦人的数学作业" class="headerlink" title="P4999烦人的数学作业"></a><a class="link"   href="https://www.luogu.com.cn/problem/P4999" >P4999烦人的数学作业<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>题意：求区间内的每个数字的每位数的数位和。</p>
<p>令 $f_{pos,sum}$ 代表 $[1,pos]$ 符合限制的条件下的数位和，记录后缀状态方便记搜。</p>
<p>从高位向低位搜索，会出现很多重复状态。</p>
<p>这样的好处是让程序帮你计算后缀记忆化的量，而不是自己手推复杂的式子正向递推减小正确率。</p>
<p><a class="link"   href="https://www.luogu.com.cn/discuss/710636" >讨论区<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> limit, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; ~f[pos][sum])</span><br><span class="line">        <span class="keyword">return</span> f[pos][sum];</span><br><span class="line">    <span class="type">int</span> up = limit ? a[pos] : <span class="number">9</span>; <span class="comment">// 上限</span></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">        res = (res + <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, sum + i)) % MOD;</span><br><span class="line">    <span class="keyword">if</span>(!limit)</span><br><span class="line">        f[pos][sum] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++len] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        LL ans = (<span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>) + MOD) % MOD;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="P2602数字计数"><a href="#P2602数字计数" class="headerlink" title="P2602数字计数"></a><a class="link"   href="https://www.luogu.com.cn/problem/P2602" >P2602数字计数<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>题意：求区间内每个数的十进制下每一位出现的次数。</p>
<p>这个限制条件多了一个前导零，判断一下前导零不要加到 0 的计数里即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">15</span>];</span><br><span class="line">LL f[<span class="number">15</span>][<span class="number">15</span>][<span class="number">2</span>];</span><br><span class="line">LL ans[<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> di;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> limit, <span class="type">bool</span> lead, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> cnt;</span><br><span class="line">    <span class="keyword">auto</span> &amp;now = f[pos][cnt][di != <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; ~now) <span class="keyword">return</span> now; <span class="comment">// 可以记忆化</span></span><br><span class="line">    <span class="type">int</span> up = limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cnt + (i == di);</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; di == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>) temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 之前有限制并且这一位还有限制下一位才能有限制</span></span><br><span class="line">        <span class="comment">// 之前有前导零并且这一位也是零那么下一位才能有前导零</span></span><br><span class="line">        res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, lead &amp;&amp; i == <span class="number">0</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead) now = res; <span class="comment">// 没有前导零并且没有限制，就可以记录</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(LL x, <span class="type">int</span> g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++len] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        di = i;</span><br><span class="line">        ans[i] += g * <span class="built_in">dfs</span>(len, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    LL l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    <span class="built_in">solve</span>(r, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">solve</span>(l - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.luogu.com.cn/problem/P4317" >P4317花神的数论题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>题意：求区间（左端点为 1）内所有数在二进制表示下 1 的个数的乘积。</p>
<p>本题无额外约束条件，转换为二进制进行数位 DP 即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e7</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 [pos + 1, len] 中已经填写了 cnt 个 1，[1,pos] 中任意填的合法方案的答案乘积</span></span><br><span class="line"><span class="comment">// 其实就是当前 [1,pos] 随便填，之前已经填了 cnt 个 1 的答案积</span></span><br><span class="line">LL f[<span class="number">82</span>][<span class="number">111</span>]; </span><br><span class="line"><span class="type">int</span> a[<span class="number">82</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> limit, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> <span class="built_in">max</span>(cnt, <span class="number">1</span>); <span class="comment">// 防止最终状态 cnt = 0 导致累乘答案为 0</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; ~f[pos][cnt]) <span class="keyword">return</span> f[pos][cnt]; <span class="comment">// 假如可以记忆化</span></span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> up = limit ? a[pos] : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">        res = (res * <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, cnt + (i &amp; <span class="number">1</span>))) % MOD;</span><br><span class="line">    <span class="keyword">if</span>(!limit) <span class="comment">// 没有限制并且一定存在该状态</span></span><br><span class="line">        f[pos][cnt] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++len] = x % <span class="number">2</span>;</span><br><span class="line">        x /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="P6218-Round-Numbers-S"><a href="#P6218-Round-Numbers-S" class="headerlink" title="P6218 Round Numbers S"></a><a class="link"   href="https://www.luogu.com.cn/problem/P6218" >P6218 Round Numbers S<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>题意：区间内满足二进制下 0 的个数不小于 1 的个数的数的方案数。</p>
<p>本题有两个额外约束条件：当前 0 的数目和 1 的数目和是否有前导零（因为要统计 0 的数目）。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">82</span>][<span class="number">82</span>][<span class="number">82</span>]; <span class="comment">// pos sum0 sum1 </span></span><br><span class="line"><span class="comment">// 我们不关心前面怎么填，只需要关心 [1,pos] 填 多少个 0 和 多少个 1 的方案数，因此可以这样记录状态</span></span><br><span class="line"><span class="comment">// 递归边界时，判断当前数是不是圆数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">82</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> limit, <span class="type">bool</span> lead, <span class="type">int</span> sum0, <span class="type">int</span> sum1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> sum0 &gt;= sum1;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; ~f[pos][sum0][sum1]) <span class="keyword">return</span> f[pos][sum0][sum1];</span><br><span class="line">    <span class="type">int</span> up = limit ? a[pos] : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; (i == <span class="number">0</span>))</span><br><span class="line">            res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, <span class="literal">true</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, <span class="literal">false</span>, sum0 + (i == <span class="number">0</span>), sum1 + (i == <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit) f[pos][sum0][sum1] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++len] = x % <span class="number">2</span>;</span><br><span class="line">        x /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    LL l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    LL ans = <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="CF628D-Magic-Numbers"><a href="#CF628D-Magic-Numbers" class="headerlink" title="CF628D Magic Numbers"></a><a class="link"   href="https://codeforces.com/contest/628/problem/D" >CF628D Magic Numbers<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>题意：求区间内满足偶数位全是 d 且奇数位不是 d 且模 d 为 0 的方案数。</p>
<p>本体额外限制条件：模 $m$ 余数为 $0$，由于读入很大，所以用字符串处理，由于 $l-1$ 可能产生退位，所以单独判断 $l$ 位置的合法性即可。</p>
<p>然后注意最高位不同情况下下标也不同。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [pos + 1, len] 已经填好，且填好的部分余数为 r，[1, len] 随意填写得到的方案数</span></span><br><span class="line">LL f[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="type">int</span> len, m, d;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2005</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> limit, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> r == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; ~f[pos][r]) <span class="keyword">return</span> f[pos][r];</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> up = limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">    <span class="type">bool</span> t = (len - pos + <span class="number">1</span>) &amp; <span class="number">1</span>; <span class="comment">// 当前位的奇偶性, 奇数位不能出现 d // 注意转换</span></span><br><span class="line">    <span class="keyword">if</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == d)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res = (res + <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, (r * <span class="number">10</span> + i) % m)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d &lt;= up)</span><br><span class="line">            res = (res + <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; d == up, (r * <span class="number">10</span> + d) % m)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit) f[pos][r] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(string x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    len = x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="comment">// a[len] 为最高位</span></span><br><span class="line">        a[len - i] = x[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="comment">// 注意下标 a[1] 为最高位</span></span><br><span class="line">        a[i + <span class="number">1</span>] = x[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == d)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] != d) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        r = (r * <span class="number">10</span> + a[i]) % m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    string l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;d);</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l) + <span class="built_in">check</span>(l) + MOD) % MOD;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="P4124-手机号码"><a href="#P4124-手机号码" class="headerlink" title="P4124 手机号码"></a><a class="link"   href="https://www.luogu.com.cn/problem/P4124" >P4124 手机号码<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>题意：求区间内满足限制的手机号码的个数。</p>
<p>本题额外限制：</p>
<ul>
<li>最高位为 1</li>
<li>有三个相邻且相同的数</li>
<li>4 和 8 不同时出现</li>
</ul>
<p>分别记录：</p>
<p>上一个数，上上个数，之前是否出现过三个相邻且相等，之前是否出现过 4，之前是否出现过 8.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本题额外限制：与上两个相邻的数的关系，目前位之前是否出现了 4，是否出现了 8</span></span><br><span class="line"><span class="comment">// 第一位是 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">12</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">int</span> f[<span class="number">12</span>][<span class="number">10</span>][<span class="number">10</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>]; <span class="comment">// 到 pos 位置位置，上两个相邻的数，之前是否出现过连号，是否出现过4，是否出现过8</span></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> limit, <span class="type">int</span> last1, <span class="type">int</span> last2, <span class="type">bool</span> same, <span class="type">bool</span> have4, <span class="type">bool</span> have8)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> (!(have4 &amp;&amp; have8) &amp;&amp; same);</span><br><span class="line">    <span class="keyword">auto</span> &amp;now = f[pos][last1][last2][same][have4][have8];</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; ~now) <span class="keyword">return</span> now;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> up = limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> down = pos == len ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = down; i &lt;= up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">4</span> &amp;&amp; !have8)</span><br><span class="line">            res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, i, last1, same || (i == last1 &amp;&amp; i == last2), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">8</span> &amp;&amp; !have4)</span><br><span class="line">            res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, i, last1, same || (i == last1 &amp;&amp; i == last1 &amp;&amp; i == last2), <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i != <span class="number">4</span> &amp;&amp; i != <span class="number">8</span>) </span><br><span class="line">            res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, i, last1, same || (i == last1 &amp;&amp; i == last2), have4, have8);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit) now = res; <span class="comment">// 合法的状态才值得被记录</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">1e10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++len] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len, <span class="literal">true</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="CF855E-Salazar-Slytherin’s-Locket"><a href="#CF855E-Salazar-Slytherin’s-Locket" class="headerlink" title="CF855E Salazar Slytherin’s Locket"></a><a href="">CF855E Salazar Slytherin’s Locket</a></h3><p>题意：求区间内的数都转换为 b 进制后，满足 $[0,b-1]$ 都各出现偶数次的数的个数。</p>
<p>坑点：</p>
<ul>
<li>开 <code>ll</code></li>
<li>记搜一定要判断前导零，只有合法的状态才可以被记忆化，而全是前导零的状态每一位都是 0，不合法所以不能被记忆化。</li>
</ul>
<p>本题限制：一个集合内数的出现个数都为偶数次，这个可以用一个二进制数状态压缩一下，第 i 位 代表 i 这个数当前是奇数次还是偶数次。</p>
<p>为了可以状态复用，所以状态多记录一个当前是几进制。</p>
<p>注意，全是偶数，即状态压缩后结果为 0，要排除全为前导零的情况。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">int</span> a[<span class="number">62</span>];</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">LL f[<span class="number">12</span>][<span class="number">62</span>][<span class="number">1030</span>]; <span class="comment">// r 进制 pos 当前递归到的位置 状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态压缩一下 0 - 该位代表的数字出现次数为偶数 1 - 奇数</span></span><br><span class="line"><span class="comment">// 统计数字，需要记录前导零</span></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> limit, <span class="type">int</span> state, <span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> (state == <span class="number">0</span> &amp;&amp; !lead);</span><br><span class="line">    <span class="keyword">auto</span> &amp;now = f[b][pos][state];</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; ~now) <span class="keyword">return</span> now; <span class="comment">// 没有前导零才是合法状态</span></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> up = limit ? a[pos] : b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, (lead &amp;&amp; i == <span class="number">0</span> ) ? <span class="number">0</span> : state ^ (<span class="number">1</span> &lt;&lt; i), lead &amp;&amp; i == <span class="number">0</span>); <span class="comment">// i 这个数出现的奇偶性：奇偶互换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead) now = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++len] = x % b;</span><br><span class="line">        x /= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len, <span class="literal">true</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    LL l, r;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld&quot;</span>, &amp;b, &amp;l, &amp;r);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="SP10606-BALNUM-Balanced-Numbers"><a href="#SP10606-BALNUM-Balanced-Numbers" class="headerlink" title="SP10606 BALNUM - Balanced Numbers"></a><a class="link"   href="https://www.luogu.com.cn/problem/SP10606" >SP10606 BALNUM - Balanced Numbers<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>题意：求一段区间内满足限制的数。</p>
<p>限制：对于数的每一位<strong>出现过</strong>的数码，偶数出现奇数次，奇数出现偶数次。</p>
<p>偶数要么出现零次要么出现奇数次，奇数要么出现零次要么出现偶数次。</p>
<p>这里由于有没出现过，奇数次，偶数次三种状态，所以一位二进制无法将其表示，因此这里用两位二进制数表示一个数的状态。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">22</span>];</span><br><span class="line">LL f[<span class="number">22</span>][(<span class="number">1</span> &lt;&lt; <span class="number">20</span>)]; <span class="comment">// 十个数 每个数用两位表示状态 一共二十位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 00 没出现过</span></span><br><span class="line"><span class="comment">// 01 出现奇数次</span></span><br><span class="line"><span class="comment">// 10 出现偶数次</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = (st &gt;&gt; (<span class="number">2</span> * i)) &amp; <span class="number">0b11</span>; <span class="comment">// 取出 i 对应的两位</span></span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">0b01</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp == <span class="number">0b10</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> st, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = (st &gt;&gt; (<span class="number">2</span> * i)) &amp; <span class="number">0b11</span>; <span class="comment">// 提取 i 对应的两位</span></span><br><span class="line">    st -= (temp &lt;&lt; (<span class="number">2</span> * i)); <span class="comment">// 减去 i 对应的两位</span></span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">0</span>)</span><br><span class="line">        temp = <span class="number">0b01</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp ^= <span class="number">0b11</span>; <span class="comment">// 01 变 10 10 变 01</span></span><br><span class="line">    st |= temp &lt;&lt; (<span class="number">2</span> * i); <span class="comment">// 加回去</span></span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> limit, <span class="type">bool</span> lead, <span class="type">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos)</span><br><span class="line">        <span class="keyword">return</span> !lead &amp;&amp; <span class="built_in">check</span>(st);</span><br><span class="line">    <span class="keyword">auto</span> &amp;now = f[pos][st];</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; ~now) <span class="keyword">return</span> now;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> up = limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = (lead &amp;&amp; i == <span class="number">0</span>) ? <span class="number">0</span> : <span class="built_in">add</span>(st, i);</span><br><span class="line">        res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, lead &amp;&amp; i == <span class="number">0</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead)</span><br><span class="line">        now = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++len] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="CFGYM104053M"><a href="#CFGYM104053M" class="headerlink" title="CFGYM104053M"></a><a class="link"   href="https://codeforces.com/gym/104053/problem/M" >CFGYM104053M<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>题意：求有多少个长度为 $k$ 的数组满足：</p>
<ul>
<li>$a_i\in[0,m]$</li>
<li>$(\sum_{i&#x3D;1}^k\sum_{j&#x3D;1}^{i-1}a_i\oplus{a_j})&#x3D;n$</li>
</ul>
<p>异或当前位产生价值的条件是当前这位是一个 $(0,1)$ 对，可以产生 $2^{pos}$ 的贡献。</p>
<p>由于是一个数组，假设有 $y$ 个数这一位填了 1，那么总共就会产生 $2^{pos}\times{y}\times{(k-y)}$ 的贡献（每个 0 都会和 它前面的 1 配对，每个 1 都会和它前面的 0 配对，这样就相当于互相组合且无重复）。</p>
<p>由于是很多数，所以我们记录总共受到限制的数的个数 $s$</p>
<p>当 $m$ 的这一位为 1 时：</p>
<p>枚举 $i,j$ 表示在 $s$ 个数里选了 $i$ 个数这一位填 1，在 $k-s$ 个数里选了 $j$ 个数填 1，贡献为 $2^{pos}\times(i+j)\times(k-i-j)$，下一层就是 <code>dfs(pos - 1, i, now + v)</code></p>
<p>这一位 0 时：</p>
<p>只需枚举 $k-s$ 中 $j$ 个数填 1，贡献是 $2^{pos}\times{j}\times(k-j)$</p>
<p>下一层就是：<code>dfs(pos - 1, s, now + v)</code></p>
<p>$now&gt;n$ 没必要搜了。</p>
<p>$max+now&lt;n$ 也没必要搜了。</p>
<p>由于本题只要状态有值就均是合法的，所以都可以记忆化。</p>
<p>由于第三维 $now$ 值域很大，所以我们用 <code>map</code> 存。</p>
<p>代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f[pos][s][now] // 当前位置 有 s 个当前位受限制 当前累计总贡献</span></span><br><span class="line"><span class="comment">// now &gt; n 时直接返回 0</span></span><br><span class="line"><span class="comment">// max + now &lt; n 也直接返回零 | max = (2 ^ (pos + 1) - 1) * k / 2 * (k - k / 2) (一半数 [1,pos] 全填 1 一半全填 0) </span></span><br><span class="line">map&lt;LL, LL&gt; f[<span class="number">62</span>][<span class="number">62</span>];</span><br><span class="line">LL n, m;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">LL c[<span class="number">62</span>][<span class="number">62</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">62</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">60</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> s, LL now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>) <span class="keyword">return</span> now == n;</span><br><span class="line">    <span class="keyword">if</span>(now + ((<span class="number">1ll</span> &lt;&lt; (pos + <span class="number">1</span>)) - <span class="number">1</span>) * (k / <span class="number">2</span>) * (k - k / <span class="number">2</span>) &lt; n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[pos][s].<span class="built_in">count</span>(now)) <span class="keyword">return</span> f[pos][s][now];</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(b[pos] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k - s; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                LL v = (LL)(k - i - j) * (i + j) * (<span class="number">1ll</span> &lt;&lt; pos); <span class="comment">// 该位产生的状态乘以组合的方案数</span></span><br><span class="line">                LL temp = c[s][i] * c[k - s][j] % MOD;</span><br><span class="line">                res = (res + temp * <span class="built_in">dfs</span>(pos - <span class="number">1</span>, i, now + v) % MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k - s; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            LL v = (LL)(k - j) * j * (<span class="number">1ll</span> &lt;&lt; pos);</span><br><span class="line">            LL temp = c[k - s][j];</span><br><span class="line">            res = (res + temp * <span class="built_in">dfs</span>(pos - <span class="number">1</span>, s, now + v) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[pos][s][now] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        b[len++] = x % <span class="number">2</span>;</span><br><span class="line">        x /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len - <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(m) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="P4127-同类分布"><a href="#P4127-同类分布" class="headerlink" title="P4127 同类分布"></a><a class="link"   href="https://www.luogu.com.cn/problem/P4127" >P4127 同类分布<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>题意：求区间内各位数字之和能整除原数的数的个数。</p>
<p>思考一下额外限制：</p>
<ul>
<li>前导零？没有影响。</li>
<li>数位之和要记录。</li>
<li>这个数填成什么样肯定也要记录，但是这个数会很大，状态数组肯定开不下，所以想到要模上某个数。而这个模数最好是刚好等于我们最后填完得到的数位之和，所以我们可以枚举数位之和，因为最多才 162，填完后假如填好的数是 0 （模意义下），并且模数刚好等于数位之和，那么我们就找到了一种合法状态。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">22</span>];</span><br><span class="line"><span class="type">int</span> mod;</span><br><span class="line">LL f[<span class="number">22</span>][<span class="number">170</span>][<span class="number">170</span>]; <span class="comment">// pos cnt state</span></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> limit, <span class="type">int</span> cnt, LL state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> (mod == cnt &amp;&amp; state == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; ~f[pos][cnt][state]) <span class="keyword">return</span> f[pos][cnt][state];</span><br><span class="line">    <span class="type">int</span> up = limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, cnt + i, (state * <span class="number">10</span> % mod + i) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit) f[pos][cnt][state] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++len] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(mod = <span class="number">1</span>; mod &lt;= len * <span class="number">9</span>; mod++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f)); <span class="comment">// 模数改变 之前的状态不能复用</span></span><br><span class="line">        res += <span class="built_in">dfs</span>(len, <span class="literal">true</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="P3413-萌数"><a href="#P3413-萌数" class="headerlink" title="P3413 萌数"></a><a class="link"   href="https://www.luogu.com.cn/problem/P3413" >P3413 萌数<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>题意：求一段区间内有多少数是萌数。</p>
<p>萌数：存在长度至少为 2 的回文子串。</p>
<p>所以我们只需要考虑存在多少长度为 2 或者长度为 3 的子串即可。</p>
<p>由于正着考虑太麻烦了 <del>其实就是懒得考虑</del></p>
<p>所以我们反向考虑，判断这段区间内存在多少没有回文子串的数，然后取个补集即可。</p>
<p>我们需要记录上一个数，上上个数，以及是否处于前导零状态。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">LL f[<span class="number">1010</span>][<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>];</span><br><span class="line">string l, r;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> le = x.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; le; i++)</span><br><span class="line">        <span class="keyword">if</span>(x[i] == x[i - <span class="number">1</span>] || (x[i] == x[i - <span class="number">2</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 不是</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> limit, <span class="type">bool</span> lead, <span class="type">int</span> pre, <span class="type">int</span> prpre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;now = f[pos][pre][prpre];</span><br><span class="line">    <span class="keyword">if</span>(~now &amp;&amp; !limit &amp;&amp; !lead &amp;&amp; pre != <span class="number">-1</span> &amp;&amp; prpre != <span class="number">-1</span>) <span class="keyword">return</span> now;</span><br><span class="line">    <span class="type">int</span> up = limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != pre &amp;&amp; i != prpre &amp;&amp; !lead)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res + <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, <span class="literal">false</span>, i, pre)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(lead)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res + <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, i == <span class="number">0</span>, ((i == <span class="number">0</span>) ? <span class="number">-1</span> : i), <span class="number">-1</span>)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; pre != <span class="number">-1</span> &amp;&amp; prpre != <span class="number">-1</span>) now = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(string x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    len = x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        a[i] = x[len - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    LL temp1 = <span class="number">0</span>, temp2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : l)</span><br><span class="line">    &#123;</span><br><span class="line">        temp1 = ((temp1 * <span class="number">10</span> % MOD) + i - <span class="string">&#x27;0&#x27;</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : r)</span><br><span class="line">    &#123;</span><br><span class="line">        temp2 = ((temp2 * <span class="number">10</span> % MOD) + i - <span class="string">&#x27;0&#x27;</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    LL temp = ((<span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l) + <span class="built_in">check</span>(l) + MOD) % MOD);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; solve(r) &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; temp &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; (((temp2 - temp1 + <span class="number">1</span>) % MOD - temp) % MOD + MOD) % MOD &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="6754"><a href="#6754" class="headerlink" title="6754"></a><a class="link"   href="https://www.luogu.com.cn/problem/P6754" >6754<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h3><p>上一道问题的子问题。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">22</span>];</span><br><span class="line">LL f[<span class="number">22</span>][<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> limit, <span class="type">bool</span> lead, <span class="type">int</span> pre, <span class="type">int</span> prpre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;now = f[pos][pre][prpre];</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; pre != <span class="number">-1</span> &amp;&amp; prpre != <span class="number">-1</span> &amp;&amp; ~now) <span class="keyword">return</span> now;</span><br><span class="line">    <span class="type">int</span> up = limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!lead &amp;&amp; i != pre &amp;&amp; i != prpre)</span><br><span class="line">            res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, <span class="literal">false</span>, i, pre);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(lead)</span><br><span class="line">            res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == up, i == <span class="number">0</span>, (i == <span class="number">0</span>) ? <span class="number">-1</span> : i, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; pre != <span class="number">-1</span> &amp;&amp; prpre != <span class="number">-1</span>) now = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++len] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="P3698"><a href="#P3698" class="headerlink" title="P3698"></a><a class="link"   href="https://www.luogu.com.cn/problem/P3698" >P3698<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>首先，这是棵树，对于这棵树我们进行 DFS，找到从根节点开始最长的一条链，如果可以就一直走这个链，如果有多的步数，我们在中间某个位置，每多花两步就可以多走一个点，注意与总点数取 min。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> fir[N];</span><br><span class="line"><span class="type">int</span> edcnt;</span><br><span class="line"><span class="type">int</span> m,n,maxdep;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt,to;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++edcnt].to=v;</span><br><span class="line">    e[edcnt].nxt=fir[u];</span><br><span class="line">    fir[u]=edcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    maxdep=<span class="built_in">max</span>(maxdep,dep);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u,dep<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=maxdep) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">min</span>(m,maxdep<span class="number">+1</span>+(n-maxdep)/<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="CF1872E"><a href="#CF1872E" class="headerlink" title="CF1872E"></a><a class="link"   href="https://codeforces.com/contest/1872/problem/E" >CF1872E<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>题意：</p>
<p>给定一个长度为 $n$ 的数组和一个长度为 $n$ 的二进制串 $s$，现有两个操作：</p>
<ol>
<li><code>1 l r</code>，表示将 $l \le i \le r$ 的所有 $s_i$ 取反（$0$ 变 $1$，$1$ 变 $0$）；</li>
<li><code>2 g</code>$(g\in {0,1})$，表示将所有 $s_i&#x3D;g$ 的 $a_i$ 求异或和；</li>
</ol>
<p>$1\le n\le 10^5,1\le t\le 10^4$.</p>
<p>首先记录下初始时所有 1 位置的异或和，记为 ans1，记录所有 0 位置的异或和，记为 ans0，然后对于每一个 1 操作，我们都要对 ans1 和 ans0 进行异或一个区间和，而这个区间和可以通过预处理前缀异或和来解决。</p>
<p>这里熟悉一下 bitset 的使用。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL ans0 = <span class="number">0</span>, ans1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n, q;</span><br><span class="line">        LL sum[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="type">int</span> a[N];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), sum[i] = sum[i - <span class="number">1</span>] ^ a[i];</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">bitset&lt;N&gt; <span class="title">a2</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = a<span class="number">2.</span>_Find_first(); i != a<span class="number">2.</span><span class="built_in">size</span>(); i = a<span class="number">2.</span>_Find_next(i))</span><br><span class="line">            ans1 ^= a[i + <span class="number">1</span>];</span><br><span class="line">        ans0 = sum[n] ^ ans1;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> op;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> l, r;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">                ans0 ^= sum[r] ^ sum[l - <span class="number">1</span>];</span><br><span class="line">                ans1 ^= sum[r] ^ sum[l - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">                <span class="keyword">if</span>(k == <span class="number">0</span>) cout &lt;&lt; ans0 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> cout &lt;&lt; ans1 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="推导-构造"><a href="#推导-构造" class="headerlink" title="推导 &amp; 构造"></a>推导 &amp; 构造</h1><h2 id="CF1862E"><a href="#CF1862E" class="headerlink" title="CF1862E"></a><a class="link"   href="https://codeforces.com/contest/1862/problem/E" >CF1862E<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>设他在 $i_1,i_2,i_3,\dots,i_k$ 这些天去看电影，那么得到的价值就是：</p>
<p>$$<br>\begin{gather}<br>a_{i_1}-d\cdot{i_1}+a_2-d\cdot(i_2-i_1)+\dots+a_{i_k}-d\cdot(i_k-i_{k-1})\&#x3D;(a_{i_1}+a_{i_2}+\dots+a_{i_k})-d\cdot{i_{k}}<br>\end{gather}<br>$$</p>
<p>所以就可以枚举最后一天去看的电影，然后记录前 $m-1$ 大的大于零的价值，用堆或者 <code>multiset</code> 维护即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a[N], ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; s;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cur = sum + a[i] - d * i;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cur);</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(&#123;a[i], i&#125;);</span><br><span class="line">                sum += a[i];</span><br><span class="line">                <span class="keyword">if</span>((<span class="type">int</span>)s.<span class="built_in">size</span>() &gt;= m)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum -= (*s.<span class="built_in">begin</span>()).first;</span><br><span class="line">                    s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="CF1860C"><a href="#CF1860C" class="headerlink" title="CF1860C"></a><a class="link"   href="https://codeforces.com/problemset/problem/1860/C" >CF1860C<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></h2><p>经典构造题。</p>
<p>我们为每个位置定义两种状态：必胜状态和必败状态；</p>
<ul>
<li>必胜状态：在它前面可以选择的状态都是必败状态。</li>
<li>必败状态：前面没有可以选择的状态或者前面存在可以选择的必胜状态。</li>
</ul>
<p>然后我们判断状态时只需要判断是否前面有最小的必胜状态即可，因为假如最小的必胜状态都大于当前状态，那么当前位置的前面不存在可选的必胜状态。</p>
<p>然后线性递推即可。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n; </span><br><span class="line">        <span class="type">int</span> p[N];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> w = n + <span class="number">1</span>, ww = n + <span class="number">1</span>; <span class="comment">// 可选状态 必胜状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(w &lt; p[i] &amp;&amp; p[i] &lt; ww) <span class="comment">// 前面有可选状态且没有必胜状态</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                ww = p[i]; <span class="comment">// 更新必胜状态的最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">            w = <span class="built_in">min</span>(w, p[i]); <span class="comment">// 更新可选状态的最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Problem</tag>
      </tags>
  </entry>
</search>
