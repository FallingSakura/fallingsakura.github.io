<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Programming, JavaScript, C++, Python, Computer Science, AI, Web, Knowledge, Blog"><meta name="author" content="Falling_Sakura"><script>(function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();</script><style>:root[data-theme=dark]{--background-color:#202124;--background-color-transparent:rgba(32, 33, 36, 0.6);--second-background-color:#2d2e32;--third-background-color:#34353a;--third-background-color-transparent:rgba(32, 33, 36, 0.6);--primary-color:#0066CC;--first-text-color:#ffffff;--second-text-color:#eeeeee;--third-text-color:#bebec6;--fourth-text-color:#999999;--default-text-color:#bebec6;--invert-text-color:#373D3F;--border-color:rgba(255, 255, 255, 0.08);--selection-color:#0066CC;--shadow-color-1:rgba(255, 255, 255, 0.08);--shadow-color-2:rgba(255, 255, 255, 0.05)}:root[data-theme=light]{--background-color:#fff;--background-color-transparent:rgba(255, 255, 255, 0.6);--second-background-color:#f8f8f8;--third-background-color:#f2f2f2;--third-background-color-transparent:rgba(241, 241, 241, 0.6);--primary-color:#0066CC;--first-text-color:#16171a;--second-text-color:#2f3037;--third-text-color:#5e5e5e;--fourth-text-color:#eeeeee;--default-text-color:#373D3F;--invert-text-color:#bebec6;--border-color:rgba(0, 0, 0, 0.08);--selection-color:#0066CC;--shadow-color-1:rgba(0, 0, 0, 0.08);--shadow-color-2:rgba(0, 0, 0, 0.05)}body{background-color:var(--background-color);color:var(--default-text-color)}:root[data-theme=dark] body{background-color:var(--background-color);color:var(--default-text-color)}</style><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="canonical" href="http://vercel.fallingsakura.top/915ab73.html"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:type" content="article"><meta property="og:title" content="NOIP-数学"><meta property="og:url" content="http://vercel.fallingsakura.top/915ab73.html"><meta property="og:site_name" content="Falling Blog"><meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:locale" content="en_US"><meta property="og:image" content="http://vercel.fallingsakura.top/images/redefine-og.webp"><meta property="article:published_time" content="2023-04-29T00:03:50.000Z"><meta property="article:modified_time" content="2025-09-24T02:07:14.374Z"><meta property="article:author" content="Falling_Sakura"><meta property="article:tag" content="Programming, JavaScript, C++, Python, Computer Science, AI, Web, Knowledge, Blog"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://vercel.fallingsakura.top/images/redefine-og.webp"><link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/favicon.ico" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/favicon.ico"><meta name="theme-color" content="#EE9CA7"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/favicon.ico"><title>NOIP-数学 | Falling Blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fonts/Chillax/chillax.css"><link rel="stylesheet" href="https://lib.baomitu.com/KaTeX/latest/katex.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/css/build/tailwind.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fonts/Geist/geist.css"><link href="/custom/fonts.css" rel="stylesheet"><link href="/custom/fonts.css" rel="stylesheet"><link href="" rel="stylesheet"><link href="" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/anime.min.js"></script><script id="hexo-configurations">window.config={hostname:"vercel.fallingsakura.top",root:"/",language:"en",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"2.2rem",h2:"2rem",h3:"1.8rem",h4:"1.6rem",h5:"1.5rem",h6:"1.4rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!1,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"atom-one-light",dark:"atom-one-dark"},font:{enable:!0,family:"Fira",url:"/custom/fonts.css"}},toc:{enable:!0,max_depth:3,number:!0,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!1,recommendation:{enable:!1,title:"Recommendation",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#EE9CA7",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!0,family:"Noto Sans SC",url:null},english:{enable:!0,family:"Ubuntu Mono",url:null},title:{enable:!1,family:null,url:null}},content_max_width:"950px",sidebar_width:"200px",hover:{shadow:!0,scale:!0},scroll_progress:{bar:!0,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!0,custom_message:null},side_tools:{gear_rotation:!0,auto_expand:!1},open_graph:{enable:!0,image:"/images/redefine-og.webp",description:"Hexo Theme Redefine, Redefine Your Hexo Journey."},google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202309291412615.webp",dark:"https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202309291412607.webp"},title:"Falling Blog",subtitle:{text:[],hitokoto:{enable:!1,show_author:!1,api:"https://v1.hitokoto.cn"},typing_speed:80,backing_speed:120,starting_delay:500,backing_delay:2e3,loop:!0,smart_backspace:!0},text_color:{light:"#fafafa",dark:"#d76694"},text_style:{title_size:"4.6rem",subtitle_size:"1.5rem",line_height:1.8},custom_font:{enable:!0,family:"Kaushan Script",url:"/custom/fonts.css"},social_links:{enable:!0,style:"default",links:{github:"https://github.com/FallingSakura",instagram:null,zhihu:"https://www.zhihu.com/people/fsimh",twitter:"https://x.com/SakuraFalling1",email:"mailto:dbw1732351264@163.com"},qrs:{weixin:"https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202309291446101.webp",qq:"https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202309291451534.webp"}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:"METHOD_HYMME_AMENOFLAME/.",artist:"stellatram",url:"https://music.163.com/song/media/outer/url?id=471403213.mp3",cover:"https://p3.music.126.net/cPwdlJxGCtX0e2L3SMQksg==/18915998044327357.jpg",lrc:null},{name:"忘れじの言の葉 - 安次嶺希和子",artist:"安次嶺希和子",url:"https://music.163.com/song/media/outer/url?id=432698934.mp3",cover:"https://p3.music.126.net/EnzRjx6TAtWsVKohfRm99w==/1373290038991137.jpg"},{name:"夜街，骤雨和启明星",artist:"鹤见江野",url:"https://music.163.com/song/media/outer/url?id=1429787173.mp3",cover:"https://p3.music.126.net/JOM1EU4wNWyLqpPA3GLTqQ==/109951164789573814.jpg"},{name:"海森堡童话",artist:"Strictlyviolin荀博 / 王朝",url:"https://music.163.com/song/media/outer/url?id=2008978774.mp3",cover:"https://p4.music.126.net/hSM0qHLHuYT388Xm1qJ9dw==/109951168171015319.jpg"},{name:"幽雅に咲かせ、墨染の桜 ~ Border of Life",artist:"ファクトリー・ノイズ&AG",url:"https://music.163.com/song/media/outer/url?id=732206.mp3",cover:"https://p4.music.126.net/m8W2vORGGnzgFRrh4PYmzg==/648711860399964.jpg"}]},mermaid:{enable:!0,version:"11.4.1"}},version:"2.8.5",navbar:{auto_hide:!1,color:{left:"#78617d",right:"#b2a1ef",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},Categories:{path:"/categories",icon:"fa-regular fa-folder"},About:{icon:"fa-regular fa-user",path:"/about"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:"Nothing for nothing.",show_on_mobile:!0,links:{Archives:{path:"/archives",icon:"fa-regular fa-archive"},Tags:{path:"/tags",icon:"fa-regular fa-tags"},Links:{path:"/friends",icon:"fa-regular fa-link"},Essays:{path:"/essays",icon:"fa-regular fa-message-heart"},Photos:{path:"/gallery",icon:"fa-regular fa-images"}}},article_date_format:"auto",excerpt_length:80,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2023/2/19 11:45:14"},window.lang_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},window.data={masonry:!0}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fontawesome/brands.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fontawesome/solid.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fontawesome/regular.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/fontawesome/sharp-solid.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span></div><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><h2 class="ml13">Falling Blog</h2><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({ loop: true })
            .add({
                targets: '.ml13 .letter',
                translateY: [20, 0],
                translateZ: 0,
                opacity: [0, 1],
                filter: ['blur(5px)', 'blur(0px)'],
                easing: "easeOutExpo",
                duration: 1200,
                delay: (el, i) => 300 + 20 * i,
            })
            .add({
                targets: '.ml13 .letter',
                translateY: [0, -20],
                opacity: [1, 0],
                filter: ['blur(0px)', 'blur(5px)'],
                easing: "easeInExpo",
                duration: 1000,
                delay: (el, i) => 15 * i,
                complete: function() {
                    hidePreloader();
                }
            }, '-=700');


        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }</script></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">Falling Blog</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> HOME</a></li><li class="navbar-item"><a href="/categories"><i class="fa-regular fa-folder fa-fw"></i> CATEGORIES</a></li><li class="navbar-item"><a href="/about"><i class="fa-regular fa-user fa-fw"></i> ABOUT</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>HOME </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories"><span>CATEGORIES </span><i class="fa-regular fa-folder fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/about"><span>ABOUT </span><i class="fa-regular fa-user fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/archives"><span>Archives</span> <i class="fa-regular fa-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags"><span>Tags</span> <i class="fa-regular fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/friends"><span>Links</span> <i class="fa-regular fa-link fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/essays"><span>Essays</span> <i class="fa-regular fa-message-heart fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/gallery"><span>Photos</span> <i class="fa-regular fa-images fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">22</div><div class="label text-third-text-color text-sm">Tags</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">9</div><div class="label text-third-text-color text-sm">Categories</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">33</div><div class="label text-third-text-color text-sm">Posts</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">NOIP-数学</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="https://cdn.jsdelivr.net/gh/FallingSakura/Source@main/img/202305211656851.webp"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Falling_Sakura</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2023-04-29 08:03:50</span> <span class="mobile">2023-04-29 08:03:50</span> <span class="hover-info">Created</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-09-24 10:07:14</span> <span class="mobile">2025-09-24 10:07:14</span> <span class="hover-info">Updated</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/OI/">OI</a>&nbsp;</li><li>| <a href="/categories/Note/">Note</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>17.8k Words</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>75 Mins</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h1 id="基础数学"><a href="#基础数学" class="headerlink" title="基础数学"></a>基础数学</h1><h2 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h2><p>一张图搞懂取模：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202309301506245.webp" alt="image.png|400"></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">cout&lt;&lt;(a+b)%c&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;((a-b)%c+c)%c&lt;&lt;endl;<span class="comment">//负数取模</span></span><br><span class="line">cout&lt;&lt;(<span class="number">1ll</span>*a*b)%c&lt;&lt;endl;<span class="comment">//防止爆int的两种方法</span></span><br><span class="line">cout&lt;&lt;((<span class="type">long</span> <span class="type">long</span>)a*b)%c&lt;&lt;endl;</span><br></pre></td></tr></table></figure></div><p>数学和计算机中的取模实现方式不同，对于正数，两种方式得到的答案一样，但是对于负数却不同。</p><p>对于下面例子：</p><p>$-3 \bmod 2$</p><p>数学得到的答案是：$-3 - \lfloor{-3 &#x2F; 2}\rfloor \times 2 &#x3D; 1$</p><p>计算机得到的答案是：$-3 - (-3 &#x2F; 2) \times 2 &#x3D; -1$</p><p>故计算机对负数取模的时候，需要 $((-3 \bmod 2) + 2)\bmod 2$</p><p>通过规律我们发现，当被模数为正数时，答案是非负数；模数为负数时，答案是非正数。</p><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><p><em>n的阶乘：</em></p><p>$n! &#x3D;n\times{(n-1)}\times{(n-2)}\times\ldots\times1$</p><p><strong>n!%p</strong></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,p;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans*=i;</span><br><span class="line">        ans%=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><em>典型的错误写法：</em></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290904698.webp" alt="image.png|600"></p><h2 id="GCD-LCM"><a href="#GCD-LCM" class="headerlink" title="GCD&amp;LCM"></a>GCD&amp;LCM</h2><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290908493.webp" alt="image.png|600"></p><p><del>太熟悉了</del></p><p>求一下gcd</p><p>设$gcd(a,b)&#x3D;g$</p><p><strong>整除</strong>：$g|a$ $g$ 能整除 $a$ $a\pmod g&#x3D;0$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290913704.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290917006.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290918595.webp" alt="image.png|600"></p><p>$$gcd(a,b)&#x3D;gcd(b,a%b)$$</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;<span class="comment">//任何数和0的最大公因数为自身</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290925998.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290928411.webp" alt="image.png|600"></p><p>1.$b \le \frac a 2$时，$a% b \le \frac a 2$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290929042.webp" alt="image.png|600"><br>wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww<br>2.$b \ge \frac a 2$时，$a% b &#x3D;a-b \le \frac a 2$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304290929060.webp" alt="image.png|600"></p><p>所以$a%b&lt;\frac1 2 a$</p><p>复杂度？</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="type">int</span> ans=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">gcd</span>(ans,a[i]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br></pre></td></tr></table></figure></div><p>$O(n+log_{a_{max}})$</p><p>$ans$只会不断变小</p><p>除$2$的次数只有$log$次</p><hr><p>若$gcd(a,b)&#x3D;g,lcm(a,b)&#x3D;l$</p><p>$l&#x3D;a*b&#x2F;g$</p><p><em>小寄巧</em>：$a * b &#x2F; gcd(a,b) \to a &#x2F; gcd(a,b) *b$</p><p>先除后乘防止爆</p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>$x^{y} % p$</p><p><em>朴素的代码：</em></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y;i++)</span><br><span class="line">        ans=<span class="number">1ll</span>*ans*x%p;</span><br></pre></td></tr></table></figure></div><p>比如现在要算$x^{37}$</p><p>需要乘$36$次</p><p>$x^{37}$$&#x3D;x^{18^2}\cdot x$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291007280.webp" alt="image.png|600"></p><p>时间复杂度就是$O(log_n)$</p><p>可以递归求解</p><p><em>朴素的代码：</em></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> z=<span class="built_in">ksm</span>(x,y/<span class="number">2</span>,p);</span><br><span class="line">    z=<span class="number">1ll</span>*z*z%p;</span><br><span class="line">    <span class="keyword">if</span>(y%<span class="number">2</span>==<span class="number">1</span>) z=<span class="number">1ll</span>*z*x%p;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>优化</strong></p><p>位运算： <code>if(y&amp;1) z=1ll*z*x%p;</code></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) res = res * x % p;</span><br><span class="line">        x = x * x % p;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><p>小题目:$x,y,p$,算$x*y%p$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291021157.webp" alt="image.png|600"></p><h2 id="快速乘法"><a href="#快速乘法" class="headerlink" title="快速乘法"></a>快速乘法</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kscf</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> z=<span class="built_in">kscf</span>(x,y/<span class="number">2</span>,p);</span><br><span class="line">    z=(z+z)%p;</span><br><span class="line">    <span class="keyword">if</span>(y&amp;<span class="number">1</span>) z=(z+x)%p;<span class="comment">//判奇</span></span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><blockquote><p>n行m列的一个东西</p></blockquote><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291041588.webp" alt="image.png|600"></p><p>两个矩阵做<strong>加法</strong>的条件是两个矩阵的大小一样</p><p>做法:</p><p>对应位置的数字加起来</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291042209.webp" alt="image.png|600"></p><p><strong>减法</strong>同理:</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291043292.webp" alt="image.png|600"></p><p><strong>数乘</strong>:</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291044900.webp" alt="image.png|600"></p><p><strong>矩阵乘法</strong>:</p><p>$$<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6 \<br>7 &amp; 8 &amp; 9 \<br>\end{bmatrix}<br>$$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291048242.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291048036.webp" alt="image.png|600"></p><p>$$\begin{bmatrix}1 &amp; 2 \3 &amp; 4 \ \end{bmatrix}\times \begin{bmatrix}1&amp;2&amp;3 \ 2 &amp; 3 &amp; 3\ \end{bmatrix}&#x3D;\begin{bmatrix}5&amp;8&amp;9\11&amp;18&amp;21\ \end{bmatrix}$$</p><p>第一个的列数 &#x3D; 第二个的行数</p><p>第一行第一列，取出第一个的第一行，第二个的第一列</p><p>一一相乘再相加</p><p><strong>代码实现</strong>:</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">int</span> z[<span class="number">23</span>][<span class="number">23</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291059199.webp" alt="image.png|600"></p><p>$z$数组不一定为$0$(受很多因素影响)</p><p><strong>构造函数</strong></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">int</span> z[<span class="number">23</span>][<span class="number">23</span>];</span><br><span class="line">    <span class="built_in">matrix</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(z,<span class="number">0</span>,<span class="built_in">sizeof</span>(z));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p><strong>重载运算符</strong></p><p>不会影响正常的$*$</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix <span class="keyword">operator</span>*(matrix m1,matrix m2)</span><br></pre></td></tr></table></figure></div><p><em>这样写有没有什么问题？</em></p><p>涉及到一个传参的问题：</p><p>为了<strong>避免占空间</strong>，可以这样写:</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix <span class="keyword">operator</span>*(matrix &amp;m1,matrix &amp;m2)</span><br></pre></td></tr></table></figure></div><p>为了<strong>避免算出结果以后原值被修改</strong>，可以这样写：</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix <span class="keyword">operator</span>*(<span class="type">const</span> matrix &amp;m1,<span class="type">const</span> matrix &amp;m2)</span><br></pre></td></tr></table></figure></div><p>接下来是<strong>矩阵乘法</strong>的函数内容了</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">matrix <span class="keyword">operator</span>*(<span class="type">const</span> matrix &amp;m1,<span class="type">const</span> matrix &amp;m2)</span><br><span class="line">&#123;</span><br><span class="line">    matrix m3;</span><br><span class="line">    m<span class="number">3.</span>n=m<span class="number">1.</span>n;</span><br><span class="line">    m<span class="number">3.</span>m=m<span class="number">2.</span>m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m<span class="number">3.</span>n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m<span class="number">3.</span>m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m<span class="number">1.</span>m;k++)</span><br><span class="line">                m<span class="number">3.</span>z[i][j]+=m<span class="number">1.</span>z[i][k]*m<span class="number">2.</span>z[k][j];</span><br><span class="line">    <span class="keyword">return</span> m3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><em>糟糕的复杂度:</em>$O(n^3)$ 可处理百位(100~200)级别的矩阵乘法</p><p>小题题：<a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3390">P3390矩阵快速幂<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p><strong>memset</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291122556.webp" alt="image.png|600"></p><p><strong>ijk</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291127728.webp" alt="image.png|600"></p><p><strong>jki</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291128426.webp" alt="image.png|600"></p><p><strong>kji</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291128497.webp" alt="image.png|600"></p><p><strong>ikj</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291130768.webp" alt="image.png|600"></p><p>枚举顺序会影响时间复杂度？</p><p>把$j$放在最后是最快的</p><p>原因是<strong>缓存机制</strong></p><p>缓存很小，但是很快</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291407593.webp" alt="image.png|600"></p><p>连续性越高，也就越快</p><p>尽可能让最后一维作为循环变量，以最大化利用缓存</p><p>$j$全部在第二维，最优</p><p>$k$只有一个在第二维，次优</p><p>$i$没有在第二维，最不优</p><p>相当于先处理答案矩阵的第一行，对第一行扫 k 遍便是结果，</p><ul><li>处理答案矩阵的第一行<ul><li>第一个矩阵的第一行的任何一个数都要被加一遍，第二个矩阵的第一列</li></ul></li></ul><p>来个<strong>小练习题</strong>：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291412157.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291413134.webp" alt="image.png|600"></p><p>求$f_n%p$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291417988.webp" alt="image.png|600"></p><p><del>暴力的写法</del></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c=a+b;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=p) c-=p;</span><br><span class="line">        a=b;</span><br><span class="line">        b=c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>$$\begin{bmatrix}f_{i-1}&amp;f_{i-2} \end{bmatrix}\times\begin{bmatrix}1&amp;1\1&amp;0\end{bmatrix}&#x3D;\begin{bmatrix}f_i&amp;f_{i-1}\end{bmatrix}$$</p><p>这样推$n$次就可以得到第$n$项</p><p>但是还不如直接算</p><p>怎么优化？</p><p>矩阵乘法也有结合律</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291426869.webp" alt="image.png|600"></p><p>这个东西是不是很眼熟</p><p>对于$B^n$可以进行一个[[NOIP-数学#快速幂|快速幂]]</p><p>小题题<a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1962">P1962斐波那契数列<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">matrix A,B;</span><br><span class="line">    A.n=<span class="number">1</span>;A.m=<span class="number">2</span>;</span><br><span class="line">    A.z[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    A.z[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    B.n=<span class="number">2</span>;B.m=<span class="number">2</span>;</span><br><span class="line">    B.z[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    B.z[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    B.z[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    B.z[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    matrix C=A*<span class="built_in">jzksm</span>(B,n);</span><br><span class="line">    <span class="type">int</span> ans=C.z[<span class="number">1</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure></div><p>复杂度:$log_n$</p><p>虽然矩阵乘法是$O(n^3)$,但是$B$矩阵是个$2 \times 2$的，$2^3$也就是$8$，可忽略</p><p>矩阵$B$是怎么来的呢？</p><p><strong>小栗子</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291437263.webp" alt="image.png|600"></p><p>找到能够向后推一项的矩阵</p><p>$$\begin{bmatrix}f_{i-1}&amp;f_{i-2} \end{bmatrix}\times\begin{bmatrix}3&amp;1\-2&amp;0\end{bmatrix}&#x3D;\begin{bmatrix}f_i&amp;f_{i-1}\end{bmatrix}$$</p><p><strong>目的</strong>:向后推一项</p><p><strong>再来一个栗子</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291440792.webp" alt="image.png|600"></p><p>刚才矩阵大小为$2$因为这一项的信息只与<strong>前两项</strong>有关</p><p>而这个却与前三项有关</p><p>$$\begin{bmatrix}f_{i-1}&amp;f_{i-2}&amp;f_{i-3}\end{bmatrix}\times\begin{bmatrix}1&amp;0&amp;1\1&amp;0&amp;0 \0&amp;1&amp;0 \end{bmatrix}&#x3D;\begin{bmatrix}f_{i}&amp;f_{i-1}&amp;f_{i-2}\end{bmatrix}$$</p><p>和前面几项有关，那么矩阵大小就是几</p><p>矩阵乘法有交换律吗？</p><p><strong>no</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291501408.webp" alt="image.png|600"><br>补充：</p><p>矩阵快速幂加速递推的底层原理想了一会，觉得它跟正常的快速幂是一个原理，都是通过减少运算（递推）次数来减少运行时间。</p><p><strong>又是一个<del>小</del>大栗子</strong></p><blockquote><p>以下仅为简要写法，具体题解请见<a class="link" target="_blank" rel="noopener" href="https://white.fallingsakura.top/59e59239/">P4159 迷路<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p></blockquote><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291505595.webp" alt="image.png|600"></p><p>$n \le 100$</p><p>$k\le$ $10^9$</p><p>邻接矩阵存图</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291509604.webp" alt="image.png|600"></p><p>$f[i][j]$代表走了$i$步到达$j$的方案数</p><p>初始化：</p><p>$f[0][1]&#x3D;1$</p><p>$f[0][{2\sim n}]&#x3D;0$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291513293.webp" alt="image.png|600"></p><p>代码中可以出现相同变量名，前提是它们的作用域不同。</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291518261.webp" alt="image.png|600"></p><p>如何精确访问？</p><p><code>::a</code>代表访问全局变量</p><p>正常的DP写法：</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">           cin&gt;&gt;z[i][j];</span><br><span class="line">   <span class="comment">//z[i][j]=0/1;i-&gt;j</span></span><br><span class="line">   f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=k;a++)<span class="comment">//走了a步</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)<span class="comment">//走到了b</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">1</span>;c&lt;=n;c++)<span class="comment">//第a-1步在c</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(z[c][b]==<span class="number">1</span>) f[a][b]+=f[a<span class="number">-1</span>][c];<span class="comment">//如果有边</span></span><br><span class="line">           &#125;</span><br><span class="line">   ans=f[k][n];<span class="comment">//走k步到n</span></span><br></pre></td></tr></table></figure></div><p>$O(n^3)$复杂度肯定过不了</p><p>优化一下：</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if(z[c][b]=1) f[a][b]+=f[a-1][c];</span></span><br><span class="line">        f[a][b]+=f[a<span class="number">-1</span>][c]*z[c][b];</span><br></pre></td></tr></table></figure></div><p><strong>解释：</strong>$c \to b$有边的时候，$z[c][b]&#x3D;1$ 就相当于转移</p><p>$c \to b$没有边的时候，$z[c][b]&#x3D;0$，就相当于加上$0$</p><p>那这样做有什么用呢？ <em>——别急，往下看</em></p><p>升一下维度，中间始终为$1$</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">           cin&gt;&gt;z[i][j];</span><br><span class="line">   <span class="comment">//z[i][j]=0/1;//i-&gt;j</span></span><br><span class="line">   f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=k;a++)<span class="comment">//走了a步</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">1</span>;d&lt;=<span class="number">1</span>;d++)<span class="comment">//无意义</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)<span class="comment">//走到了b</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">1</span>;c&lt;=n;c++)<span class="comment">//第a-1步在c</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// if(z[c][b]=1) f[a][b]+=f[a-1][c];</span></span><br><span class="line">                   f[a][d][b]+=f[a<span class="number">-1</span>][d][c]*z[c][b];</span><br><span class="line">               &#125;</span><br><span class="line">   ans=f[k][<span class="number">1</span>][n];</span><br></pre></td></tr></table></figure></div><p>加维度、把判断变为相乘的目的就是为了<strong>把形式凑成矩阵乘法</strong></p><p>$f[i][j][k]$$DP$意义实际上就是以$j$为起点，走了$i$步到达点$k$的方案数,只不过这里的起点是$1$</p><p>把$f[a]$当作变量</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291531519.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291532228.webp" alt="image.png|600"></p><p>然后用下矩阵快速幂就搞定了</p><p>%% #Q： 但是 Z 这个数组时时刻刻在变化啊 %%</p><p>$O(n^{3\times}log k)$</p><p><strong>小问题</strong><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4159">P4159<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291542660.webp" alt="image.png|600"></p><p>$1 \le$ 边权 $\le 9$</p><p>拆！</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291543666.webp" alt="image.png|600"></p><p>尽量少拆</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291549120.webp" alt="image.png|600"></p><p>最多延申九个点，加上原来的点，最多十个点</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291552458.webp" alt="image.png|600"></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        z[i][n+(i<span class="number">-1</span>)*<span class="number">9</span><span class="number">+1</span>]=<span class="number">1</span>;<span class="comment">//链</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;<span class="number">9</span>;j++)<span class="comment">//n之外点的相互连边</span></span><br><span class="line">        &#123;</span><br><span class="line">            z[n+(i<span class="number">-1</span>)*<span class="number">9</span>+j][n+(i<span class="number">-1</span>)*<span class="number">9</span>+j<span class="number">+1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291603778.webp" alt="image.png|600"></p><p>最终建出的图：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291956964.webp" alt="graph.png|700"></p><p>（距离为9的最后一个节点其实没有必要）</p><p>由图可知，这个矩阵<strong>长度和宽度是十倍的n</strong></p><p>第一步是指$1\to n$</p><p>第二步是指$n+1 \to n+2 \to n+3 \ldots$</p><p>假设$n&#x3D;5$</p><p>加入对$1\to 4$有一条长度为$6$的边，那么就是：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291959263.webp" alt="graph (1).png|700"></p><p>假如是$3\to 5$长度为$9$</p><p>那么就是：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304292001831.webp" alt="graph (2).png|700"></p><p>对长度为$1$特判一下,直接连边</p><p>对长度为$0$特判一下，直接<code>continue</code></p><p>假如$2 \to 4$长度为$1$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304292021848.webp" alt="graph (3).png|700"></p><h1 id="初等数论"><a href="#初等数论" class="headerlink" title="初等数论"></a>初等数论</h1><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><blockquote><p>研究范围：正整数</p><p>素数:只有两个因子</p></blockquote><p>除了质数就是 <code>和数</code> 和 <code>1</code></p><p>如何判断$x$是不是质数</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291616963.webp" alt="image.png|600"></p><p>有可能$x$是$1$或$0$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291617098.webp" alt="image.png|600"></p><hr><p>一个数的因子一定都是成对出现的</p><p>$x&#x3D;a\cdot b$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291619810.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291619096.webp" alt="image.png|600"></p><p>所以只需要枚举前根号个即可，大于 $\sqrt{x}$ 的质因子最后处理一下就可以了。</p><p>为什么没有两个大于 $\sqrt{x}$ 的质因子出现？</p><p>反证法：假如有，那么它们的乘积已经大于了 x，所以不存在。</p><p><strong>典型错误</strong>：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291620535.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291622907.webp" alt="image.png|600"></p><p><em>这样会很man</em></p><p>因为每次都会重新调用一遍函数</p><p>修改：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304291626807.webp" alt="image.png|600"></p><p>x最大只能到$x^{16}$</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">2</span>;a*a&lt;=x;a++)</span><br><span class="line">    <span class="keyword">if</span>(x%a==<span class="number">0</span>)<span class="comment">//第一个质因子,每次进来都一定是一个质因子</span></span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        prime[cnt]=a;</span><br><span class="line">        <span class="keyword">while</span>(x%a==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num[cnt]++;</span><br><span class="line">            x/=a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(x!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    prime[cnt]=x;</span><br><span class="line">    num[cnt]=<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>小练习:<strong>CF45G</strong></p><p><strong>哥德巴赫猜想</strong>：</p><p><em>始终不会超过三组</em></p><p>对于任何一个大于等于4的偶数，一定可以拆成两个质数之和</p><p>任何一个大于等于7的奇数，一定可以拆成三个质数之和</p><p>加和算出来是$x$</p><p>如果$x$是偶数，那么就是$2$组，</p><p>如果$x$是奇数，那么肯定小于$3$组</p><p>$x$本身是质数时答案为$1$组</p><p>剩下情况答案要么为$2$组，要么为$3$组</p><p>一个奇数可以看成一个奇数和一个偶数的和</p><p>若$x-2$是质数，那么就是$2$组，否则就可以拆成$3$组</p><h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><h3 id="逆元的引入"><a href="#逆元的引入" class="headerlink" title="逆元的引入"></a>逆元的引入</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300831974.webp" alt="image.png|600"></p><p>算完取模：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300833180.webp" alt="image.png|600"></p><p>边算边取模：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300834493.webp" alt="image.png|600"></p><p>理论上吧来说它也应该等于$2$</p><p>现在想计算$a \div b%p$</p><p>现在要把</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300836655.webp" alt="image.png|600"></p><p>如果能找到这个 $c$</p><p>$c$也就是 $\frac 1 b$</p><p>那么$c$就是$b$的逆元</p><p>我们想用一个乘法来替代除法</p><hr><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>当$p$是<strong>质数</strong>并且$1\le a &lt; p$</p><p>那么一定有</p><p>$$<br>a^{p-1}\bmod p\equiv1<br>$$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300839102.webp" alt="image.png|600"></p><p>$$<br>a^{p-1}\equiv 1 \pmod p<br>$$</p><p>这也就是<strong>费马小定理</strong></p><p>两边同除$a$</p><p>$$<br>a^{p-2}\equiv \frac 1 a \pmod p<br>$$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300844814.webp" alt="image.png|600"></p><p>四分之一模$p$就是$4^{p-2}%p$</p><p>$$a\div b %p &#x3D;a\times b^{p-2}% p$$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/20230430092107.webp" alt="image.png|600"></p><p>那么$b$的$p-2$次方就可以用[[#快速幂|快速幂]]来求了</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300848556.webp" alt="image.png|600"></p><p>第一个条件是$p$<strong>是质数</strong></p><p><del>第二个是a大于等于1小于p</del>（$a$也可以比$p$大，因为一模$p$就肯定比$p$小了，只要它们<strong>互质</strong>就可以）</p><p>假如a&gt;p，a与p互质，那么a%p还与p互质吗</p><p>依然互质，这不就是辗转相除法么</p><p>$gcd(a,p)&#x3D;1 \to gcd(p,a%p)&#x3D;1$</p><p>所以第二个条件是$gcd(a,p)&#x3D;1$,也就是$a$和$p$互质</p><p><strong>互质的概念</strong>：两个数的公因数只有1</p><p>那假如$p$不是质数怎么办</p><p>新定理：<strong>欧拉定理</strong></p><h3 id="欧拉定理-欧拉函数"><a href="#欧拉定理-欧拉函数" class="headerlink" title="欧拉定理&amp;欧拉函数"></a>欧拉定理&amp;欧拉函数</h3><p>使用条件：$gcd(a,p)&#x3D;1$</p><p>$$<br>a^{\varphi(p)}\equiv1\pmod p<br>$$</p><p>$\varphi(p)$为欧拉函数</p><p><strong>定义</strong>：一到$p$中有多少个数与$p$互质</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300854015.webp" alt="image.png|600"></p><p>$\varphi (4)\to$ 1 3<br>$\varphi (6)\to$ 1 5</p><p>和上面同理，两边同时除以$a$</p><p>$$<br>a^{\varphi (p)-1}\equiv \frac 1 a \pmod p<br>$$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300857708.webp" alt="image.png|600"></p><p>当$p$是质数的时候，$\varphi (p)&#x3D;p-1$</p><p>$$<br>a \div b \bmod p&#x3D;a \times \frac 1 b \bmod p&#x3D;a \times b^{\varphi(p)-1} \bmod p &#x3D; a \times b^{p-2} \bmod p<br>$$</p><p>$a$和$p$不互质的时候，<strong>以上两种定理是不成立的，此时逆元不存在</strong></p><p>这个时候我们认为这个用逆元是算不出来的</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300900691.webp" alt="image.png|600"></p><p>接下来问题来了，$\varphi (n)$怎么算呢</p><p>假设$n&#x3D;p_1$</p><p>假设$p_1$是个质数，这时候$\varphi (n)&#x3D;p-1$</p><p>假设$n&#x3D;p_1^2$?</p><p>$p_1$的倍数都和$p_1$都不互质</p><p>一共有$p_1$个数和$n$不互质</p><p>那么$\varphi(n)$就是 ${p_{1}^2}-p_1&#x3D;p_1 \times (p1-1)$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300905869.webp" alt="image.png|600"></p><p>那么假设为$p^k$时，每$p_1$个数就刚好有一个是$p_1$的倍数</p><p>那么每$p_1$个数就有$p_1-1$个与$n$互质的</p><p>一共有$n$个数</p><p>所以$\varphi(n)&#x3D;\frac n p_{1} \cdot (p_1-1)$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300908200.webp" alt="image.png|600"></p><hr><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300911470.webp" alt="image.png|600"></p><p>假设$n&#x3D;p_{1}\times p_2$</p><p>$\varphi(n)&#x3D;n- \frac n {p_{1}} - \frac n {p_{2}} + \frac n {p_{1}\times p_2}$</p><p>解释一下，这个式子就是总共有$n$个数，每$p_1$个数就会出现一个不与$n$互质的数（$p_1$的倍数），每$p_2$个数就会出现一个不与$n$互质的数（$p_2$的倍数），减去不互质的数剩下的就是互质的数，我们发现每$p_{1}\times p_2$个数就会出现一个不与n互质的数且为$p_{1}\times p_2$的倍数（其实就是$n$），这个数被删了两次，所以要加回来一次</p><p>提取一个$n$出来</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300913285.webp" alt="image.png|600"></p><p>因式分解：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300912307.webp" alt="image.png|600"></p><p>我们发现：</p><p>当$n&#x3D;p_1^{k_1}\cdot p_2^{k_2}\cdot p_3^{k_3}\dots\cdot p_t^{k_t}$时($p$都是质数)(无论$n$为何值，一定能凑成几个质因数幂的乘积的形式——质因数分解)</p><p>📜 $\varphi(n)&#x3D;n\cdot (1-\frac 1 {p_1})(1-\frac 1 {p_2})(1-\frac 1 {p_3})\dots(1-\frac 1 {p_t})$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300913014.webp" alt="image.png|600"></p><p><strong>根据容斥原理</strong></p><p><strong>现在要找的就是$n$的每个质因子,几次不用管</strong></p><p>正确性的话，举几个例子就行了，毕竟，<del>OI不需要证明</del></p><p><strong>先除再乘防止范围炸掉</strong></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> phi = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)<span class="comment">//质因子,证明见[质因数分解]</span></span><br><span class="line">        &#123;</span><br><span class="line">            phi=phi/i*(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n=n/i;<span class="comment">//把i的几次方全部去掉</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>)<span class="comment">//最后一个质数是n，如果是n的很多次方，循环不会停止</span></span><br><span class="line">        phi=phi/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> phi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="小问题：求n个数的逆元"><a href="#小问题：求n个数的逆元" class="headerlink" title="小问题：求n个数的逆元"></a>小问题：求n个数的逆元</h3><h4 id="阶乘的做法"><a href="#阶乘的做法" class="headerlink" title="阶乘的做法"></a>阶乘的做法</h4><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300921125.webp" alt="image.png|600"></p><p>最简单的做法：<em>枚举一下</em></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300922921.webp" alt="image.png|600"></p><p>这么做的复杂度是$O(nlogn)$的，但是$n$比较大</p><p>先算出$1$到$n$每个数的阶乘算下来</p><p>只需要算$n！$的逆元</p><p>$n$的逆元也就是$\frac 1 n$(模意义下)</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300930964.webp" alt="image.png|600"></p><p>每个数的阶乘分之$1$，从右往左推</p><p>再相乘，就求得逆元</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300935335.webp" alt="image.png|600"></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------------*/</span></span><br><span class="line">   fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//1</span></span><br><span class="line">   &#123;</span><br><span class="line">       fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">   &#125;</span><br><span class="line">   ifac[n]=<span class="built_in">ksm</span>(fac[n],p<span class="number">-2</span>,p);<span class="comment">//算n的阶乘的逆元</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//2</span></span><br><span class="line">   &#123;</span><br><span class="line">       ifac[i]=<span class="number">1ll</span>*ifac[i<span class="number">+1</span>]*(i<span class="number">+1</span>)%p;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//3</span></span><br><span class="line">   &#123;</span><br><span class="line">       inv[i]=fac[i<span class="number">-1</span>]*ifac[i]%p;<span class="comment">//除以i的阶乘也就是乘以i的阶乘的逆元</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*-------------------*/</span></span><br></pre></td></tr></table></figure></div><p>复杂度为$O(n)$</p><p>这是第一种方法</p><h4 id="正推"><a href="#正推" class="headerlink" title="正推"></a>正推</h4><p>首先$1$的逆元就是$1$</p><p>假设从左向右一个一个求</p><p>当我要求$i$这个数的时候</p><p>那么$i-1$个逆元都已经求好了</p><p>可以把它们都存下来</p><p><strong>条件:质数p大于i</strong></p><p>$p%i$一定小于$i$</p><p>设$p&#x3D;ki+r$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300956374.webp" alt="image.png|600"></p><p>因为$i$一定不是$p$的因子</p><p>$1\le r \le i-1$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300958120.webp" alt="image.png|600"></p><p>现在想算$i$分之一</p><p>两边同除$i$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300958020.webp" alt="image.png|600"></p><p>两边同除$r$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304300959364.webp" alt="image.png|600"></p><p>$r$是个小于$i$的数，因此它的逆元一定在之前求出来的</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301000198.webp" alt="image.png|600"></p><p>复杂度$O(n)$</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> k = p / i;</span><br><span class="line">	<span class="type">int</span> r = p % i;</span><br><span class="line">	inv[i] = <span class="number">1ll</span> * k * (-inv[r] + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>由于是在模 p 意义下的运算，所以所有逆元都小于 p，所以加上 p 就可以防止负数。</p><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3811">模板题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="Miller-Rabin"><a href="#Miller-Rabin" class="headerlink" title="Miller-Rabin"></a>Miller-Rabin</h3><p>判断$x$是不是质数</p><p>复杂度为$O(\sqrt x)$</p><p>假如$x \le 10^{18}$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301008894.webp" alt="image.png|600"></p><p>假设$n&#x3D;37$</p><p>$n-1&#x3D;36$</p><p>$36&#x3D;9 \times 2^2$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301010370.webp" alt="image.png|600"></p><p>当$n$为质数的时候</p><p>至少有一条成立</p><p>$n$不是质数的时候也可能满足。</p><p>假如一个都不满足，那么一定不是质数。</p><hr><p>补充证明：</p><ol><li>Fermat 素性检验</li></ol><p>由费马小定理可知，若 $p$ 是素数：$a^{p - 1} \equiv 1 \pmod p$</p><p>那么当这个等式成立的时候，$p$ 就一定是素数？</p><p>不一定。</p><p>有部分合数无法被筛掉。</p><p>这个时候更换底数，可以增大它是素数的概率，但不管怎么换，仍然有合数无法被筛掉，所以我们需要引入另一个定理。</p><ol start="2"><li>二次探测定理</li></ol><p>对于素数 $p$ 若 $x^{2}\equiv 1 \pmod p$ 那么小于 $p$ 的解只有两个，$x_{1}&#x3D; 1, x_{2} &#x3D; p - 1$。</p><p>证明：$x^{2} - 1 \equiv 0 \pmod p\to(x + 1)(x - 1) \equiv 0\pmod p$ ，</p><p>那么要么是零，要么是 p 的倍数。</p><p>所以小于 $p$ 的解就是这两个。</p><p>两者结合一下：</p><p>先用 Fermat 检测得到 $a^{p - 1} \equiv 1 \pmod p$，这时候保证 $p - 1$ 是偶数，不然 p 是偶数就直接筛掉，那么就可以拆分为 $(a^{\frac{p-1}2})^2\equiv1\pmod{p}$ ，就可以用二次探测定理来判断了。</p><p>如果还符合，那就可以再进行同样的操作，直到里面的指数变为奇数。</p><p>也就是说，我们把 $p - 1 &#x3D; u \times 2^t$（u 是奇数），对 $a^u,a^{u\times2},a^{u\times2^2}$ 等数进行检验，它们的解要么全是一，要么出现 p - 1，注意，一开始没提取的时候是不能等于 p - 1 的，因为要满足费马小定理。</p><p>注意特判 a 是 p 的倍数的情况。</p><p><a class="link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/349360074">参考文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p>#Q 为什么从出现解为 p - 1 后解就必须全是 1？</p><p>假如一个$a$只成立性质一，<del>什么也说明不了</del>，说明$n$有可能是质数。</p><p>换了一个$a$，两个性质仍然有一个成立，那么这个概率就会提高。</p><p>不断地往里带，假如一直成立的话，那么概率就会不断提高。</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301018351.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301022385.webp" alt="image.png|600"></p><p>在$i$不断加一的过程中 $a^d$在不断地在平方</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mb</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> a)</span><span class="comment">//检查是否符合定理中的一个，现在要求d和r</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d=n<span class="number">-1</span>,r=<span class="number">0</span>;<span class="comment">//不断拿d除以2</span></span><br><span class="line">    <span class="keyword">while</span>(d%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        d=d/<span class="number">2</span>,r++;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">ksm</span>(a,d,n);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//a的d次方已经算过了，每加一次</span></span><br><span class="line">        <span class="keyword">if</span>(x==n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%n;<span class="comment">//不然就平方一下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>假如 $a^d$ 满足解为 $1$，那么不断把它平方，得到的解也必然为 1，因此对于第一个条件我们只需要检测 $a^d$ 是否满足即可。</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301024349.webp" alt="image.png|600"></p><p>枚举$d$和$r$以及快速幂复杂度都是$log_n$的</p><p>一半概率对，一半概率错</p><p>$20$次检查后，仍然错误的概率就是$\frac 1 {2^{20}}$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301029032.webp" alt="image.png|600"></p><p>$a\in1\sim n-1$</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">23</span>;i++)<span class="comment">//正常20次是足够的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="built_in">rand</span>()%(n<span class="number">-1</span>)<span class="number">+1</span>;<span class="comment">//随机检查 1~n-1</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">mb</span>(n,a)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>第二种方法：定义一个<strong>质数表</strong></p><p>在$10^{18}$以内质数的概率更高(<em>前人的智慧</em>)</p><p>质数表可以自己去搜。</p><ul><li><p>对于 $2^{32}$ 以内的判素数，选 2, 7, 61 即可</p></li><li><p>对于 $2^{64}$ 以内的判素数，选 2, 325, 9375, 28178, 450775, 9780504, 1795265022 即可。</p></li><li><p>对于考场上，选前 12 个质数作为底数即可，<br>2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37，适用于 $2^{78}$ 以内的判断素数。</p></li></ul><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/wangrx/miller-rabin">参考文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h2 id="EXGCD"><a href="#EXGCD" class="headerlink" title="EXGCD"></a>EXGCD</h2><p>$gcd(a,b)&#x3D;g$</p><p><strong>解决的问题</strong> 是为了解出$ax+by&#x3D;g$</p><p>未知数个数比方程数多的时候，这个方程通常有无数解</p><p>我们只需要找到一组解</p><p>用辗转相除求x,y?</p><p>$gcd(a,b)\to gcd(b,a%b)$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301058888.webp" alt="image.png|600"></p><p>倒推</p><p>先讲讲<strong>最后一层</strong></p><p>最终一定会得到：</p><p>$gcd(a,0)&#x3D;a$</p><p>因为每次得到的一定是它们<strong>最大公因数</strong>的倍数</p><p>$x \cdot a+y \cdot 0&#x3D;a$</p><p>$x&#x3D;1,y&#x3D;0(random)$</p><p>假设已经找到了$x’ y’$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301100694.webp" alt="image.png|600"></p><p>怎么变成左边的式子？</p><p>只能推出$y&#x3D;x’$，而不知道$x$，所以要往下化简</p><p>余数&#x3D;被除数-除数乘商</p><p>$a% b&#x3D; a - \lfloor \frac a b \rfloor \times b$</p><p>替换一下并整理：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301102376.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301103081.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301104954.webp" alt="image.png|600"></p><p>和原来的比对一下：</p><p>$ax+by&#x3D;g$</p><p>$\therefore$</p><p>$x&#x3D;y’$</p><p>$y&#x3D;x’-y’ \lfloor \frac a b \rfloor$</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span><span class="comment">//g=gcd(a,b),xy通过取地址传参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;<span class="comment">//gcd</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> xp,yp;</span><br><span class="line">    <span class="type">int</span> g=<span class="built_in">exgcd</span>(b,a%b,xp,yp);<span class="comment">//最大公因数//x&#x27;y&#x27;</span></span><br><span class="line">    <span class="comment">// 返回后一定满足xp*b+yp*a%b=g</span></span><br><span class="line">    <span class="comment">// xp*b+yp*(a-b*(a/b))=g</span></span><br><span class="line">    <span class="comment">// xp*b+yp*a-yp*b*(a/b)=g</span></span><br><span class="line">    <span class="comment">// yp*a+(xp-yp*(a/b))*b=g</span></span><br><span class="line">    x=yp;<span class="comment">//y&#x27;</span></span><br><span class="line">    y=xp-yp*(a/b);<span class="comment">//每层的xy是变的，g一直都是a b的gcd</span></span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这样就可以把$x$，$y$求出来</p><p>如果想要其它的解，那么只需要改变一下$y$的值就可以解出其它的解</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><blockquote><p>$f(x) &#x3D; ax+by$</p></blockquote><p>$x,y$都是<strong>任意整数</strong></p><p>这个式子能表示出的<strong>最小正整数</strong>就是$gcd(a,b)$</p><p>证明:</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301123858.webp" alt="image.png|600"></p><p>$x$ $y$ 不管怎么变，相加都是$g$的倍数，</p><p>不能表示任意的数，</p><p>只能表示$g$的倍数，</p><p>所以最小的正整数就是它自己。</p><p><a class="link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/155721651">详细证明过程<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><hr><p>比如：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301124607.webp" alt="image.png|600"></p><p>这个方程没有整数解，</p><p>满足这个条件的前提下，</p><p>$gcd(a,b)|z$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301125175.webp" alt="image.png|600"></p><p>它才有整数解。</p><p>那么怎么解？</p><p>$z$是$g$的倍数</p><p>那么把<code>exgcd</code>解出后，两边同时乘$k$就是这个方程的解。</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301126589.webp" alt="image.png|600"></p><h3 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h3><blockquote><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1082">P1082<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p></blockquote><p>假如不互质，那么这道题就无解，所以互质</p><p>$ax\equiv 1 \pmod b$</p><p>$ax$一定等于$yb+1$</p><p>$ax-by&#x3D;1$</p><p>和$exgcd$的区别？</p><p>没有区别</p><p>解出来解后给$y$加上负号就可以了</p><p>要求的时$x$</p><p>那么怎么保证正整数x最小呢？</p><p>随便找到一组解</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301411776.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301413608.webp" alt="image.png|600"></p><p>把$x$变大$n$</p><p>$y$调小$m$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301413753.webp" alt="image.png|600"></p><p>我们发现$2n&#x3D;3m$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301415958.webp" alt="image.png|600"></p><p>这样就可以把所有的解写出来</p><p>设解出一组解$x&#x3D;x_0,y&#x3D;y_0$</p><p>即$an&#x3D;bm$</p><p>$\frac a b&#x3D;\frac m n$</p><p>$$<br>\begin{cases}<br>x&#x3D;x_0+bk \<br>y&#x3D;y_0-ak \<br>\end{cases}<br>$$</p><p>这就是所有的解吗？</p><p><em>显然不是</em></p><p>假如$a&#x3D;4，b&#x3D;6$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301421189.webp" alt="image.png|600"></p><p>要保证$abk-abk&#x3D;0$又要保证$ab$的<strong>最大公因数</strong>不变，并且保证要整除，所以除去<strong>最大公因数</strong>最优。</p><p>$$<br>\begin{cases}<br>x&#x3D;x_0+{\frac b g}k \<br>y&#x3D;y_0-{\frac a g}k \<br>\end{cases}<br>$$</p><p>我们发现$x% \frac b g&#x3D;x_0$</p><p>这道题中$g&#x3D;1$</p><p>$x% b &#x3D;x_0$</p><p>每个$x$都是$b$的倍数$+n$</p><p>那么最小的时候就是 $x&#x3D; x \bmod b$ 的时候。</p><hr><p>假如方程两边同乘一个系数 k</p><p>方程变为：</p><p>$akx + bky &#x3D; kg$</p><p>简写一下就是：</p><p>$Ax + By &#x3D; G$</p><p>$$A &#x3D; \frac{G}{g}\times{a},a&#x3D;\frac{g}{G}\times A$$</p><p>$$B &#x3D; \frac{G}{g}\times{b},b&#x3D;\frac{g}{G}\times B$$</p><p>然后用 Exgcd 进行求解，</p><p>解得：</p><p>$$<br>\begin{cases}<br>x&#x3D;x_0 \<br>y&#x3D;y_0<br>\end{cases}<br>$$</p><p>这是随便的一组解，并且不是 $Ax + By &#x3D; G$ 的解，而是 $ax + by &#x3D; g$ 的解，因为在计算 $y’$ 的时候乘的系数是 $\lfloor{\frac a b}\rfloor$ 。而 a、b 等比增加不会导致这个值改变，也不会导致 $gcd(a, b)$ 发生改变，所以最后得到的解要乘上系数 $\frac G g &#x3D; k$ 才是 $Ax + By &#x3D; G$ 的解。</p><p>也就是说方程的解为：</p><p>$$<br>\begin{cases}<br>x&#x3D;kx_0 \<br>y&#x3D;ky_0<br>\end{cases}<br>$$</p><p>先看原来的方程，x 最小为多少？</p><p>$$x_0\bmod{\frac b g} &#x3D; x_0\bmod{\frac B G}$$</p><p>那么在新方程里，x 最小为：</p><p>$$<br>\begin{aligned}<br>x_{min}&amp;&#x3D;x_0\times{\frac G g}\bmod{\frac B G\times\frac G g}\ &amp;&#x3D; x_0\times{\frac G g}\bmod{\frac B g}\<br>\end{aligned}<br>$$</p><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1516">练习题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>有一堆<strong>同余方程</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301427824.webp" alt="image.png|600"></p><p>我们现在要把它们合并为一个方程</p><p>这个方程就是我们要求的</p><p>首先想解$x$</p><p>$x$有几个解呢？</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301429779.webp" alt="image.png|600"></p><p>一共有$n+1$个未知数</p><p>$n$个方程</p><p>理论上会有无数组解</p><p>假设现在只有两个方程</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301430010.webp" alt="image.png|600"></p><p>$x\in{1,16,31\dots}$<br>$x&#x3D;1+15k$</p><p>那么最后的解就是$x%15&#x3D;1$</p><p>两个同余方程解出一个同余方程</p><p>那么$n$个呢？</p><p>可以不断拿两个同余方程合并，合并$n-1$次</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301433401.webp" alt="image.png|600"></p><p>最后必然也会只剩下一个同余方程</p><p>那么怎么把两个方程合并为一个方程呢？</p><h4 id="大数翻倍法"><a href="#大数翻倍法" class="headerlink" title="大数翻倍法"></a>大数翻倍法</h4><blockquote><p>ZHX:我很推荐你们用大数翻倍法，好写还不容易被卡，不像EXGCD难写还难调</p></blockquote><p>$$<br>\begin{cases}<br>x_1%p_1&#x3D;a_1 \<br>x_2%p_2&#x3D;a_2 \<br>\end{cases}<br>$$<br>$$\downarrow$$<br>$$x%p&#x3D;a$$</p><p>考虑枚举，那么怎么优化呢？</p><p>可以强行让它满足第一个方程，再看它满不满足第二个方程</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301437414.webp" alt="image.png|600"></p><p>在$a_1$的基础上不断加上$p_1$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301440594.webp" alt="image.png|600"></p><p>这样对吗？</p><p>假如这个方程无解，那么就会死循环</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301442450.webp" alt="image.png|600"></p><p>这时候$%p2$就是$a_1$，相当于一个新的周期</p><p>超过<strong>最小公倍数</strong>就可以退出循环了</p><p><strong>最小公倍数就是新方程中被模的数</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301448021.webp" alt="image.png|600"></p><p>$x%15&#x3D;7$</p><p>假如让这个$x$模$3$的话</p><p>也就是$kp+7%3$,而$p$又是$3$的倍数，所以满足$x%3&#x3D;1$,t 同理满足$x%5&#x3D;2$</p><p>于是就是</p><p>$x%l&#x3D;a$</p><p>极端情况下会运行$p_2$次</p><p>时间复杂度是$O(p_2)$次</p><p><em>大数翻倍法？</em></p><p>让大的数翻倍</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301452389.webp" alt="image.png|600"></p><p>让枚举次数变为更小的p1</p><p>时间时间复杂度为$O(min(p1,p2))$</p><p>最后解出来的$p$是所有$p$的$lcm$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301456104.webp" alt="image.png|600"></p><p>复杂度</p><p>当$p$互质时候</p><p>要让所有$p$相乘小于$10^{18}$</p><p>所以一般不太可能炸掉</p><p>想卡也不是很好卡</p><h4 id="EXGCD法"><a href="#EXGCD法" class="headerlink" title="EXGCD法"></a>EXGCD法</h4><p>$$<br>\begin{cases}<br>x_1%p_1&#x3D;a_1 \<br>x_2%p_2&#x3D;a_2 \<br>\end{cases}<br>$$</p><p>$$<br>\downarrow<br>$$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301515598.webp" alt="image.png|600"></p><p>可以只看后半部分</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301516829.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301517447.webp" alt="image.png|600"></p><p>$$ \downarrow$$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301517282.webp" alt="image.png|600"></p><p>通过扩展欧几里得把$k1、k2$解出来</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301957534.webp" alt="image.png|600"></p><p>这里相当于$+(-k_2)$</p><p>那么求出来以后$k_2&#x3D;-k_2$即可</p><p>我按照$k_{1}\times p_{1}+k_{2}\times p_{2}&#x3D;a_2-a_1$求得的$x$</p><p>我现在想知道$k_{1}\times p_{1}-k_{2}\times p_{2}&#x3D;a_2-a_1$的解</p><p>那么令$k_2&#x3D;-k_2$即可</p><h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><h3 id="埃式筛"><a href="#埃式筛" class="headerlink" title="埃式筛"></a>埃式筛</h3><p>给一个数$n$</p><p>尽量少的时间内把$1\to n$所有的质数求出来</p><p>枚举$a$的所有倍数</p><p>$a$的倍数一定不是质数</p><p>把所有数的倍数都标记一遍</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">2</span>;a&lt;=n;a++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> b=a+a;b&lt;=n;n+=a)<span class="comment">//枚举a的所有倍数</span></span><br><span class="line">        not_prime[b]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">2</span>;a&lt;=n;a++)</span><br><span class="line">    <span class="keyword">if</span>(not_prime[a]==<span class="literal">false</span>) </span><br><span class="line">        prime[++cnt]=a;</span><br></pre></td></tr></table></figure></div><p>复杂度：$O(nlogn)$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301540448.webp" alt="image.png|600"></p><p>调和集数，约等于为$logn$</p><p>所以埃式筛的复杂度为$nlogn$</p><h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>首先,$4$有必要枚举吗？</p><p>因为枚举$2$的标记的时候$4$的标记已经被标记了</p><p>1.只需要枚举质数的倍数就行</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">2</span>;a&lt;=n;a++)</span><br><span class="line">        <span class="keyword">if</span>(not_prime[a]==flase)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b=a+a;b&lt;=n;n+=a)<span class="comment">//枚举a的所有倍数</span></span><br><span class="line">                not_prime[b]=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure></div><p>复杂度:$nloglogn$</p><p>证明一下为什么可以求倍数的过程中找质数</p><p>假设我枚举到了第$22$倍</p><p>那么我$22$之前的所有质数一定找完了</p><p>如果第$22$个没被标记，它一定不可能是一个和数</p><p>因为它只能被小于等于它的数标记</p><p>而不能被$23、24$标记</p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>现在一个数仍然有可能被筛多次</p><p>比如$6$，会被$2$和$3$都筛一次</p><p>比如$30$，会被$2$和$3$和$5$都筛一次</p><p>每个数都会被它的质因子筛一次</p><p>因为每个数质因子个数不是一个，因此大于$n$</p><p>我们要保证每个数只被筛一次</p><p>我们让它被最小的质因子筛掉</p><p>比如$6$只被$2$筛</p><p>$55$只被$5$筛</p><p><em>看代码</em></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="comment">//先枚举倍数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(not_prime[i]==<span class="literal">false</span>)<span class="comment">//一定是质数吗？有没有可能只是没被标为true</span></span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        prime[cnt]=i;<span class="comment">//存进质数表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=prime[j]*i;<span class="comment">//筛掉第j个质数的i倍</span></span><br><span class="line">        <span class="keyword">if</span>(x&gt;n) <span class="comment">//质数表是从小往大枚举的，这是第一个大于n的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        not_prime[x]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>还是$nloglogn$</p><p>加上一句话：</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isprime[N];</span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(isprime, <span class="literal">true</span>, <span class="built_in">sizeof</span>(isprime));</span><br><span class="line">	isprime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (isprime[i]) prime[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			isprime[i * prime[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301615037.webp" alt="image.png|600"></p><p>首先找出了$i&#x3D;2$</p><p>$x&#x3D;4$</p><p>$4$就不是质数</p><p>第二轮，$3$也是质数</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301616621.webp" alt="image.png|600"></p><p>会把$6$和$9$也筛掉</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301617580.webp" alt="image.png|600"></p><p>筛掉$8$之后，$4$是第一个质数的倍数，会<code>break</code></p><p>不会枚举到第三个质数</p><p>$12$也就没有筛掉</p><p>枚举到$i&#x3D;6$时</p><p>此时i最小的质因子就是$prime[j]$</p><p><strong>证明：</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304302021073.webp" alt="image.png|600"></p><p>假如没有<code>break</code></p><p>那么就会枚举第$j+1$个质数</p><p>$x&#x3D;prime[j+1]*i$</p><p>而$i&#x3D;k \times prime[j]$</p><p>$x&#x3D;prime[j+1] \times k \times prime[j]$</p><p>由于质数表是往后递增的，因此最小质因子就是第一次被整除的$prime[j]$</p><p><em>小练习</em>：<a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3383">P3383:线性筛素数<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><hr><p><em>常用大小：</em></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301627305.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301628330.webp" alt="image.png|600"></p><hr><h3 id="求积性函数"><a href="#求积性函数" class="headerlink" title="求积性函数"></a>求积性函数</h3><p><strong>定义：</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301631980.webp" alt="image.png|600"></p><p><strong>前提</strong>：$a$和$b$互质</p><p><strong>完全积性函数：</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301632192.webp" alt="image.png|600"></p><p><strong>不需要满足互质</strong>的条件</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301633307.webp" alt="image.png|600"></p><p>[[#欧拉定理|欧拉函数]]其实就是一个<strong>积性函数</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301636339.webp" alt="image.png|600"></p><p>$q$都是质数</p><p>$\varphi( )&#x3D;？$</p><p><strong>证明过程：</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301639198.webp" alt="image.png|600"></p><p>我们发现$\varphi(mn)$的结果拆成两部分也就是$n$和$m$</p><p>$O(n)$求$1\to n$的值</p><p>$prime[j]$ 和 $prime[i]$</p><p>有可能不互质</p><p>假设它全互质，先按照函数定义求</p><p>那么<strong>不互质</strong>的怎么处理(也就是i和)</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301646087.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301646101.webp" alt="image.png|600"></p><p>现在算$\varphi(i\cdot p_j)$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301646256.webp" alt="image.png|600"></p><p>$\because$ $i$是$p_j$的整数倍</p><p>$\therefore$ <strong>质因子</strong>没有发生变化,也就是$prime[j]$的质因子和$i$的质因子都是$q$,只是次数不一样</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202304301649030.webp" alt="image.png|600"></p><p>后面那个东西就是$\varphi(i)$</p><p>所有数分为1+质数+和数</p><p>$\varphi(1)&#x3D;1$</p><p>当$n$为质数，$\varphi(n)&#x3D;n-1$</p><p>和数分为以上互质和不互质两种情况</p><h2 id="BSGS-Baby-Step-Giant-Step"><a href="#BSGS-Baby-Step-Giant-Step" class="headerlink" title="BSGS(Baby Step Giant Step)"></a>BSGS(Baby Step Giant Step)</h2><p>$a,b,p$</p><p>$p$是质数</p><p>求$a^x%p&#x3D;b$</p><p>也就是$a^x\equiv b \pmod p$</p><p>$a,b,p\le 10^9$</p><p>写一下暴力</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">1</span>;<span class="comment">//a的零次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;;x++)<span class="comment">//从0次开始枚举</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==b) <span class="keyword">return</span> x;</span><br><span class="line">        v=<span class="number">1ll</span>*v*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>枚举到符合条件为止</p><p>假如无解，就会死循环</p><p>怎么判断无解？</p><p>初始状态就是$1$</p><p>再次出现若循环后依旧无解，那么就是无解</p><p>$v$的范围是$0$到$p-1$</p><p>[[#费马小定理|费马小定理]]：</p><p>一定会从1开始循环</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010839896.webp" alt="image.png|600"></p><p>$a^{p-1}%p&#x3D;1$</p><p>$a^0%p&#x3D;1$</p><p>循环长度为$p-1$</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">1</span>;<span class="comment">//a的零次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;p<span class="number">-1</span>;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==b) <span class="keyword">return</span> x;</span><br><span class="line">        v=<span class="number">1ll</span>*v*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>$a^0&#x3D;a^{p-1}&#x3D;1$</p><p><em>怎么优化呢？</em></p><p>答案一定会在$a^{0\to p-1}$中出现</p><p>那我分个组</p><p>第零组是到从$a^0$到$a^{s-1}$</p><p>$s$为每组的大小</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010845006.webp" alt="image.png|600"></p><p>把第零组的每个数都$for$一下</p><p>看下这$s$个数里有没有$b$</p><p>这样就知道答案的位置在哪里了</p><p>如果不在第零组，那么就去看第一组</p><p>还是$for$一遍</p><p>$\dots\dots$</p><p>还是要枚举$p$次</p><p>那么第二次有没有更聪明的找法呢？</p><p>第零组乘以$a$的$s$次方就是第一组</p><p>如果要变回去的话那就是乘以$a$的$-s$次方</p><p>假如$b$在第一组出现了，那么第零组会出现下面这个东西</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010850813.webp" alt="image.png|600"></p><p>其实就是找第一组$b\cdot a^{-s}$</p><p>假如$b$在第$i$组出现了，那就要找第一组的$a^{-is}$</p><p>把每一组都映射到第一组</p><p>这样就可以很方便地查询了</p><p><code>STL</code>有一个东西叫<code>set</code>，可以存一堆数，查找一个数在这堆数中是否出现过</p><p><strong>Set</strong></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin</span>();<span class="comment">// 返回指向第一个元素的迭代器</span></span><br><span class="line"><span class="built_in">end</span>();<span class="comment">// 返回指向迭代器的最末尾处（即最后一个元素的下一个位置）</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">// 清除所有元素</span></span><br><span class="line"><span class="built_in">count</span>();<span class="comment">// 返回某个值元素的个数</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">// 如果集合为空，返回true</span></span><br><span class="line"><span class="built_in">equal_range</span>();<span class="comment">//返回集合中与给定值相等的上下限的两个迭代器</span></span><br><span class="line"><span class="built_in">erase</span>()<span class="comment">//–删除集合中的元素</span></span><br><span class="line"><span class="built_in">find</span>()<span class="comment">//–返回一个指向被查找到元素的迭代器</span></span><br><span class="line"><span class="built_in">get_allocator</span>()<span class="comment">//–返回集合的分配器</span></span><br><span class="line"><span class="built_in">insert</span>()<span class="comment">//–在集合中插入元素</span></span><br><span class="line"><span class="built_in">lower_bound</span>()<span class="comment">//–返回指向大于（或等于）某值的第一个元素的迭代器</span></span><br><span class="line"><span class="built_in">key_comp</span>()<span class="comment">//–返回一个用于元素间值比较的函数</span></span><br><span class="line"><span class="built_in">max_size</span>()<span class="comment">//–返回集合能容纳的元素的最大限值</span></span><br><span class="line"><span class="built_in">rbegin</span>()<span class="comment">//–返回指向集合中最后一个元素的反向迭代器</span></span><br><span class="line"><span class="built_in">rend</span>()<span class="comment">//–返回指向集合中第一个元素的反向迭代器</span></span><br><span class="line"><span class="built_in">size</span>()<span class="comment">//–集合中元素的数目</span></span><br><span class="line"><span class="built_in">swap</span>()<span class="comment">//–交换两个集合变量</span></span><br><span class="line"><span class="built_in">upper_bound</span>()<span class="comment">//–返回大于某个值元素的迭代器</span></span><br><span class="line"><span class="built_in">value_comp</span>()<span class="comment">//–返回一个用于比较元素间的值的函数</span></span><br></pre></td></tr></table></figure></div><p>看答案是否在第$i$行里面,<strong>第一行是第$0$行</strong></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i*s&lt;=p;i++)<span class="comment">//看答案是否在第i行里面,第一行是第0行//超过p次方就会开始循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//看b乘以a的-is次方是否在第零行出现——逆元</span></span><br><span class="line">        <span class="type">int</span> c=<span class="number">1ll</span>*b*<span class="built_in">ksm</span>(<span class="built_in">ksm</span>(a,i*s,p),p<span class="number">-2</span>,p)%p;<span class="comment">//快速幂</span></span><br><span class="line">        <span class="keyword">if</span>(se.<span class="built_in">count</span>(c)!=<span class="number">0</span>)<span class="comment">//出现次数 0/1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//答案在第i行,暴力一遍</span></span><br><span class="line">            <span class="type">int</span> v=<span class="built_in">ksm</span>(a,i*s,p);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i*s;;j++)<span class="comment">//一定会找到答案</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(v==b) <span class="keyword">return</span> j;<span class="comment">//找到答案</span></span><br><span class="line">                v=<span class="number">1ll</span>*v*a%p;<span class="comment">//枚举次数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p><strong>由于越往下找答案肯定就越大，那么第一次找到一定就是最小值</strong></p><p><strong>注意这里$i*s$可能会爆<code>int</code>，要开<code>long long</code></strong></p><p>第一层循环$\frac ps$次</p><p>第二层循环枚举这一组中每一个数</p><p>最坏的情况就是$O(s)$</p><p>第二次循环只会执行一次，所以是加法原理</p><p>$O(\frac ps+s)$</p><p>$O(n+logn)&#x3D;O(n)$</p><p>我们只关心更大的</p><p>所以复杂度就是$O(max(\frac ps,s))$</p><p>复杂度由较大值决定</p><p>所以$\frac ps&#x3D;s$的时候复杂度最优（基本不等式）</p><p>$s&#x3D;\sqrt p$</p><p><code>insert</code>和<code>count</code>是$log$的</p><p>这也就是分块的思想</p><p>若要访问出现多少次，用<code>map</code></p><h1 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h1><h2 id="引入定义式"><a href="#引入定义式" class="headerlink" title="引入定义式"></a>引入定义式</h2><p><strong>小栗子：</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010917302.webp" alt="image.png|600"></p><p>假如条件是<strong>互斥</strong>的（不能同时成立），那么就是加法</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010918133.webp" alt="image.png|600"></p><p>前面的选择和后面的选择是不同阶段的选择，前一阶段的条件对后续条件的选择没有影响</p><p>就乘起来</p><hr><p>从三个人选出来两个人站成一列，有几种选法？ ——<em>排列</em></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010922121.webp" alt="image.png|600"></p><p>有六种选法</p><p>那假如从$n$个人中选$m$个人站成一列,考虑这$m$个人<strong>内部的顺序</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010924291.webp" alt="image.png|600"></p><p>$$<br>\begin{aligned}<br>P(n,m)&amp;&#x3D;n\cdot (n-1)\cdot(n-2)\cdot(n-3)\cdot(n-4)\cdot(n-5)\ldots \cdot(n-m+1)\<br>&amp;&#x3D;\frac {n!}{(n-m)!}<br>\end{aligned}<br>$$</p><hr><p>这样是考虑<strong>内部顺序</strong>的情况</p><p>假如不考虑<strong>内部的顺序</strong>呢？ ——<em>组合</em></p><p>$C(n,m)&#x3D;n\cdot (n-1)\cdot(n-2)\cdot(n-3)\cdot(n-4)\cdot(n-5)\dots (n-m+1)$? ——<em>显然不是</em></p><p>$1,2$和$2,1$是同一种方案，也就是$m$个人的内部随便怎么排都可以，都是一种方案</p><p>$m$个人内部随便排的方案数其实就是记录顺序地从$m$个人中选$m$个人，也就是：</p><p>$$<br>{m}\times{(m-1)}\times{(m-2)}\times{(m-3)}\times{(m-4)}\times{\ldots}\times1<br>$$</p><p>想想第一个人选的时候有$m$种可能</p><p>那选第二个人的时候就有$m-1$种可能</p><p>以此类推</p><p>因为每次选择都是独立的，所以概率要相乘</p><p>也就是有$m!$种方案</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010929411.webp" alt="image.png|600"></p><p>三个人可以引伸为<strong>六种方案</strong></p><p>也就是$3！$种方案</p><p>$m$个人内部可以有多少种顺序呢，答案是有$m!$种顺序，那就有$m!$种方案为同一种方案</p><p>$$<br>\begin{aligned}<br>C(n,m)&amp;&#x3D;\frac {n\cdot (n-1)\cdot(n-2)\cdot(n-3)\cdot(n-4)\cdot(n-5)\dots (n-m+1)}{m!}\<br>&amp;&#x3D;\frac {P(n,m)}{m!}\<br>&amp;&#x3D;\frac {n!}{m!(n-m)!}\<br>\end{aligned}<br>$$</p><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p>$C(n,0)&#x3D;1$</p><p>$C(n,n)&#x3D;1$</p><p>$P(n,n)&#x3D;n!$</p><h3 id="1-C-n-m-C-n-n-m"><a href="#1-C-n-m-C-n-n-m" class="headerlink" title="1.C(n,m)&#x3D;C(n,n-m)"></a>1.C(n,m)&#x3D;C(n,n-m)</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010935737.webp" alt="image.png|600"></p><p>保留$m$个和丢掉$n-m$个方案数相同</p><p>或者带进式子，会发现式子一样</p><h3 id="2-🚩递推式"><a href="#2-🚩递推式" class="headerlink" title="2.🚩递推式"></a>2.🚩递推式</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010937199.webp" alt="image.png|600"></p><p>它们分别代表：</p><ul><li><p>$n$个选$m$个的<strong>方案数</strong></p></li><li><p>$n-1$个选$m-1$个的<strong>方案数</strong></p></li><li><p>$n-1$选$m$个的<strong>方案数</strong></p></li></ul><p>可以用背包的思路</p><p>可以用第$n$个物品要<em>选&#x2F;不选</em></p><ul><li><p>如果选的话，方案数就是选在$n-1$个数种选$m-1$个数的方案数，也就是$C(n-1,m-1)$</p></li><li><p>如果不选的话，方案数就是在在$n-1$个数中选$m$个数的方案数，也就是$C(n-1,m)$</p></li></ul><p>因为选了以后就不能选了</p><p>所以是<em>加法原理</em></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010941373.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010945910.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010946576.webp" alt="image.png|600"></p><p>这不就是<em>杨辉三角</em>嘛!</p><h3 id="3-n个物品随便选"><a href="#3-n个物品随便选" class="headerlink" title="3.n个物品随便选"></a>3.n个物品随便选</h3><p>$C(n,0)+C(n,1)+C(n,2)+C(n,3)+\dots +C(n,n)&#x3D;2^n$</p><ul><li><p>$n$个物品选$0$个物品的方案数</p></li><li><p>*$n$个物品选$1$个物品的方案数</p></li><li><p>*$n$个物品选$2$个物品的方案数</p></li><li><p>$n$个物品选$3$个物品的方案数</p></li><li><p>$n$个物品选$4$个物品的方案数</p></li></ul><p>$\dots$</p><ul><li>$n$个物品选$n$个物品的方案数</li></ul><p>也就是从$n$个物品里<strong>任意选多少</strong>个的方案数</p><p>第一个物品要么选要么不选</p><p>一直到第n个物品，每个物品都是两种选择</p><p>那就是$2^n$</p><h3 id="4-奇方案-偶方案"><a href="#4-奇方案-偶方案" class="headerlink" title="4.奇方案&#x3D;偶方案"></a>4.奇方案&#x3D;偶方案</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011006475.webp" alt="image.png|600"></p><p>加到&#x2F;减到$C(n,n)$为止</p><p>移一下项</p><p>就是选偶数个东西的方案数等于选奇数个东西的方案数</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305010937199.webp" alt="image.png|600"></p><p>可以画出当前这行的杨辉三角形</p><p>每一行的第一个都是$1$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011010633.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011011482.webp" alt="image.png|600"></p><p>偶数位置的和恰好把上一行每一个数加了起来</p><p>那假如是<strong>奇数</strong>？</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011012723.webp" alt="image.png|600"></p><p>也恰好把上一行所有位置加起来</p><p><strong>选奇数的方案数&#x3D;选偶数的方案数&#x3D;</strong>$2^{n-1}$</p><h3 id="5-二项式定理"><a href="#5-二项式定理" class="headerlink" title="5.二项式定理"></a>5.二项式定理</h3><p>$(x+y)^0&#x3D;1$</p><p>$(x+y)^1&#x3D;x+y$</p><p>$(x+y)^2&#x3D;x^2+2xy+y^2$</p><p>$(x+y)^3&#x3D;x^3+3x^2y+3xy^2+y^3$</p><p>$(x+y)^4&#x3D;x^4+4x^3y+x^2y^2+4xy^3+y^4$</p><p>这不也是一个<em>杨辉三角</em>嘛</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011017334.webp" alt="image.png|600"></p><p>每行从左到右$x$次数逐渐减小，$y$的次数逐渐增加，系数就是杨辉三角数</p><ul><li>$(x+y)^n&#x3D;C(n,0)x^ny^0+C(n,1)x^{n-1}y^1+\dots+C(n,n)x^0y^n$</li></ul><p>但是这样写很麻烦</p><p>$\downarrow$</p><p><strong>求和运算符：</strong>$\Sigma$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011022670.webp" alt="image.png|600"></p><ul><li>$&#x3D;\sum^n \limits_{i&#x3D;0}C(n,i)x^{n-i}y^i$</li></ul><h3 id="6-📌组合数的卷积（展开式）"><a href="#6-📌组合数的卷积（展开式）" class="headerlink" title="6.📌组合数的卷积（展开式）"></a>6.📌组合数的卷积（展开式）</h3><p>$$<br>\begin{aligned}<br>C(n,m)&amp;&#x3D;C(n-1,m-1)+C(n-1,m)\<br>&amp;&#x3D;C(n-2,m-2)+C(n-2,m-1)+C(n-2,m-1)+C(n-2,m)\<br>&amp;&#x3D;C(n-2,m-2)+2\cdot C(n-2,m-1)+C(n-2,m)\<br>&amp;&#x3D;C(n-3,m-3)+3C(n-3,m-2)+3C(n-3,m-1)+C(n-3,m)\<br>&amp;&#x3D;\dots\dots\<br>&amp;\downarrow \<br>\end{aligned}<br>$$</p><p>$$<br>\begin{aligned}<br>C(n,m)&amp;&#x3D;C(k,0)\cdot C(n-k,m-k)+C(k,1)\cdot C(n-k,m-k+1)+C(k,2)\cdot C(n-k,m-k+2)+\dots +C(k,k)\cdot C(n-k,m-k+k)\<br>\downarrow \<br>&amp;&#x3D;\sum^k\limits_{i&#x3D;0}C(k,i)\cdot C(n-k,m-i)<br>\end{aligned}<br>$$</p><p>$k$表示展开$k$次,我们发现展开后多项式的系数就是杨辉三角数</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011029469.webp" alt="image.png|600"></p><p>$C(n,m)&#x3D;\sum^k\limits_{i&#x3D;0}C(k,i)\cdot C(n-k,m-k+i)&#x3D;$</p><h2 id="亿些数学题"><a href="#亿些数学题" class="headerlink" title="亿些数学题"></a>亿些数学题</h2><h3 id="1-组合"><a href="#1-组合" class="headerlink" title="1.组合"></a>1.组合</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011033937.webp" alt="image.png|600"></p><p>一个数可以被选<strong>任意多</strong>次</p><p>$\frac {n^m}{m!}$？</p><p>每种方案<strong>重复的次数</strong>不一样</p><p>比如123(<em>123,132,213,231,312,321</em>)，我有六种方式为一种方案</p><p>但假如是122(<em>122,212,221</em>)，我只有$3$种方式为一种方案</p><p>正因为每个数<strong>可以重复并且重复的次数不一样</strong>，因此不可以同除一个数</p><p>那就是$m个1，2，3，4，5，6$？</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011038831.webp" alt="image.png|600"></p><p>也不对，每个$2$都是一个$2$</p><hr><p>首先选$m$个数</p><p>$a_1a_2a_3a_4a_5a_6…a_m$</p><p>排个序，那么它就是递增的</p><p>大于等于$1$小于等于$n$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011041121.webp" alt="image.png|600"></p><p>这个不等式解的个数</p><p>答案就是$C(n,m)$</p><p>所有的数从小于号变成了小于等于</p><p>现在要解的就是这个方程有多少组解</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011042717.webp" alt="image.png|600"></p><p>现在会解小于，考虑把小于等于转化为小于</p><p>那我再造$m$个变量</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011043630.webp" alt="image.png|600"></p><p>所以带进小于等于不等式</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011045854.webp" alt="image.png|600"></p><p>也就是从$n+m-1$个数中选$m$个</p><p>$c$的方案数就是$C(n+m-1,m)$</p><p>每一组$b$的解都对应着一组$c$的解</p><p>所以b的方案数也就是$C(n+m-1,m)$</p><hr><p>相邻的不能选的情况呢？</p><h2 id="亿点代码题-卢卡斯定理"><a href="#亿点代码题-卢卡斯定理" class="headerlink" title="亿点代码题(卢卡斯定理)"></a>亿点代码题(卢卡斯定理)</h2><p>$n,m,p$</p><p>求$C(n,m)%p$</p><p>数据范围?</p><ol><li>$n,m$&lt;&#x3D;$10^{18}$,$P&#x3D;1$</li></ol><p>输出$0$</p><ol start="2"><li>$n,m\le 1000$ $p$无限制</li></ol><p>递推式：</p><p>$C(n,m)&#x3D;(C(n-1,m-1)+C(n-1,m))%p$</p><ol start="3"><li>$n,m\le 10^6$,$p$是质数</li></ol><p>因为$p$是质数了，所以可以用<strong>逆元</strong></p><p>$C(n,m)&#x3D;\frac {n!}{m!\times (n-m)!}$</p><p>除法可以用<strong>逆元</strong>搞定</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011108568.webp" alt="image.png|600"></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fac[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//0!</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000000</span>;i++)</span><br><span class="line">        fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    <span class="built_in">C</span>(n,m)=<span class="number">1ll</span>*fac[n]*<span class="built_in">ksm</span>(fac[m],p<span class="number">-2</span>,p)%p*<span class="built_in">ksm</span>(fac[n-m],p<span class="number">-2</span>,p)%p;</span><br></pre></td></tr></table></figure></div><ol start="4"><li>$n\le 10^9$ $m&lt;&#x3D;1000$ $p$无限制</li></ol><p>大概是一个$m^2$级别的才符合出题人的意图</p><p><strong>一个题的突破口就是最奇怪的地方</strong></p><p>因为$p$无限制，所以<strong>不一定是质数</strong>，可能<strong>逆元不存在</strong></p><p><em>不用递推式可不可以？</em></p><p>$m\le n$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011126512.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011119941.webp" alt="image.png|600"></p><p>把能约的全部约掉</p><p>上面有$m$项，下面有$m$项</p><p>枚举上下两项</p><p>最后分母一定可以被约成$1$</p><p>答案就是把分子乘起来</p><p>复杂度:$m^2\times logn$</p><ol start="5"><li>$n,m\le 10^9$,$p\le 100$且为质数</li></ol><p><strong>卢卡斯定理</strong></p><p>$p$为质数</p><p>把$n$，$m$转换为$p$进制的数</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011404855.webp" alt="image.png|600"></p><p>按位取$C()$再相乘</p><p>比如：</p><p>$25&#x3D;221$</p><p>$C(25,12)%3&#x3D;C(2,1)\cdot C(2,1)\cdot C(1,0)%3$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011407891.webp" alt="image.png|600"></p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 转为p进制</span></span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        x[<span class="number">0</span>]++;<span class="comment">//x[0]代表位数</span></span><br><span class="line">        x[x[<span class="number">0</span>]]=n%p;</span><br><span class="line">        n=n/p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m)</span><br><span class="line">    &#123;</span><br><span class="line">        y[<span class="number">0</span>]++;<span class="comment">//y[0]代表位数</span></span><br><span class="line">        y[y[<span class="number">0</span>]]=m%p;</span><br><span class="line">        m=m/p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>因为$n$大于$m$</p><p>所以正常情况下$n$转换为$p$进制的位数比$m$要大</p><p>所以按照$n$转化后的位数枚举就可以了</p><p>以最低位对齐，高位补零</p><p>时间复杂度？</p><p>不断除以$p$</p><p>那么就是$log_p$的复杂度</p><p>那假如模的不是质数（这个数也不能是某个质数的若干次方）</p><p>那先对它先进行一个质因数分解</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011422004.webp" alt="image.png|600"></p><p>这不就是[[#中国剩余定理|中国剩余定理]]嘛</p><p>解同余方程就可以了</p><h3 id="1-组合数拆解"><a href="#1-组合数拆解" class="headerlink" title="1.组合数拆解"></a>1.组合数拆解</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011425063.webp" alt="image.png|600"></p><p>$n&#x3D;1+1+1+1+1+1…+(n-k+1)$</p><p>加上$k-1$个$1$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011431364.webp" alt="image.png|600"></p><p><strong>任何一个自然数都是组合数</strong></p><h3 id="2-比较组合数大小"><a href="#2-比较组合数大小" class="headerlink" title="2.比较组合数大小"></a>2.比较组合数大小</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011433838.webp" alt="image.png|600"></p><p>数据范围:$&lt;&#x3D;1000000$</p><p>解法：</p><p><strong>log</strong></p><p>$log_x(ab)&#x3D;log_a+log_b$</p><p>$log_x(\frac ab)&#x3D;log_a-log_b$</p><p>$log$可以反映大小关系</p><p>$log{C(n1,m1)}$ $log{C(n2,m2)}$</p><p>假如$C_1&lt;C_2$那么一定有$logC_1&lt;logC_2$，反之亦然<br>$$<br>\begin{aligned}<br>logC(n,m)&amp;&#x3D;log\frac{n!} {m!\times (n-m)!}\<br>&amp;&#x3D;log{n!}-log{m!}-log{(n-m)!}\<br>&amp;\downarrow\<br>log{n!} &amp;&#x3D;log1+log2+log3+\dots logn\<br>\end{aligned}<br>$$</p><p>这样就可以求出$logC(n,m)$的值就可以进行比较大小了</p><p><em>精度误差？</em></p><p>这个是在小数点后很多位产生的误差</p><p>因此可以忽略不计</p><h3 id="3-找最大组合数"><a href="#3-找最大组合数" class="headerlink" title="3.找最大组合数"></a>3.找最大组合数</h3><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4370">P4370<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011455419.webp" alt="image.png|600"></p><p><strong>对某个数取模,不需要考虑和是什么</strong></p><p>最大的数一定在最下面的最中间</p><p>最下面那不就是第$n$行嘛，也就是第$n$行的最中间$n&#x2F;2$</p><p>要求组合数，要么就是带入公式，但是这里模数不一定为质数，所以只能用递推式</p><p>第二大的一定在它的周围</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011500778.webp" alt="image.png|600"></p><p>下一个最大的在第二大和第一大的组合数周围</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011501761.webp" alt="image.png|600"></p><p>怎么比较大小呢？</p><p>上一道题就说了</p><p>那就可以用<code>BFS</code>做了</p><p>但$k$比较大</p><p>可以加堆优化</p><h3 id="4-组合数问题"><a href="#4-组合数问题" class="headerlink" title="4.组合数问题"></a>4.组合数问题</h3><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problemP3746">P3746<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p>一开始的$f(n,r)$,往下化简</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011522366.webp" alt="image.png|600">^1121</p><p>展开$k$次</p><p>按照[[#6.📌组合数的卷积（展开式）|展开式]]</p><p>$C(n,m)&#x3D;\sum^k\limits_{i&#x3D;0}C(k,i)\cdot C(n-k,m-i)$</p><p>$C(nk,ik+r)&#x3D;\sum^k\limits_{j&#x3D;0}$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011524057.webp" alt="image.png|600"></p><p>出现了很多$\Sigma$</p><p>这个叫做<em>求和变形</em></p><p><u>常用的技巧</u>：</p><ol><li><strong>增加枚举量</strong></li><li><strong>交换枚举顺序</strong></li></ol><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011528564.webp" alt="image.png|600"></p><ol start="3"><li><strong>分离无关变量</strong></li></ol><p>什么叫做分离无关变量呢？</p><p>这个式子里变得是$i$和$j$</p><p>$i$变了第二个式子就会变，但第一个式子不会变</p><p>那就可以把第一个式子提出去</p><ol start="4"><li>[[#7.|换元法]]</li></ol><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011531771.webp" alt="image.png|600"></p><p>求完和再统一去乘</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011532366.webp" alt="image.png|600"></p><p>这还是两层循环</p><p>想想题目开始时设的$f$，现在已经化简成了这样</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011522366.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011533496.webp" alt="image.png|600"></p><p>$i,j$控制的是圈起来的部分,这个地方就可以把$\infty$消掉</p><p>![[#^1121]]</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011534068.webp" alt="image.png|600"></p><p>那就能化为</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011535079.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011537221.webp" alt="image.png|600"></p><p>老规矩，加一维，凑成矩阵乘法</p><p>第一行第$r$列</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011538082.webp" alt="image.png|600"></p><p>令</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011539247.webp" alt="image.png|600"></p><p>$f_0$就是$n&#x3D;0$时的值，往公式里带就可以了</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011539727.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011541533.webp" alt="image.png|600"></p><h2 id="抽屉原理"><a href="#抽屉原理" class="headerlink" title="抽屉原理"></a>抽屉原理</h2><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011546192.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011547914.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011549655.webp" alt="image.png|600"></p><p>一般来讲小的为抽屉</p><p>所以$c$是抽屉，$n$是东西</p><p><strong>陷阱：选任意多个数，但不保证连续，但其实连续更好做</strong></p><p><strong>前缀和：</strong></p><p>$n$个数的前缀和一定有$n+1$个</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011556589.webp" alt="image.png|600"></p><p>$n+1&gt;n\ge c$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011600523.webp" alt="image.png|600"></p><p>按照模$c$以后的数分组</p><p>那就是 $0 \to c-1$</p><p>一共有$c$个抽屉</p><p>$n+1$个前缀和，按照模数分组</p><p>那么一定有一个抽屉有两个前缀和,前缀和肯定是几个数相加</p><p>这两个数模$c$是同余的</p><p>那它们的差一定就是$c$的倍数</p><p>那前缀和之差肯定就是某段区间的和了</p><h3 id="1-正方形覆盖"><a href="#1-正方形覆盖" class="headerlink" title="1.正方形覆盖"></a>1.正方形覆盖</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011613679.webp" alt="image.png|600"></p><p>假如$L&#x3D;100$能盖住</p><p>那$L&#x3D;150$一定也可以盖住</p><p>假如$L&#x3D;100$不能盖住</p><p>那么$L&#x3D;50$一定也不能盖住</p><p>考虑<em>二分答案</em></p><p>那么现在问题是已知$L$，能不能覆盖所有点</p><p>这题有个很特殊的数字$3$</p><p>$3$和抽屉原理有什么关系</p><p>可以把平面上所有点分为<strong>四块</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011621702.webp" alt="image.png|600"></p><p>最靠<em>上&#x2F;下&#x2F;左&#x2F;右</em>的点为边界</p><p>至少有<strong>一个正方形</strong>会盖住<strong>两个点</strong></p><p>要么<em>左上角&#x2F;右上角&#x2F;左下角&#x2F;右下角</em></p><p>枚举一下就可以了</p><p>假如放在左下角</p><p>盖住一个区块后</p><p>剩下的点还可以构造一个四边形</p><p>现在还剩两个正方形</p><p>至少有一个正方形至少盖住两个边界点</p><p>再枚举一次（枚举的是盖住哪个角，而不是盖住几个点，盖住几个点都不重要，我们想知道的只是最后能不能全都盖住）</p><p>再把没有被盖住的点拿出来，看看最后一个正方形能不能盖住剩下的点就可以了</p><p>这样就可以判断能不能用长度为$L$的正方形能不能盖住了</p><p>每次盖住就要重新求一遍边界点，为$O(n)$级别</p><p>然后枚举十六种情况</p><p>也就是$O(16n)$</p><p>为什么放角上是最优的？</p><p>因为再往外移就会浪费面积</p><p>没有盖住任何点</p><p>我倒不如往里移让它盖住更多的点</p><h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011647747.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011647211.webp" alt="image.png|600"></p><p>加上所有一个式子，减去所有两个式子，加上所有三个式子，减去所有四个式子</p><h3 id="n对夫妻问题"><a href="#n对夫妻问题" class="headerlink" title="n对夫妻问题"></a>n对夫妻问题</h3><p>$2n$个人坐成一圈</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305011650406.webp" alt="image.png|600"></p><p>每对夫妻不能坐在相邻的位置</p><p>旋转后相同的算一种</p><p>假如不要求不相邻，让他们作为一排</p><p><strong>有两种解释：</strong></p><p><strong>第一种：</strong></p><p>一排的方案数是$n!$</p><p>坐成一圈呢？</p><p>$n$个人坐成一圈的人可以转出n种方案</p><p>所以就是$n!\div n$</p><p>$&#x3D;(n-1)!$</p><p><strong>第二种：</strong></p><p>假如第一个人定死了，剩下$n-1$个人坐$n-1$个位置，还是$(n-1)!$</p><p>回到题目本身的要求上：<strong>每对夫妻都不能相邻</strong></p><p>原来有$2n$个人</p><p>随便坐的方案数：$(2n-1)!$</p><p>但这里面包含<em>不合法</em>的方案数</p><p>那就把它<strong>减去</strong>就可以了</p><p>我可以让一对夫妻强制坐在一起，那么这种一定不合法</p><p>$n$对中选出一对夫妻强制相邻：$C(n,1)\cdot (2n-2)!$</p><p>可以把强制相邻看作让把一个人强制绑定到另一个人身上，也就是让这$(2n-2)$个人围成一圈做全排列</p><p>虽然强制相邻，但<strong>男左女右</strong>，<strong>男右女左</strong>也是两种方案</p><p>所以还要再乘以$2$：$C(n,1)\cdot (2n-2)!\cdot 2$</p><p>这就是答案吗？</p><p>但有没有可能把一种不合法的方案删了多次呢？</p><p>如果一个方案里，既有第一对相邻，也有第二对相邻，那么这个方案会被减掉两次</p><p>发现被多减了</p><p>$(2n-1)!-C(n,1)\cdot (2n-2)!\cdot 2+C(n,2)\cdot (2n-3)!\cdot x^2$</p><p>我们又发现多加上了三对夫妻相邻的方案数</p><p>那么就不断加加减减下去，最后写成$\Sigma$的形式</p><p>有i对夫妻强制相邻</p><p>$\sum^n\limits_{i&#x3D;0}C(n,i)\cdot (2n-i-1)!\cdot{2^i}$</p><p>那么加减呢？</p><p>观察上面的式子</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020844653.webp" alt="image.png|600"></p><p>发现规律：<strong>奇数减，偶数加</strong></p><p>为了使奇数减，偶数加，那么就要再做一点修改：</p><p>$\sum^n\limits_{i&#x3D;0}C(n,i)\cdot (2n-i-1)!\cdot{2^i}\cdot{(-1)^i}$</p><p>把$n$对不坐在一起的问题转换为只限制一对，两对，三对……</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020847026.webp" alt="image.png|600"></p><h3 id="x的y次方"><a href="#x的y次方" class="headerlink" title="x的y次方"></a>x的y次方</h3><blockquote><p><a class="link" target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=2204">HDU2204<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P9118">P9118<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p></blockquote><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020849353.webp" alt="image.png|600"></p><p>$y$最大的多少？</p><p>要保证$2^y&lt;10^{18}$，这是$x$最小的($1$的任意次方等于它本身)</p><p>那么$y&lt;64$</p><p>$1-100$有多少个数能用$x^2$表示？</p><p>这个答案显然是$\sqrt{100}$个</p><p>那么$1\to{N}$能表示$x^y$的数一共有$\sqrt[y]{N}$个</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020852314.webp" alt="image.png|600"></p><p>那么答案是这个吗？</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020853573.webp" alt="image.png|600"></p><p>比如$64$，$y&#x3D;2$的时候会被$8$算一次</p><p>$y&#x3D;3$的时候会被$4$算一次</p><p>$y&#x3D;6$的时候会被$2$算一次</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020855290.webp" alt="image.png|600"></p><p>要把它减掉</p><p>$-^6\sqrt{N}$</p><p>决定$y$次是加还是减呢？</p><p>可以用<del>莫比乌斯函数</del></p><p>先暴力</p><p>当算到$x^2$的时候$x^{4,6,8\dots}$都会被算</p><p>也就是$a$的倍数都要$+1$；</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">2</span>;a&lt;=<span class="number">64</span>;a++)</span><br><span class="line">&#123;</span><br><span class="line">    num[a]=<span class="number">0</span>;<span class="comment">//代表x的a次方这种形式的数被算了几次，它应该为1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">2</span>;a&lt;=<span class="number">64</span>;a++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//v表示x^a这种形式的数有多少个</span></span><br><span class="line">    <span class="comment">//pow要下取整，不能四舍五入</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> v=<span class="built_in">pow</span>(n,<span class="number">1.0</span>/a)<span class="number">-1</span>;<span class="comment">//减去1的a次方这个方案数，因为1^a会被算63次//pow(x,y)计算x的y次方--&gt;开a次方根，减去1次方</span></span><br><span class="line">    <span class="comment">//把1去掉</span></span><br><span class="line">    <span class="type">int</span> d=<span class="number">1</span>-num[a];<span class="comment">//代表这个数还要算几次/不应该被算多少次，因为最后要让每个num都是1//3,2,1,0,-1,-2...</span></span><br><span class="line">    <span class="comment">//d*v就是对答案的贡献,通过算了多少次就可以知道容斥系数</span></span><br><span class="line">    ans+=v*d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> b=a;b&lt;=<span class="number">64</span>;b+=a)</span><br><span class="line">    &#123;</span><br><span class="line">        num[b]+=d;<span class="comment">//b被算了这么多次，就把所有a的倍数都加上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans++;<span class="comment">//因为一开始就没算1，所以要加上1</span></span><br></pre></td></tr></table></figure></div><p>$pow(n,1.0&#x2F;a)&#x3D;\sqrt[a]{n}$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020930805.webp" alt="image.png|600"></p><p>$\because2^{log_2n}&#x3D;n$</p><p>$\therefore$原式$&#x3D;n^{\frac{1}{a}}$</p><p>$&#x3D;^a\sqrt{n}$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020932102.webp" alt="image.png|600"></p><p>$log$和$exp$在<code>cpp</code>里都是以$e$为底的</p><p>以什么为底都一样</p><p>$exp(x)$就是$e^x$</p><h1 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h1><h1 id="矩阵-1"><a href="#矩阵-1" class="headerlink" title="矩阵"></a>矩阵</h1><blockquote><p>矩阵乘法和前缀和很像</p></blockquote><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><p><strong>解方程</strong><br>$$<br>\begin{cases}<br>x_1+x_2&#x3D;2\<br>2x_1+3x_2&#x3D;5 \<br>\end{cases}<br>$$</p><p>$\begin{cases}{x_1}&#x3D;1\{x_2&#x3D;1}\end{cases}$</p><p>假如稍作变化呢？</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020937268.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020939573.webp" alt="image.png|600"></p><p>$n$个未知数</p><p>要解决$n$元一次方程，怎么解？</p><p>要<strong>把未知数消去</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020941862.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020941863.webp" alt="image.png|600"></p><p>$x1$就消失了</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020942049.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020942601.webp" alt="image.png|600"></p><p>$x1$也消失了</p><p>$(i)-(1)\cdot\frac{a_{11}}{a_{i1}}$</p><p>可以用第$i$个方程-第一个方程乘以$a11$分之$ai1$就可以把所有的$x1$消掉</p><p>只有$n-1$个方程，$n-1$个未知数了</p><p>不断减去第一行就可以消掉$x1$，剩下的方程不断减去第二行就可以消去$x2$,$\ldots$</p><p>不断这样做下去就可以做成一个方程，一个未知数</p><p>解出来后一步一步往回带，也可以变成只剩一个未知数</p><p>写一下代码</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020951435.webp" alt="image.png|600"></p><p><strong>i&#x3D;1</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305020958685.webp" alt="image.png|600"></p><p><strong>i&#x3D;2</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021000278.webp" alt="image.png|600"></p><p>会变成一个三角形</p><p>所以消元后</p><p>最后的方程会在最后一行</p><p>一般也就$100\to 200$</p><p>题目保证有唯一解</p><p>假如$a[i][i]&#x3D;0$?</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021009681.webp" alt="image.png|600"></p><p>任何一个$a[i][i]&#x3D;0$</p><p>这样拿第一个方程的$x1$消去其它方程的$x1$，没有办法消元，因为第一个方程压根就没有$x1$</p><p>所以我要用第$i$个方程消去$xi$要先保证有$xi$</p><p>可以交换</p><p>代码:</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="comment">// cin&gt;&gt;b[i];</span></span><br><span class="line">    cin&gt;&gt;a[i][n<span class="number">+1</span>];<span class="comment">//存b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a存系数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//消元</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j][i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">+1</span>;k++)</span><br><span class="line">                    <span class="built_in">swap</span>(a[i][k],a[j][k]);<span class="comment">//交换方程O(1)</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//要把xi从i+1个方程到第n个方程消掉</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="comment">//把xi从第j个方程开始消掉</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> ratio=a[j][i]/a[i][i];<span class="comment">//求应该变的系数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">+1</span>;k++)<span class="comment">//算上更新常数b</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[j][k]-=a[i][k]*ratio;<span class="comment">//每一个位置都要对应减，长度为n</span></span><br><span class="line">                <span class="comment">//单独减b比较麻烦</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)<span class="comment">//解方程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][n<span class="number">+1</span>]-=a[i][j]*x[j];<span class="comment">//把已经回带的未知数移到右边去</span></span><br><span class="line">        &#125;</span><br><span class="line">        x[i]=a[i][n<span class="number">+1</span>]/a[i][i];<span class="comment">//解一元一次方程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>$int$的话写不等于$0$就可以了</p><p>但是这里面所有的方程都是<code>double</code>类型的，不可以用<code>!=0</code>来判断</p><p>应该这样写</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i])&gt; <span class="number">1e-8</span>)<span class="comment">//fabs取绝对值，在10^-8以上，就不是0</span></span><br><span class="line">......</span><br><span class="line"><span class="type">double</span> ratio=a[j][i]/a[i][i];<span class="comment">//求应该变的系数</span></span><br></pre></td></tr></table></figure></div><p>但实际上这种高斯消元很容易被卡</p><h3 id="主元消元法"><a href="#主元消元法" class="headerlink" title="主元消元法"></a>主元消元法</h3><p>精度问题</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021035445.webp" alt="image.png|600"></p><p>换哪个呢？</p><p>一个会除以$0.1$</p><p>一个会除以$10$</p><p>数学意义上无所谓</p><p>但第二个会更好</p><p>除以$10$会更好</p><p>假如精度误差到了$0.01$的级别</p><p>$0.1$会使它波动到$0.09\to 0.1$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021038924.webp" alt="image.png|600"></p><p>第二个波动范围更小</p><p>因为误差会随着数一起变</p><p>数变大误差也就会变大，数变小误差也会变小</p><p>这里选的$a[i][i]$应该越大越好</p><p><strong>主元消元法：</strong></p><p>找到系数最大的那个作为被除数使最优的</p><p>假如系数和解都是整数呢？</p><p>可以存分子分母</p><p>也可以：</p><p>举个栗子：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021044736.webp" alt="image.png|600"></p><p>假如还是那么写，要乘$1.5$倍</p><p>那就可以把它们都变成各自的最小公倍数</p><p>这样就可以避免出现小数</p><p>但是不断求<code>LCM</code>这样系数可能会越来越大</p><p>所以要开<code>long long</code></p><p>要是<code>long long</code>还不行就得去用<code>double</code>的方法了</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a[][];</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="comment">// cin&gt;&gt;b[i];</span></span><br><span class="line">    cin&gt;&gt;a[i][n<span class="number">+1</span>];<span class="comment">//存b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a存系数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//消元</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j][i]!=<span class="number">0</span>)</span><br><span class="line">            <span class="comment">// if(fabs(a[j][i])&gt; 1e-8)//fabs取绝对值，在10^-8以上，就不是0</span></span><br><span class="line">            <span class="comment">// if(fabs(a[j][i])&gt; fabs(a[i][i]))//系数更大，就会使误差更小，也就更优，那就换</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">+1</span>;k++)</span><br><span class="line">                    <span class="built_in">swap</span>(a[i][k],a[j][k]);<span class="comment">//交换方程O(1)</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//要把xi从i+1个方程到第n个方程消掉</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="comment">//把xi从第j个方程开始消掉</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j][i]==<span class="number">0</span>) comtinue;</span><br><span class="line">            <span class="type">int</span> l=a[i][i]/<span class="built_in">gcd</span>(<span class="built_in">abs</span>(a[i][i]),<span class="built_in">abs</span>(a[j][i]))*a[j][i];<span class="comment">//lcm//可能有负数</span></span><br><span class="line">            <span class="type">int</span> retioi=l/a[i][i];</span><br><span class="line">            <span class="type">int</span> retioj=l/a[j][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">+1</span>;k++)<span class="comment">//算上更新常数b</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// a[j][k]-=a[i][k]*ratio;//每一个位置都要对应减，长度为n</span></span><br><span class="line">                a[j][k]=a[j][k]*retioj-a[i][k]*ratioi;</span><br><span class="line">                <span class="comment">//单独减b比较麻烦</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)<span class="comment">//解方程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][n<span class="number">+1</span>]-=a[i][j]*x[j];<span class="comment">//把已经回带的未知数移到右边去</span></span><br><span class="line">        &#125;</span><br><span class="line">        x[i]=a[i][n<span class="number">+1</span>]/a[i][i];<span class="comment">//解一元一次方程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h2><p>可以怎么用高斯消元呢？</p><p>输入一个数，输出一个数，一般可以打表</p><p>打表打不下的时候可以找规律</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021057735.webp" alt="image.png|600"></p><p>假设答案是关于$n$的一次方程</p><p>可以得到若干个方程</p><p>假如规律不对</p><p>那就把它当成$2$次的式子</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021100409.webp" alt="image.png|600"></p><p>在把$n&#x3D;4$带进去</p><p>若还不满足</p><p>再升幂</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021101450.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021101127.webp" alt="image.png|600"></p><p>次数比较低的时候可以手解</p><p>那么就可以枚举这个规律是几次的</p><p>那就把它带到下一项去验证</p><p>这样就可以找到规律</p><p>条件：一定是$n$的多少次方</p><h2 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a>矩阵求逆</h2><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021106592.webp" alt="image.png|600"></p><p>矩阵$I$叫做单位矩阵</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021107829.webp" alt="image.png|600"></p><p>假如$A\times{B}&#x3D;I$</p><p>矩阵$B$是矩阵$A$的逆矩阵</p><p>矩阵$A$是矩阵$B$的逆矩阵</p><p>怎么求逆矩阵呢？</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021110936.webp" alt="image.png|600"></p><p>$i&#x3D;j$的时候$&#x3D;1$</p><p>$i!&#x3D;j$的时候$&#x3D;0$</p><p>这样才能保证得到一个单位矩阵</p><p>$n^2$个未知数，$n^2$个方程，这样就可以把逆矩阵求出来了</p><p>那么这个的复杂度就会是$n^{2^3}$</p><p>也就是$n^6$</p><p>有亿点大</p><p>怎么优化呢？</p><p>用一个小小的<u>小技巧</u></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021116986.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021117476.webp" alt="image.png|600"></p><p>对角线有两个是$0$，它们所在的小矩阵，$1$变成了另一个对角线</p><p>这个矩阵可以<strong>交换第二行和第三行</strong></p><p><strong>可以动手算一下</strong></p><p>那假如是这个：</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021120083.webp" alt="image.png|600"></p><p>对角线为$1$</p><p>其实就是把第一行的两倍加到第二行上</p><p>就是把某一行的若干倍加到某一行上去</p><p>高斯消元的核心操作：交换某两行，把一行的若干倍加到某一行上去</p><p>高斯消元每一步相当于做矩阵乘法</p><p>一开始有个矩阵$A$</p><p>$A\times B&#x3D;I$</p><p>用高斯消元不断消$A$，把它消成$I$</p><p>正着消除一遍，再倒着消除一遍</p><p>就可以把矩阵化为$I$</p><p>其实就是乘了个$B$</p><p>把消元的过程中把同样的操作在矩阵$I$同样做一遍</p><p>就可以把$A\times B\to I$,$I\times B\to B$</p><p>就相当于对一个$n\times 2n$的矩阵消元</p><p>左边是$A$,右边是$I$</p><h1 id="概率和期望"><a href="#概率和期望" class="headerlink" title="概率和期望"></a>概率和期望</h1><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><p><strong>概率：一件事发生的可能性</strong></p><p>什么是事件呢？</p><p>比如扔骰子🎲，可能扔出${1,2,3,4,5,6}$</p><p>这六个数叫做样本空间</p><p>每一个值叫做一个样本点</p><p><strong>事件：几个样本点的集合</strong></p><p>$A&#x3D;{1}\to\frac16$</p><p>$A&#x3D;{1,2,3}\to\frac12$</p><ol><li>交集<ol><li>$A\cap{B}&#x3D;A\cdot{B}$</li><li>$A\cup{B}&#x3D;A+B$</li><li>$A-A\cdot B&#x3D;A-B$</li></ol></li></ol><p>那$A-B$是什么呢？</p><p>$A$里面在$B$种出现过的扔掉</p><p>就是$A$减去$A$和$B$的交集</p><p>除法呢？</p><p><strong>除以一个矩阵&#x3D;乘上它的逆矩阵</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021310051.webp" alt="image.png|600"></p><p>每个样本点的概率不一定是相等的</p><p>$A{1,2,3}&#x3D;A{1}+A{2}+A{3}$</p><h3 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h3><p>假如有个事件概率为$P(A)$</p><p>任何一个事件的概率都是$0\to 1$的一个实数</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021314630.webp" alt="image.png|600"></p><p>所有样本点的概率之和为$1$</p><p>$P(A)&#x3D;0$,叫做<strong>不可能事件</strong></p><p>$P(A)&#x3D;1$,叫做<strong>必然事件</strong></p><p>$P(A|B)$ <strong>条件概率</strong>：$B$发生的情况下，$A$发生的概率</p><p>看$B$事件的发生对$A$产生了何种影响</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021318047.webp" alt="image.png|600"></p><p>$B$事件改变了它的样本空间</p><p>$P(A|B)&#x3D;\frac 13$</p><p>再换个栗子</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021319834.webp" alt="image.png|600"></p><p>$P(A|B)&#x3D;A{1}+A{2}+A{3}&#x3D;\frac{1}{3}+0+\frac{1}{3}&#x3D;\frac 23$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021322346.webp" alt="image.png|600"></p><p>$P(A|B)&#x3D;\frac{P(AB)}{P(B)}&#x3D;\frac{\frac{1}{3}}{\frac{1}{2}}&#x3D;\frac{2}{3}$</p><p>一共六个样本点</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021324733.webp" alt="image.png|600"></p><hr><p><strong>独立事件</strong></p><p>$A$是否发生和$B$是否发生没有关系</p><p>$P(A)\times P(B)&#x3D;P(AB)$</p><p>$P(A|B)\times P(B)&#x3D;P(AB)$</p><p>$P(A)&#x3D;P(A|B)$</p><p>$A$发生的概率&#x3D;$B$事件发生的情况下$A$发生的概率</p><p>因此B时间的发生对$A$时间的发生没有影响</p><p>这个时候这两个事件就是独立的</p><p>比如扔两枚骰子🎲&#x2F;生两个孩子👶</p><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><p>扔一枚骰子🎲</p><p>每种情况发生的概率是$\frac {1}{6}$</p><p>扔出来的数的期望是什么？</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021333472.webp" alt="image.png|600"></p><p>用每一种情况的这个数去乘以这个情况的概率</p><p>第一种情况就是$1\times{\frac{1}{6}}$</p><p>第二种情况就是$2\times{\frac{1}{6}}$</p><p>$\ldots$</p><p>第六种情况就是$6\times{\frac{1}{6}}$</p><p>把这六个式子加起来就是数的期望</p><p>也就是扔出来数的平均值</p><p>每个事件有一个概率，每个事件有一个权值</p><p>权值$x$概率之和就是期望</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021336539.webp" alt="image.png|600"></p><p>扔出来数平方的平均值</p><p>假如十个测试点，输出$Y&#x2F;N$</p><p>假如我写了个<code>cout&lt;&lt;Y&lt;&lt;endl;</code></p><p>这个期望是$50$分</p><p>每个测试点有一半概率是$Y$一半概率是$N$，一个测试点是十分</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021339069.webp" alt="image.png|600"></p><p>假如概率不一样呢？</p><p>还是一样算</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021341638.webp" alt="image.png|600"></p><hr><h3 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h3><p>期望的和$&#x3D;$和的期望</p><p><em>一枚骰子灌铅，一枚骰子不灌铅</em></p><p>$E$代表期望</p><p>$E[x_1+x_2]$</p><p>两枚骰子有三十六种情况</p><p>得算一遍三十六种</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021346265.webp" alt="image.png|600"></p><p>再来几枚骰子呢？</p><p>这东西就没法算了</p><p>期望的和&#x3D;和的期望</p><p>$E[x_1+x_2]&#x3D;E[x_1]+E[x_2]$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021349184.webp" alt="image.png|600"></p><p>这个式子永远都可以用</p><p>即使有关系也可以用</p><p>假如要算$E[x_1+{x_1}^2]$</p><p>就是$&#x3D;E[x_1]+E[{x_1}^2]$</p><p>与它们独立不独立没有影响</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021403451.webp" alt="image.png|600"></p><p>$P(Black|Red)$</p><p>比如两面都是黑色的就被排除了</p><p>另一面的概率是黑色和红色概率真的一样吗？</p><p>选牌的时候，放哪面呢？</p><p>有六种情况</p><p>第一张牌：<code>红|红</code></p><p>第二张牌：<code>红|黑</code></p><p>第三张牌：<code>黑|黑</code></p><p>条件概率P(<code>下黑|上红</code>)&#x3D;P(<code>下黑上红</code>)$\div$P(<code>上红</code>)</p><p>分子是六分之一</p><p>分母是二分之一</p><p>最终的概率就是三分之一</p><p>因为第一张牌两面都是红色，拿它摆上来正面是红的概率要比一红一黑这张牌摆上来正面是红的概率要高</p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021410805.webp" alt="image.png|600"></p><p>公平：每个人中奖的概率是一样的</p><p>第一个人中奖的概率是$n$分之一</p><p>第二个人中奖的概率：第一个人没中奖的概率乘以第二个人中奖的概率</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021414382.webp" alt="image.png|600"></p><p>第三个人中奖的概率：第一个人第二个人没中奖的概率乘以第三个人中奖的概率</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021415542.webp" alt="image.png|600"></p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021416567.webp" alt="image.png|600"></p><p>条件概率</p><p>P(<code>男人</code>|<code>色盲</code>)&#x3D;P(<code>男人</code>$\times$<code>色盲</code>)除以P(<code>色盲</code>)</p><p>&#x3D;51%x2%&#x2F;51%x2%+49x0.25%</p><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021421358.webp" alt="image.png|600"></p><p>(1)取了$2n-m+1$次</p><p>哪个空了？</p><p>虽然取右边的概率比左边大</p><p>也有可能左边$(1-p)$先被取完</p><ol><li>右边口袋空了<ol><li>右边取</li></ol></li><li>左边口袋空了<ol><li>右边取了$n-m$次</li><li>左边取了$n+1$(又取了一次才发现空了)</li><li>第一次取到左边和第二次取左边的概率相同</li><li>$(1-p)^{(n+1)}p^{(n-m)}$把左边取光的概率是这个东西吗？</li><li>$(1-p)^{(n+1)}p^{(n-m)}$这个式子的意思实际上是顺序取的概率，完全可以交替取,是可以换顺序的，左于左之间是不计顺序的，一种情况的概率是这么多，那么这么多情况叠加起来就是要乘以情况数，因为不记顺序，所以是组合而不是排列（不清楚的可以回去看[[#组合数学|排列和组合的区别]]）；乘上C(2n-m,n)和乘上C(2n-m,n-m)其实是一回事，是相同的这么多次情况，所以没必要乘两遍</li><li>最后一次一定是左边，最后发现的时候是左边，前面还差$(2n-m)$次可以任意(<code>n次左</code>,<code>(n-m)次右</code>)</li><li>$(1-p)^{(n+1)}p^{(n-m)}\cdot C(2n-m,n)$,</li><li>两问，每问两种情况，一共有四种情况，这只是其中一种情况，记得乘上组合的方案数</li></ol></li></ol><p>(2)取了$2n-m$次</p><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021434242.webp" alt="image.png|600"></p><p>换不换都是一样的</p><h4 id="前置：三门问题"><a href="#前置：三门问题" class="headerlink" title="前置：三门问题"></a>前置：三门问题</h4><p>现在有三扇门，一扇门后面是车，另外两扇门后面是羊🐏，你想要车</p><p>你选了一个门，主持人打开另外两扇门中的一个</p><p>这扇门后面是羊🐏</p><p>换了是三分之二</p><p>不换是三分之一</p><p>和本题有什么区别呢？</p><p>这个问题出在小泽和主持人上</p><p>并不是同一个角色</p><p>主持人是知道哪扇门</p><p>主持人没有任何概率会打开车的那扇门</p><p>我选三个门的概率是一样的</p><p>枚举一下：</p><ol><li>我选了一号门</li></ol><p>不换二号门</p><p>不换二号门</p><ol start="2"><li>选了二号门 主持人打开三号门</li></ol><p>换一号门</p><ol start="3"><li>选了三号门，主持人打开二号门</li></ol><p>换一号门</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021442648.webp" alt="image.png|600"></p><h4 id="本题"><a href="#本题" class="headerlink" title="本题"></a>本题</h4><p>一共六种情况</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021444855.webp" alt="image.png|600"></p><p>这是一个条件概率</p><p>小泽死的情况下</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021444194.webp" alt="image.png|600"></p><p>我拿到的是好药</p><p>P(<code>好</code>,<code>挂</code>)除以P(<code>挂</code>)</p><p>小泽挂掉，分母是六分之四</p><p>小葱活下来，小泽挂掉，所以分母是六分之二</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021445527.webp" alt="image.png|600"></p><p>概率问题中，知道的信息量不一样就会导致事件的概率不一样</p><h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021449897.webp" alt="image.png|600"></p><p>哪边挂掉的概率小一些呢？</p><h4 id="1-1"><a href="#1-1" class="headerlink" title="(1)"></a>(1)</h4><p>第一条路不挂掉的概率&#x3D;${99}^{100}%$</p><h4 id="2-1"><a href="#2-1" class="headerlink" title="(2)"></a>(2)</h4><p>第二条路每个石头都不挂掉的概率是$99.9^{1000}%$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021454880.webp" alt="image.png|600"></p><p>这两个谁大？</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021454462.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021456219.webp" alt="image.png|600"></p><p>$$<br>\because\frac{999}{1000}&gt;\frac{998}{999}&gt;\frac{997}{998}\ldots &gt;\frac{990}{991}<br>$$</p><p>$$\therefore{\frac{999}{1000}}^{10}&gt;\frac{999}{1000}\cdot\frac{998}{999}\cdot\frac{997}{998}\ldots \cdot\frac{990}{991}&#x3D;\frac{990}{1000}&#x3D;\frac{99}{100}$$</p><h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021507295.webp" alt="image.png|600"></p><p>经过原点的概率？</p><p>首先有三个阶段</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021512528.webp" alt="image.png|600"></p><p>第二阶段的末尾和第三个阶段的起点很关键</p><p>而第一个阶段和第二阶段极端情况下可以走无穷步</p><p>也就是第一象限所有的点都有可能</p><p>也就是$\sum^{\infty}\limits_{x&#x3D;0}$$\sum^{\infty}\limits_{y&#x3D;0}$</p><p>第一阶段走到$(x,0)$,走$x$步，$x$次反面$(1-p)$，概率为$(1-p)^x$$\times p$</p><p>停下来的概率？</p><p>也就是抛一次正面的概率$p$</p><p>第二阶段走到$(x,y)$，走$y$步，$y$次反面，概率为$(1-p)^y\times p$</p><p>停下来的概率是$p$</p><p>走到$(x,y)$了，要走第三阶段，走回原点</p><p>$q$：向左走</p><p>$(1-q)$：向下走</p><p>要抛$x+y$次才能回到原点</p><p>恰好抛$x$次正面，$y$次反面才可以恰好回到原点</p><p>$q^x$*$(1-q)^y$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021519554.webp" alt="image.png|600"></p><p>但是还有组合顺序（不计内部顺序，详见[[#组合数学|排列组合]]和[[#4.|火柴]]）：$q^x$*$(1-q)^y$$\times C(x+y,x)$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021522894.webp" alt="image.png|600"></p><p>在$x+y$个位置找$x$:$C(x+y,x)$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021521918.webp" alt="image.png|600"></p><p>化简呢？</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021522343.webp" alt="image.png|600"></p><p>[[#4.组合数问题|求和变形]]:</p><ol start="4"><li><strong>变化量有两个：$x$和$y$，但是$x+y$随着$x$，$y$变化：换元法</strong></li></ol><p>令$t&#x3D;x+y$</p><p>$y&#x3D;t-x$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021526859.webp" alt="image.png|600"></p><p>枚举到$t$</p><p>那么怎么分离无关变量呢？</p><p>$p^2$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021527614.webp" alt="image.png|600"></p><p>右边这个东西是不是很眼熟？</p><p>[[#5.二项式定理|二项式定理]]</p><p>$(q+1-q)^t$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021529164.webp" alt="image.png|600"></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021529617.webp" alt="image.png|600"></p><p>这是一个<strong>等比数列求和</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021530256.webp" alt="image.png|600"></p><p>设它为$x$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021530253.webp" alt="image.png|600"></p><p>两式一减</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021531181.webp" alt="image.png|600"></p><p>$a$就是$(1-p)$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021532567.webp" alt="image.png|600"></p><p>一个零点几的数的无穷次方$&#x3D;0$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021533246.webp" alt="image.png|600"></p><p>那答案就是$p$</p><p><strong>全过程：</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021533868.webp" alt="image.png|600"></p><h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021536097.webp" alt="image.png|600"></p><p>三个矩阵都是$n\times{n}$的</p><p>看来不能直接乘，$n^3$会<code>TLE</code></p><p>可以不算整个矩阵，可以随机几个位置</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021539959.webp" alt="image.png|600"></p><p>如果有一个位置不相等，那么一定不同</p><p>但这样可以吗？</p><p>假如只有一个错的</p><p>随机到那一个错的概率是一百万分之一</p><p>这个方法过不了</p><p>有没有什么<strong>正确率高一点的随机方法</strong></p><p>现在的问题是矩阵$A$和$B$是算不出来的</p><p>造一个矩阵$D$</p><p>矩阵$D$大小为$n\times{1}$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021543345.webp" alt="image.png|600"></p><p>矩阵乘法有结合律</p><p>可以先算$BD$</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021544931.webp" alt="image.png|600"></p><p>反过来对吗？</p><p>假如$D$全是$0$</p><p>想想[[NOIP-数学#Miller-Rabin|miller]]</p><p>随机一个$D$</p><p>假如通过不了测试</p><p>那就不是；如果是，就再随机一个$D$</p><p>拿每个矩阵去算一下$ABD$和$CD$</p><p>每相等一次，相等的概率就会足够高</p><p><img lazyload src="/images/loading.svg" data-src="https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202305021548886.webp" alt="image.png|600"></p><p>加权求和并且错到一起的概率是相当低的</p><p>也就是这个的正确率是相当高的</p><p>$n$越大，加权求和的随机率越高，正确率越高</p></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>Title:</strong> NOIP-数学</li><li><strong>Author:</strong> Falling_Sakura</li><li><strong>Created at :</strong> 2023-04-29 08:03:50</li><li><strong>Updated at :</strong> 2025-09-24 10:07:14</li><li><strong>Link:</strong> https://vercel.fallingsakura.top/915ab73.html</li><li><strong>License: </strong>This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.</li></ul></div></div><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/668ad1af.html"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item truncate max-w-48">数据结构</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/48659.html"><span class="title flex justify-center items-center"><span class="post-nav-title-item truncate max-w-48">DP</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">Comments</div><div class="twikoo-container"><script data-swup-reload-script src="https://cdnjs.cloudflare.com/ajax/libs/twikoo/1.6.10/twikoo.all.min.js"></script><div id="twikoo-comment"></div><script data-swup-reload-script>function loadTwikoo() {
                twikoo.init({
                    el: '#twikoo-comment',
                    envId: 'https://twikoo.fallingsakura.top',
                });
            }

            if ('true') {
                const loadTwikooTimeout = setTimeout(() => {
                    loadTwikoo();
                    clearTimeout(loadTwikooTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadTwikoo);
            }</script></div></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">On this page</div><div class="page-title">NOIP-数学</div><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6"><span class="nav-number">1.</span> <span class="nav-text">基础数学</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%96%E6%A8%A1"><span class="nav-number">1.1.</span> <span class="nav-text">取模</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B6%E4%B9%98"><span class="nav-number">1.2.</span> <span class="nav-text">阶乘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD-LCM"><span class="nav-number">1.3.</span> <span class="nav-text">GCD&amp;LCM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-number">1.4.</span> <span class="nav-text">快速幂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E4%B9%98%E6%B3%95"><span class="nav-number">1.5.</span> <span class="nav-text">快速乘法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5"><span class="nav-number">1.6.</span> <span class="nav-text">矩阵</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA"><span class="nav-number">2.</span> <span class="nav-text">初等数论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%A8%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">质数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%86%E5%85%83"><span class="nav-number">2.2.</span> <span class="nav-text">逆元</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E5%85%83%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-number">2.2.1.</span> <span class="nav-text">逆元的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86"><span class="nav-number">2.2.2.</span> <span class="nav-text">费马小定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.3.</span> <span class="nav-text">欧拉定理&amp;欧拉函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E9%97%AE%E9%A2%98%EF%BC%9A%E6%B1%82n%E4%B8%AA%E6%95%B0%E7%9A%84%E9%80%86%E5%85%83"><span class="nav-number">2.2.4.</span> <span class="nav-text">小问题：求n个数的逆元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Miller-Rabin"><span class="nav-number">2.2.5.</span> <span class="nav-text">Miller-Rabin</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EXGCD"><span class="nav-number">2.3.</span> <span class="nav-text">EXGCD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8"><span class="nav-number">2.3.1.</span> <span class="nav-text">性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E9%A1%B9%E5%85%AC%E5%BC%8F"><span class="nav-number">2.3.2.</span> <span class="nav-text">通项公式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86"><span class="nav-number">2.3.3.</span> <span class="nav-text">中国剩余定理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%9B%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">筛法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%83%E5%BC%8F%E7%AD%9B"><span class="nav-number">2.4.1.</span> <span class="nav-text">埃式筛</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E7%AD%9B"><span class="nav-number">2.4.2.</span> <span class="nav-text">欧拉筛</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.3.</span> <span class="nav-text">求积性函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BSGS-Baby-Step-Giant-Step"><span class="nav-number">2.5.</span> <span class="nav-text">BSGS(Baby Step Giant Step)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6"><span class="nav-number">3.</span> <span class="nav-text">组合数学</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E5%AE%9A%E4%B9%89%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">引入定义式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8-1"><span class="nav-number">3.2.</span> <span class="nav-text">性质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-C-n-m-C-n-n-m"><span class="nav-number">3.2.1.</span> <span class="nav-text">1.C(n,m)&#x3D;C(n,n-m)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%F0%9F%9A%A9%E9%80%92%E6%8E%A8%E5%BC%8F"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.🚩递推式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-n%E4%B8%AA%E7%89%A9%E5%93%81%E9%9A%8F%E4%BE%BF%E9%80%89"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.n个物品随便选</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%A5%87%E6%96%B9%E6%A1%88-%E5%81%B6%E6%96%B9%E6%A1%88"><span class="nav-number">3.2.4.</span> <span class="nav-text">4.奇方案&#x3D;偶方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86"><span class="nav-number">3.2.5.</span> <span class="nav-text">5.二项式定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%F0%9F%93%8C%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E5%8D%B7%E7%A7%AF%EF%BC%88%E5%B1%95%E5%BC%80%E5%BC%8F%EF%BC%89"><span class="nav-number">3.2.6.</span> <span class="nav-text">6.📌组合数的卷积（展开式）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%BF%E4%BA%9B%E6%95%B0%E5%AD%A6%E9%A2%98"><span class="nav-number">3.3.</span> <span class="nav-text">亿些数学题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BB%84%E5%90%88"><span class="nav-number">3.3.1.</span> <span class="nav-text">1.组合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%BF%E7%82%B9%E4%BB%A3%E7%A0%81%E9%A2%98-%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86"><span class="nav-number">3.4.</span> <span class="nav-text">亿点代码题(卢卡斯定理)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BB%84%E5%90%88%E6%95%B0%E6%8B%86%E8%A7%A3"><span class="nav-number">3.4.1.</span> <span class="nav-text">1.组合数拆解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%AF%94%E8%BE%83%E7%BB%84%E5%90%88%E6%95%B0%E5%A4%A7%E5%B0%8F"><span class="nav-number">3.4.2.</span> <span class="nav-text">2.比较组合数大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%89%BE%E6%9C%80%E5%A4%A7%E7%BB%84%E5%90%88%E6%95%B0"><span class="nav-number">3.4.3.</span> <span class="nav-text">3.找最大组合数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.4.</span> <span class="nav-text">4.组合数问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86"><span class="nav-number">3.5.</span> <span class="nav-text">抽屉原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%AD%A3%E6%96%B9%E5%BD%A2%E8%A6%86%E7%9B%96"><span class="nav-number">3.5.1.</span> <span class="nav-text">1.正方形覆盖</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86"><span class="nav-number">3.6.</span> <span class="nav-text">容斥原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#n%E5%AF%B9%E5%A4%AB%E5%A6%BB%E9%97%AE%E9%A2%98"><span class="nav-number">3.6.1.</span> <span class="nav-text">n对夫妻问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x%E7%9A%84y%E6%AC%A1%E6%96%B9"><span class="nav-number">3.6.2.</span> <span class="nav-text">x的y次方</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%9F%BA"><span class="nav-number">4.</span> <span class="nav-text">线性基</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5-1"><span class="nav-number">5.</span> <span class="nav-text">矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83"><span class="nav-number">5.1.</span> <span class="nav-text">高斯消元</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%85%83%E6%B6%88%E5%85%83%E6%B3%95"><span class="nav-number">5.1.1.</span> <span class="nav-text">主元消元法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%96%B9%E7%A8%8B"><span class="nav-number">5.2.</span> <span class="nav-text">解方程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86"><span class="nav-number">5.3.</span> <span class="nav-text">矩阵求逆</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E7%8E%87%E5%92%8C%E6%9C%9F%E6%9C%9B"><span class="nav-number">6.</span> <span class="nav-text">概率和期望</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E7%8E%87"><span class="nav-number">6.1.</span> <span class="nav-text">概率</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8-2"><span class="nav-number">6.1.1.</span> <span class="nav-text">性质</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%9F%E6%9C%9B"><span class="nav-number">6.2.</span> <span class="nav-text">期望</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8-3"><span class="nav-number">6.2.1.</span> <span class="nav-text">性质</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem"><span class="nav-number">6.3.</span> <span class="nav-text">Problem</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1"><span class="nav-number">6.3.1.</span> <span class="nav-text">1.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2"><span class="nav-number">6.3.2.</span> <span class="nav-text">2.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3"><span class="nav-number">6.3.3.</span> <span class="nav-text">3.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4"><span class="nav-number">6.3.4.</span> <span class="nav-text">4.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5"><span class="nav-number">6.3.5.</span> <span class="nav-text">5.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6"><span class="nav-number">6.3.6.</span> <span class="nav-text">6.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7"><span class="nav-number">6.3.7.</span> <span class="nav-text">7.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8"><span class="nav-number">6.3.8.</span> <span class="nav-text">8.</span></a></li></ol></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="customize-info my-1">人类的悲欢本不相通我只觉得他们吵闹.</div><div class="text-center">&copy; <span>2023</span> - 2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">Falling_Sakura</a><p class="post-count space-x-0.5"><span>33 posts in total </span><span>176.7k words in total</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">VISITOR COUNT</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">TOTAL PAGE VIEWS</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span> <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span></div><div>Blog up for <span class="odometer" id="runtime_days"></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec</div><script data-swup-reload-script>try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/Swup.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/SwupSlideTheme.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/SwupProgressPlugin.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/SwupScrollPlugin.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });</script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/tools/imageViewer.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/utils.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/main.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/layouts/navbarShrink.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/tools/scrollTopBottom.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/tools/lightDarkSwitch.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/layouts/categoryList.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/tools/localSearch.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/tools/codeBlock.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/layouts/lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/tools/runtime.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/assets/odometer-theme-minimal.css"><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/Typed.min.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/plugins/typed.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/mermaid.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/plugins/mermaid.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/minimasonry.min.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/plugins/masonry.js"></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/plugins/tabs.js" data-swup-reload-script></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script><script type="module" src="https://cdn.jsdelivr.net/npm/hexo-theme-redefine@2.8.5/source/js/build/layouts/essays.js" data-swup-reload-script></script></body></html>